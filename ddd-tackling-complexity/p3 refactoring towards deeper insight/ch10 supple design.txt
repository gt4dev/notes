ch10 supple design

- sw ze zlym design'em, skomplikowany - trudno zmieniac
- co znaczy ze nie mozna go rozwijac

// en: supple - gietki

- supple design is the COMPLEMENT to deep modeling

flow
- masz model, refine'ujesz go [implicit concepts you make explicit] - masz 'raw material'

- zeby laczyc elements w czytelny complex system to model [mdd] musi byc polaczony by 'rigorous design style'

- design of sw musi wspierac zmiany w tym sw

- efekt dzialania kodu musi byc 'transparently obvious' [mega oczywisty]
- dzieki czemu konsekwencje zmiany beda latwe do przewidzenia

- early version of design are usually stiff
- ale kiedy complexity zatrzymuje progres to wymusza to zmiane design'u

- there is NO formula for designing "easy changable sw"
- EE prezentuje kilka patterns ktore sie w tym sprawdzaja

c: ee nie widzial sw ktory mialy nice desgin w calym zakresie


ch10.1 intention revealing interface

- interfejs obiektow [publiczne api: nazwa metody, types of params, returned] powinien mowic dev'owi jak uzywac obiektu
- inaczej bedzie musial sprawdzac implementacje - zeby zrozumiec jak dziala
- a to 'zgubi' efekt enkapsulacji
// g: czy ee nie przesadza?
- zwieksza sie congitive overload
- bo dev is flooded with details 'how component does a job'
- a powinien skupic sie na kodzie klienta ktory wola dany komponent

vin
- if dev must consider a impl of component [in order to use it] - value of encaps. is lost

- klasy i metody musza miec nazwy ktore odzwierciedlaja koncpecje z modelu

vin
- name classes and operations to describe EFFECT AND PUROPSE without ref to means by which they do it
- nazwy [z UL] powinny oddawac intencje 'po co to jest' a nie 'co to robi w srodku'

- dzieki temu dev klienta naszego obiektu nie bedzie musial znac internals of our object

- best: write uTest - ktory wymusi na Tobie "client PoV" na metody obiektu

example: refactor a paint mixing app
- trywialny example
- v0: mamy metode Paint.paint(Paint) // metoda miesza rozne farby
- v1: rename it   Paint.mixIn(Paint  // nazwa mixIn oddaje intencje "mixowania paints"

vin
- new name 'mixIn' doesn't tell everything about EFFECT of mixIn
- for that we'll use assertions [next, next chapter]


ch10.2 side-effect-free functions


mamy operacje
- commands - modyfikuja dane
- queries - wyciagaja dane

- interakcje wielu rules + kompozycje kalkulacji sa EXTREMLLY difficult to predict
- dev calling that hard operation must understand its implementaitons and impls of ALL its delegations - to predict result

- uzytecznosc any impl of interface is lost if caller must look into impl. details
- devs musz miec easy predicable abstracts - inaczej zgubia sie w analizie kombinacji algs [combinatory explosion]

- functions = operacje bez side effects [queries]

ways of mitigating command problems [tj doing by them side-effects]
1
- keep c and q separated in diff operations
- ensure that commands doesn't return DOMAIN data
- c should be ASimpleAP [zeby nie komplikowac ich analizy]
- all queries/calculations - do in SEFF
2 
- bardzo czesto:
  - zamiast modyfikowac current object
  - zwroc nowy vo - reprezentujacy rezultat kalkulacji
- it's common technique

- funk masz obowiazkowo na vo-sach, ale e, ds tez moga miec f
- z def. commands masz tylko na e-sach [bo vo-sy sa immutable]

- met. ktore sa maja responsibilities of Q + C - powinny byc refactored, zeby je rozdzielic
- skompl. kalkulacje przenies do vo-sa

- b. wiele SE mozna wyeliminowac - przenoszac logike do vo-sow

// g: vm chyba tez da sie modyfikowac [jak e]

sample: refactor Paint.mixIn(Paint)
- mixIn robimy SEFF
- wydzielamy z Paint - PigmentColor i metode mixWith // SEFF


ch10.3 assertions


- commands called on e-s cause side-effects
- anyony calling C must understand these SE
- assertions make SE explicit and easier to deal with

- to wazne dla commands ktore wywoluje inne commands etc... te juz trudno zrozumiec

problem: 
- SE of C are implicitly visible in impl.
- nie widzimy SE patrzac na interfejs obiektu

- there must be means to see SE w/o analysing opetaion logic
- wprowadzamy elementy tzw. design by contract
- na koncu metody robiacej SE - sprawdzamy POST-CONDITIONS [chociaz nie tyle "sprawdzamy" co explicit pokazujemy zmiane]
- w post-conditions sprawdzamy invariany/stan [metody, klasy, agregatu] po C
- wiec nie jest to explicit wskazanie zmiany po C
- na koniec C trzeba sprawdzic ALL modified states - to give this tech sense

- assertions w post-conditions sa "identyczne" z assert'ami w unit-test
- np: 
  - mieszasz paint1 z paint2 
  - to na koniec sprawdzash assert(paint1.size + paint2.size = paint3.size)

- vi: assercje mozesz pokazac w UT'ach - a nie w main code

- assertions desc state [not procedure] - so they are easy to analyse

// g: te assercje troche smierdza - duzo zalezy od jakosci ich impl., moga wrecz wprowadzac w blad


ch10.4 conceptual contours


- jak mamy monolityczny construct to trudon go zrozumiec, concepty sa zmix'owane
- ale tez podzielenie zbyt drobne moze skomplikowac strone klienta [klient musi wiedziec jak poszczeg. klocki dzialaja razem]
- a nawet moze byc utracony jakis wazny koncept doemny

- cookbook rules don't work - tech. zasady podzialu softu nie dzialaja
- zwykle w doamains jest jakis logiczna struktura deep domains

c: zastrzezenia do spojnosci domen [acz zwykle jest ok]
- acz nie wszyskie domeny sa spojne!!!
- nie wszyscy eksperci 
  - maja spojne/jedno zdanie nt jak powinna dzialac domena
  - potrafia sie spojnie wyrazic
  
r-s: high cohesion, low coupling are important 
- at ALL scales: from methods, to classes, modules to large scale structures
- ale tez w concepts modelu

vi
group design elements [operations, interfaces, classes, aggs] into cohesive units
taking into cosideration your INTUITION ab. divisions in domain

w tych podzialach 'wypatruj' conceptual contour [acz to dosc vague def]

the goal is simple set of interfaces that combine logically to make sensible statements in UL
and w/o distractions of irrelevant options

czystosc modelu/kodu jest efekten cont. refactoring
ale to refactor modelu a nie tech. refactor

summary
- intention revealing interfaces allow clients to see objects as units of meaning
- seff + assertions - make using these units safe and make complex combinations
- conceptual contours - stabilizuje czesci modelu

// g: cc to p/p "kontur koncepcji" tj. na poziomie modelu wyznaczony 'kontur' grupuje koncepty z high cohesion i jednoczesnie miedzy konturami mamy low coupling


ch10.5 standalone classes


- dependencies make model/code hard [to code/change/maintain ..]

- kazda assoc tworzy zaleznosc
- zrozumienie klasy wymaga zrozumienia jej samej i all elems od ktorych zalezy [i od ktorych te klasy zaleza ..]

- kazdy param, returned result - tez tworza dep - ktore trzeba zrozumiec

- both: modules/aggs are aimed to limit the web of interdependencies

- im wiecej elems w module - tym wiekszy mental overload
- problem sie zwieksza jesli masz 'implicit conepts' thus use 'explicit concepts' [are easier to grasp]

- in well distilled subset of domain - the concept deps can [usually] be reduced to ZERO [yes, zero]
- mozesz te klase zrozumie as is [bez zadnych deps]

- low coupling is fundamental to object design

- if you can - eliminate all concepts and make class self-containd [w/o deps], understood alone
- // g: acz to troche sciema: bo all classes deps on others - cholera wie jak ee chce wyeliminowac deps ...

- standalone classes - to extremum, rzadko widziane - wiekszosc class bedzie zalazala od innych
- acz mozesz wyeliminowac all NON-ESSENTIAL deps
- z core concepts - mozesz zejsc do standalone class [w modelu np: customer, ..]

- ale standalone - moga byc tez complex algs [zaszyte w vo-ach]
- wydzielone, niezalezne od innych - latwiej je analizowac


ch10.6 closure of operations


7.16 16.28.54


ch10.7 declarative design


ch10.7.1 domain specific languages


ch10.8 declarative style of design


ch10.8.1 extending spec in a declarative style


ch10.9 angles of attach


ch10.9.1 carve off subdomains


ch10.9.2 draw on estabilished formalizms, when you can

