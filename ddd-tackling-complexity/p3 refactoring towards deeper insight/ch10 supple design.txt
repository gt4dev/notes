ch10 supple design
// en: supple - gietki

- sw ze zlym design'em - trudno zmieniac - nie mozna rozwijac

- supple design is the COMPLEMENT to deep modeling
// g: bo pozwala utrzymac czytelnie zakodowany model

- zeby laczyc elementy w czytelny complex system - model musi byc zbudowany wg 'rigorous design style'

- EFEKT DZIALANIA KODU MUSI BYC 'TRANSPARENTLY OBVIOUS' [MEGA OCZYWISTY]
- DZIEKI TEMU KONSEKWENCJE ZMIANY KODU BEDA LATWE DO PRZEWIDZENIA

zwykle
- EARLY version of design is stiff
- ale kiedy complexity zatrzymuje progres to wprowadza sie zmiany design'u

- there is NO formula for designing "easy changable sw"
- EE prezentuje kilka patterns ktore sie mu sprawdzaja

c: ee nie widzial sw ktory mialy nice desgin w calym zakresie


ch10.1 intention revealing interface


- interfejs obiektow [nazwy metody, types of params, result] powininny mowic dev'owi jak uzywac obiektu
- inaczej bedzie musial sprawdzac implementacje - zeby zrozumiec jak dziala
- a to 'zgubi' efekt enkapsulacji
// g: czy ee nie przesadza?
- more: zwieksza sie cognitive overload
- more: dev 
  - skupia sie na 'how component does a job'
  - a powinien na kodzie klienta [ktory wola komponent]

vin
- if dev must consider a impl of component [in order to use it] - value of encaps. is lost

- klasy i metody musza miec nazwy ktore odzwierciedlaja koncpecje z modelu

VIN
- NAME CLASSES AND OPERATIONS TO DESCRIBE EFFECT AND PUROPSE WITHOUT REF TO MEANS BY WHICH THEY DO IT
- NAZWY [Z UL] POWINNY ODDAWAC INTENCJE 'PO CO TO JEST' A NIE 'CO TO ROBI W SRODKU'

- write uTest - ktory wymusi na Tobie "client PoV" na metody obiektu

example: refactor a paint mixing app
- trywialny example
- v0: mamy metode Paint.paint(Paint) // metoda miesza rozne farby
- v1: rename it   Paint.mixIn(Paint) // nazwa mixIn oddaje intencje "mixowania paints"

vin
- new name 'mixIn' doesn't tell everything about EFFECT of mixIn
- for that we'll use assertions [next, next chapter]


ch10.2 side-effect-free functions


mamy operacje
- commands - modyfikuja dane
- queries - wyciagaja dane

- mixing many C/Q in 1 oper gives code EXTREMLLY difficult to predict

- uzytecznosc any impl of interface is lost if caller must look into impl. details
- devs musza miec easy predicable abstracts - inaczej zgubia sie w analizie kombinacji algs [combinatory explosion]

- function = operacja bez side effects [query]

ways of mitigating command problems [tz their side-effects]
1
- keep c and q separated in diff operations
- ensure that commands doesn't return DOMAIN data
- c should be A-Simple-AP [zeby nie komplikowac ich analizy]
- all queries/calculations - do in SEFF
2 
- bardzo czesto:
  - zamiast modyfikowac current object
  - zwroc nowy vo - reprezentujacy rezultat kalkulacji

- SEFF masz obowiazkowo na vo-s, ale teoretycznie e, ds tez moga je miec
- commands masz tylko na e-sach [bo vo-sy sa immutable]

- refactor methods ktore sa maja responsibilities of Q + C
- skompl. kalkulacje przenies do vo-s

- b. wiele side-effects mozna wyeliminowac - przenoszac logike do vo-sow

// g: vm chyba tez da sie modyfikowac [jak e]

sample: refactor Paint.mixIn(Paint)
- mixIn robimy SEFF
- wydzielamy z Paint - PigmentColor i metode mixWith // SEFF


ch10.3 assertions


- commands called on e-s cause side-effects [SE]
- anyone calling C must understand its SE
- assertions make SE explicit and easier to deal with
- to szczgolnie wazne dla commands ktore wywoluje inne commands etc... 

problem:
- SE of C are implicitly visible in impl.
- nie widzimy SE patrzac na interfejs obiektu

- to see SE w/o analysing operataion code - we can use elems of design by contract
- na koncu metody robiacej SE - sprawdzamy POST-CONDITIONS [chociaz nie tyle "sprawdzamy" co explicit pokazujemy zmiane]
- w post-conditions [of C] sprawdzamy invariany/stan [metody, klasy, agregatu]
- wiec nie jest to explicit wskazanie zmiany po C
- na koniec C trzeba sprawdzic ALL modified states - to give this tech sense

- assertions w post-conditions sa "identyczne" z assert'ami w unit-test
- np: 
  - mieszasz paint1 z paint2 
  - to na koniec sprawdzasz assert(paint1.size + paint2.size = paint3.size)

- vi: assercje mozesz pokazac w UT'ach - a nie w main code

- assertions desc state [not procedure] - so they are easy to analyse

// g: ale tez assercje troche smierdza - duzo zalezy od jakosci ich impl., moga wrecz wprowadzac w blad


ch10.4 conceptual contours


- jak mamy monolityczny construct to trudon go zrozumiec, concepty sa zmix'owane
- ale tez podzielenie zbyt drobne moze skomplikowac strone klienta [klient musi wiedziec jak poszczeg. klocki dzialaja razem]
- nawet moze byc utracony jakis koncept doemny

- cookbook rules don't work - tech. zasady podzialu softu nie dzialaja
- zwykle w domains jest jakas logiczna struktura deep domains

c: zastrzezenia do spojnosci domen [acz zwykle jest ok]
- nie wszyskie domeny sa spojne!!!
- nie wszyscy eksperci 
  - maja spojne/jedno zdanie nt jak powinna dzialac domena
  - potrafia sie spojnie wyrazic
  
r-s: high cohesion, low coupling are important 
- at ALL scales: from methods, to classes, modules to large scale structures
- ale tez w concepts modelu

vi
group design elements [operations, interfaces, classes, aggs] into cohesive units
use your INTUITION to divide domain

w tych podzialach 'wypatruj' conceptual contour [acz to dosc vague def]

the goal is simple set of interfaces that combine logically to make sensible statements in UL
and w/o distractions of irrelevant options

summary
- intention revealing interfaces allow clients to see objects as units of meaning
- seff + assertions - make using these units safe and make complex combinations
- conceptual contours - stabilizuje czesci modelu


ch10.5 standalone classes


- dependencies make model/code hard [to code/change/maintain ..]

- zrozumienie klasy wymaga zrozumienia jej samej i all elems od ktorych zalezy [i od ktorych te klasy zaleza ..]

- kazdy param, returned result - tez tworza dep - ktore trzeba zrozumiec

- both: modules/aggs are aimed to limit the web of interdependencies

- im wiecej elems w module - tym wiekszy mental overload
- problem sie zwieksza jesli masz 'implicit concepts'
  - thus make them 'explicit' [are clearer]

- in well distilled subset of domain - the concept deps can [usually] be reduced to ZERO [yes, zero]

- low coupling is fundamental to object design

- standalone classes - to rzadko widziane - wiekszosc class bedzie zalazala od innych
- acz mozesz wyeliminowac all NON-ESSENTIAL deps
- z core concepts - mozesz zejsc do standalone class [w modelu np: customer, ..]

- ale standalone - moga byc tez complex algs [zaszyte w vo-ach]
- wydzielone, niezalezne od innych - latwiej je analizowac

- std bedziesz mial duuuzo deps - to normalne i porzadane - pod warunkiem ze sa really required


ch10.6 closure of operations


- c: pojecie 'closure' pochodzi z math
- jesli operacja [np. +] dziala na liczbach rzeczywistych to efekt tez jest liczba rzeczywista [domkniecie matematyczne]

- jesli mozliwe - zwracaj z metody typ ktory jest taki sam jak args tej metody
- zaleta: closure - provides interface without introducing any dependency/new concept [bo ma 1 typ]

- c uzywamy glownie z vo-s
- czasem [rzadko] mozesz miec e np. Employee z meth: GetSupervisor():Employee

- type in/out moga byc abstract [a w realu rozne konkretne typy]

- forma posrednia c: metoda ma arg. identyczne jak 'this' ale zwracaja nowy typ
- to nie jest closed operation ale ma czesc zalet closures

sample: selecting from collections
// g: Java bezposrednio nie ma CL operations na listach, C# ma przez linq
- c: wg EE w Java nie ma takich opers // g: ale sa libs
- myDotNetCollection.Where(i => i.cash > 100)   <<< zwraca inna kolekcje, tego samego typu


vvv cont here


ch10.7 declarative design


vin about assertions / intention revealing
- ee wspomina ze assertions sa super ale nie mozna miec ZADNYCH gwarancji w hand-written sw
- bo niektore assertions moga byc niepotrzebna lub moze ich brakowac
// g: najblizsze idei 'ee-assetions' sa p/p asercja z unit tests
// - UT cos robi i sprawdzasz co sie zmienilo
// - ale to dosc HC w analizie [zeby zrozumiec co sie zmienia po call of method-command] i niepewne [jak w/w napisane]
- intention revealing - moze tez miec ten problem - kod moze 'wprowadzac w blad'

- declarative design to [posrednio] odpowiedz na w/w problemy ["klamania" w assetions/intention revealing interface]
- dd = way of writing program as kind of executable specification
- generowanie executable spec - moze miec wiele form - przez
  - przez reflekscje
  - przez std generowanie kodu [ze specyfikacji]

problemy z generowaniem kodu
- languages nie sa wystarczajaca expresyjne zeby opisac domene
- wygen. kod ciezko laczyc z 'hand written code' - jest hc


ch10.7.1 domain specific languages


- dsl czasem sa deklaratywne

- tworzymy jezyk z ktorego generujemy kod

problem
- trudno pisac dsl - zeby nadarzaly za zmianami w modelu [ciezko zmieniac gramatyke dsl, to wymaga skill'a]


ch10.8 declarative style of design


ch10.8.1 extending spec in a declarative style


- c: pattern spec jest forma 'predykatu'

- przy spec czesto chcesz je kombinowac, laczyc

- spec to predykat a predykaty mozna laczyc [std operatorami and, or, not i innymi operacjami]

- bazowy interf. WSZYSTKICH spec
public interface Specification {
  // v0
  isSatisfiedBy(object o);
  // v1 - jesli laczysz specs; n: these are "closure opers"
  Specification and(Specification s);
  ...            or(..);
  ...           not(); // n: bez param
}
- acz nie wszyskie w/w opers potrzebujes
- a czasem potrzebujesz innych operacji laczenia specs, eg. subsume(Spec..)


sample - laczenie specs
Specification ventilated = new ....;
Specification armored = new ....;

Specification both = ventilated.and(armored);
Specification either = ventilated.or(armored);


sample - impl. or/and/.. -> see book
- rozne specs wymagaja roznych impls [vide sql spec ..]


ch10.9 angles of attach


wstep do calego ch10
- all techs presented here maja na celu
  - clarify intention of code
  - make consequences of calling it - transparent [know side effects?]
  - decouple model elements
  
// g: czy aktualna wiedza nt supple designs z ch10 sie zmienila od 2004?


ch10.9.1 carve off subdomains


- nie mozesz 'walczyc' z designem calej apki 'na raz'
- znajdz fragment systemu, wydziel go i zastosuj supple designs [refactor code]
- szukaj fragmentu domeny [calej subdomeny], a nie technicznego: jakies wyliczenia, rule bizneswoe ...

c
- lepiej dobrze i w calosci naprawic fragment
- niz po troche refactor'owac w calym systemie


ch10.9.2 draw on estabilished formalizms, when you can


// cut

EXAMPLE
- przyklad na bazie 'sindicated loan system' ["pozyczka dla intel'a"]

separating commands and queries
- problem to fix: Loan ma metode ktora robi i calcs i zmiania stan Loan
- fix: rozbicie jej na command and query - client calls:
                                                  // g: skoro metoda zwraca:
  Map distribution = aLoan.calculateSth(sthElse); // cos - to jest pp query/SEFF
  aLoan.applyPayments(distribution);              // nic - to jest pp cmd

- TEN CASE SUPER POKAZUJE MOC CMD/Q[/IMMUT.] - jest super czytelnie!!!!!!!
- c: w/w seff wcale nie musi uzywac immutable objects - to 2nd'ary problem
- sam cmd wcale nie musi byc "1 LoC"
  - moze calkiem ostro grzebac po modelu
  - ale niech nic nie liczy
  
// g:q: jakim typem metody [q czy c] jest klient - bo wywoluje on obliczenia a potem zmienia stan

// g-btw
- przyklad Loan fajnie pokazuje jak rozsiac kalkulacje po kilku obiektach
- normalnie robiles metody 'kalkulatory' i przekazywales im dane wejsciowe [anemiczne klasy]
- EE cale kalkulacje pieknie rodzielil na kilka klas

 | <e>  |          | <vo>      |               | <pp vo> |  
 | Loan |<>------->| Share Pie | owner ]<>---->|  Share  |
 |      |          |           |               |         |  


making implicit concepts explicit
- dodanie explicit klasy SharePie - uproscilo algs, model ... - obvious ;]
- mega c
  - caly alg kalkulacji kredytu dla intela jest rozdezielony na 3 w/w klasy!!! 
  - zwykle robiles to alg w 1 metodzie - a tu - rodzielenie alg na 3 klasy - UPRASZCZA KOD!!!
  

SharePie becomes VO
- ee refactors metody tak by zrobic z nich SEFF [plus 'closure' bo zwracaja SharePie]
- troche z tym roboty
- ale kod jest duuuzo czytelniejszy [z seff]

// g: mega c
- dla algs zaszytych w modelu - KOMPLETNIE nie ma znaczenia czy to e czy vo
  - oprocz LL tech kwestii: modyfikacji e, ident. e by id ...
- alg cos po prostu liczy na bazie stanu klasy, ew. zmienia stan klasy ...
- pomijam tu ew. technikalia jak immutability of vo, granice agregatu ... to detale ;]
- a zapis stanu obiektu do bazy - to problem repo


sample - po refactorze
- udalo sie wyizolowac complex logic do VO [tak, do vo] i zamknac teo w SEFF
// g: sample obliczen gdzie SEFF zwraca nowy obiekt zamiast modyfikowac 'this' 
// - wygladaja REWELKA
// - latwo sie to analizuje [nie wnikasz jakie inne metody obiekt modyfikuja, masz po each call "nowy obiekt" i na nim robisz next method call ..]