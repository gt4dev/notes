ch10 supple design

- sw ze zlym design'em, skomplikowany - trudno zmieniac
- co znaczy ze nie mozna go rozwijac

// en: supple - gietki

- supple design is the COMPLEMENT to deep modeling

flow
- masz model, refine'ujesz go [implicit concepts you make explicit] - masz 'raw material'

- zeby laczyc elements w czytelny complex system to model [mdd] musi byc polaczony by 'rigorous design style'

- design of sw musi wspierac zmiany w tym sw

- efekt dzialania kodu musi byc 'transparently obvious' [mega oczywisty]
- dzieki czemu konsekwencje zmiany beda latwe do przewidzenia

- early version of design are usually stiff
- ale kiedy complexity zatrzymuje progres to wymusza to zmiane design'u

- there is NO formula for designing "easy changable sw"
- EE prezentuje kilka patterns ktore sie w tym sprawdzaja

c: ee nie widzial sw ktory mialy nice desgin w calym zakresie


ch10.1 intention revealing interface

- interfejs obiektow [publiczne api: nazwa metody, types of params, returned] powinien mowic dev'owi jak uzywac obiektu
- inaczej bedzie musial sprawdzac implementacje - zeby zrozumiec jak dziala
- a to 'zgubi' efekt enkapsulacji
// g: czy ee nie przesadza?
- zwieksza sie congitive overload
- bo dev is flooded with details 'how component does a job'
- a powinien skupic sie na kodzie klienta ktory wola dany komponent

vin
- if dev must consider a impl of component [in order to use it] - value of encaps. is lost

- klasy i metody musza miec nazwy ktore odzwierciedlaja koncpecje z modelu

vin
- name classes and operations to describe EFFECT AND PUROPSE without ref to means by which they do it
- nazwy [z UL] powinny oddawac intencje 'po co to jest' a nie 'co to robi w srodku'

- dzieki temu dev klienta naszego obiektu nie bedzie musial znac internals of our object

- best: write uTest - ktory wymusi na Tobie "client PoV" na metody obiektu

example: refactor a paint mixing app
- trywialny example
- v0: mamy metode Paint.paint(Paint) // metoda miesza rozne farby
- v1: rename it   Paint.mixIn(Paint  // nazwa mixIn oddaje intencje "mixowania paints"

vin
- new name 'mixIn' doesn't tell everything about EFFECT of mixIn
- for that we'll use assertions [next, next chapter]


ch10.2 side-effect-free functions


mamy operacje
- commands - modyfikuja dane
- queries - wyciagaja dane

- interakcje wielu rules + kompozycje kalkulacji sa EXTREMLLY difficult to predict
- dev calling that hard operation must understand its implementaitons and impls of ALL its delegations - to predict result

- uzytecznosc any impl of interface is lost if caller must look into impl. details
- devs musz miec easy predicable abstracts - inaczej zgubia sie w analizie kombinacji algs [combinatory explosion]

- functions = operacje bez side effects [queries]

ways of mitigating command problems [tj doing by them side-effects]
1
- keep c and q separated in diff operations
- ensure that commands doesn't return DOMAIN data
- c should be ASimpleAP [zeby nie komplikowac ich analizy]
- all queries/calculations - do in SEFF
2 
- bardzo czesto:
  - zamiast modyfikowac current object
  - zwroc nowy vo - reprezentujacy rezultat kalkulacji
- it's common technique

- funk masz obowiazkowo na vo-sach, ale e, ds tez moga miec f
- z def. commands masz tylko na e-sach [bo vo-sy sa immutable]

- met. ktore sa maja responsibilities of Q + C - powinny byc refactored, zeby je rozdzielic
- skompl. kalkulacje przenies do vo-sa

- b. wiele SE mozna wyeliminowac - przenoszac logike do vo-sow

// g: vm chyba tez da sie modyfikowac [jak e]

sample: refactor Paint.mixIn(Paint)
- mixIn robimy SEFF
- wydzielamy z Paint - PigmentColor i metode mixWith // SEFF


ch10.3 assertions


- commands called on e-s cause side-effects
- anyony calling C must understand these SE
- assertions make SE explicit and easier to deal with

- to wazne dla commands ktore wywoluje inne commands etc... te juz trudno zrozumiec

problem: 
- SE of C are implicitly visible in impl.
- nie widzimy SE patrzac na interfejs obiektu

- there must be means to see SE w/o analysing opetaion logic
- wprowadzamy elementy tzw. design by contract
- na koncu metody robiacej SE - sprawdzamy POST-CONDITIONS [chociaz nie tyle "sprawdzamy" co explicit pokazujemy zmiane]
- w post-conditions sprawdzamy invariany/stan [metody, klasy, agregatu] po C
- wiec nie jest to explicit wskazanie zmiany po C
- na koniec C trzeba sprawdzic ALL modified states - to give this tech sense

- assertions w post-conditions sa "identyczne" z assert'ami w unit-test
- np: 
  - mieszasz paint1 z paint2 
  - to na koniec sprawdzash assert(paint1.size + paint2.size = paint3.size)

- vi: assercje mozesz pokazac w UT'ach - a nie w main code

- assertions desc state [not procedure] - so they are easy to analyse

// g: te assercje troche smierdza - duzo zalezy od jakosci ich impl., moga wrecz wprowadzac w blad


ch10.4 conceptual contours


nt: 7.14 16.10.50


ch10.5 standalone classes


ch10.6 closure of operations


ch10.7 declarative design


ch10.7.1 domain specific languages


ch10.8 declarative style of design


ch10.8.1 extending spec in a declarative style


ch10.9 angles of attach


ch10.9.1 carve off subdomains


ch10.9.2 draw on estabilished formalizms, when you can

