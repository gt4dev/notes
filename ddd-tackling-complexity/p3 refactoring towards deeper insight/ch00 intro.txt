- model musi byc wypracowany iteracyjnie [nie waterfall]
- miedzy domain experts i devs
- eg flow: modelowanie, kodowanie, refactor


1. levels of refactoring

- r = redesign sw w sposob ktory nie zmienia jego funkcjonalnosci
- zeby robic r - musisz miec unit tests - zeby wiedziec czy feat nadal dziala
// g: zeby robic r na poziomie modulow - musisz miec testy na poziomie modulow [integracyjne] 
// g: ut'ami testujesz tylko units - i tylko units mozesz testowac = r-owac

- r-s ktore maja biggest impact = r-s motywowane przez nowe spojrzenie na domene lub czyszczace model

type r-s
- micro r-s - tech r-s, opisane np. przez fowler'a [refactoring 99]
  - fix'uja code smells - ktore trzeba naprawic
- r-s to deeper model


2. deep models


classic approach to modeling
- find verbs/nouns in specification
- build from them objects and methods

- ee uwaza ze w/w = oversimplification
- useful only when learning OO ;]
// g: "wszyscy" tego uzywaja

// g: acz w/w to dobry start modelu v0

// g: wraz z nauka domeny - opracowujesz DEEP model

'deep model' 
- model ktory wydestylowal bardzo pierwotne 'primary concerns' z domeny
- odcina sie od powierzchownych aspektow domeny/use-cases


3. deep model supple design


- w warunkach ciaglej zmiany [modelu] - design musi wspierac te zmiany
- opisuje taki design ch10 (supple design)

- ciezki w zmianie kod - moze totalnie zatrzymuje mozliwosc zmiany modelu