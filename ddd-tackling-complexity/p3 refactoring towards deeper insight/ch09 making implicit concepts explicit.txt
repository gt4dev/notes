ch09 making implicit concepts explicit


wiele b. dobrych refactors modelu jest po
- znalezieniu implcit some elements [object, relations]
- making them explicit

// g: na modelu - rob all explicit
// g:           - zadnej implicit wiedzy


ch09.1 digging out concepts


- in short: sluchaj bardzo uwaznie domain experts
- jakich terms uzywaja, jak reaguja na twoje termy

- to b. podejrzane jesli expert/dev uzywaja slow ktore nie sa w UL

// g: all terms from spec/uc-s/talks musza byc w UL i modelu!!!

- czasem bardzo trudno znalezc 'implicit objects' ktore chcemy zrobic 'explicite'
- widac ze modelowi cos brakuje - ale trudno stwiedzic gdzie jest "brak"

contradictions
- rozni experci domenowi - roznie widza biznes [zaleznie od dowsiadczen ..]
- more: 1 osoba moze dawac infa ktore sa niespojne [jesli sie temu przyjrzymy]

- w/w niekonsystencje sa dobrym miejsce na poglebianie modelu, destylowanie wiedzy

- it's NOT practical to reconsile all contradictions
- nawet tego nie chcemy
- niektore contrad. swiadomie zostawiamy w modelu


c sample
- w przykladach w tym ch
- mamy "encje" z modelem [dane + metody]
- wsrod niech FeeCalculator, InteresCalculator
- normalnie takie calculatory - lubisz umieszczac w ds
- tu maja one ctx obiektu

c: ee zaleca book Analyse Patterns by Fowler 97

- dopracowanie dobrego modelu - wymaga wiele, wielu rozmow z expertami doemnowymi


ch09.2 how to model less obvious kinds of concepts


- wg ee next 3 constrs were not obvious when started oo modeling ;]

ch09.2.1 explicit constraints


- constrains to wazny element modelu
- expressing constraints explicit can greatly improve design

sample
- Bucket object must guarantee the invariant: contents <= capacity
- simple constraint/invariant - thus 
  - can be enforced by "IF like code"
  - add check to each method changing content/capacity
class Bucket {
  float capacity;
  float contents;
  
  // bad: constraint wmieszany w logike metody
  public void pourIn(float addedValue){
    if(content + addedValue > capacity)
      contents = capacity;
    else
      contents = contents + addedValue;
  }

  // good: constraint explicit named and separated from 'code'
  public void pourIn(float addedValue){
    var newCont = content + addedValue;
    contents = constrainedToCapacity(newCont) <<< explicit constraint
  }
  
  float constrainedToCapacity(input){ .. }
}
good version
- wydzielenie c zwieksza czytelnosc 'host code' i samego c
- named/explicit 'thing' is easier to discuss
- easier to later modify constrint and host code

sygnaly ostrzegawcze c is distoring design of host
- c reqs data not available on host object
- c appear in multiple diff objects

w w/w cases - mozliwe ze c nalezy
- przesunac do innego obiektyu
- dodac do modelu jako nowe obiekty/relacje [see next sample]


example: overbooking policy
- w shipping business - book'ujesz 10% wiecej niz transport moze pomiescic [zwykle i tak sa 'last minute' cancellations]

| voyage |-----------*--| cargo |
                ^   
                | {sum(cargo.size) < voyage.capacity * 1.1}
                |
              ---------------------
              | overbooking policy |     <<< expl. constraint
              
int makeBooking(Cargo cargo, Voyage voyage) {
  if(!overbookingPolicy.isAllowed(cargo,voyage)
    return -1;
  // make booking
}

bool isAllowed(Cargo cargo, Voyage voyage) {
  "return cargo.size < voyage.capacity * 1.1"
}


ch09.2.2 processes as domain objects


- w domain czasem sa procedury

- procedury 'wyrazamy' explicit uzywajac services

- ale moze byc opcja wykonania procedury/procesu na kilka sposobow
- then: do this procedure [or key fragment] object
- then the choice between process ver is explicit visible as choice of object - each of which represent STRATEGY


ch09.2.3 specification

- s wymyslil ee z fwoler w '97
- s pridives concise way of expressing certain kings of rules, extracting them from conditional logic
- and making them explicit in model

- ee rozkminia - ze stosowanie own patterns - czesto jest bez sensu, nawet szkodliwe ;]
- wiele projects experimented diff approaches
- use this exper, szkoda czasu/energii na own tries
- inni 'latami' szukali rozw. jak prawidolowo  budowac dany pattern

// g: w ch10 tez jest o s?

- nie all rules sa proste jak w/w

sample: invoice.IsDeliquent():bool
- moze byc mega skomplikowana
  - ma proste testy: is invoice overdue
  - i complex
    - lepsi customers moga przekraczac limit o x days
    - trzeba sprawdzic historie zamowien customer'a
- w/w r-s nie maja wiele wspolnego z Invoice
- ale te r-s powinny byc w domain layer
- s zawiera business r-s!!!

solutions
- create spec. object that evaluate to boolean
- place there logic [r-s] of tests
- s to vs'y  // g: oblukaj smaple Cargo model - there is Spec [as vo]

- s wyraza constraints ktore sa narzucone na inny obiekt, czy spelnia on okreslone kryteria
- s sprawdza konkretne warunki, r-y

- many s-s are simple special purpose tests [as w/w isDeliquent example]

- factory can create s - by using data from mixes srcs [database, entities ..]

sample
- s = DeliquentInvoiceSpecification
- s sprawdza Invoice'y
- client call
  deliquentInvoSpec.IsDeliquent(invoice123) // pass tested object to spec
- DIS ma pola biznesowe np 'standard grace period = 20d'
- pola sa inited pod konkretna grupe Invoices - do testowania
- DIS zwraca true - tz. invoice jest 'deliquent'

- dostosuj pattern do 'own needs' - nie trzymaj sie tego sztywn - now
 point


ch09.2.4 applying and implementing specification


// gt: co o spec mowi vv, check iddd index

wg ee spec pozwala zunifikowac czesc funkcjonalnosci of app
ktore sa zwykle dosc mocno rozstrzelone w app
a dzieki spec - sa one w 1 miejscu
unifikacja roznych feats w 1 concept
- walidacja - validate an object to see if it fulfills some need
- selekcja - select an object[s] from collection 
- building to order - spec is specing the creation of new object fitting spec // gt: skad taka nazwa?
all of them are 'the same' on concept level

// gt
n: all specs maja meth isSatisfiedBy(..):bool

VALIDATION


- simplest spec usage

sample
- b.need: app wyswietla red flag - if saler opens customer info with delinquent bill [zalegÅ‚y rachunek]
- podczas budowania ekranu - musimy wywolac metode 
    public boolean accountIdDelinquent(Customer customer) {
      var invoice = customer.pobierzJakisTamInvoice()
      Specification spec = new DelinquentInvoiceSpecification(today);
      return spec.isSatisfiedBy(invoice); // true - spec fulfilled - account is delinquent
    }
- model

  <abstract, general spec>
  | InvoiceSpecification [IS]   |                 |         |
  |-----------------------------| - - - - - - - > | Invoice |
  | isSatisfiedBy(invoice):bool |                 |         |
  
  <real specs, with real validations>  n: spec moze walidowac 'cokolwiek'
  DelinquentIS : IS {...}   // czy zalegla faktura
  BigIS        : IS {...}   // czy kwota faktury jest 'big'
  
- real spec
  class DeliquentIS : IS {
  
    constr(Date currentDate){ set this.currentDate from param }
  
    // n: spec dostaje walidowany obiekt jako param
    public bool isSatifiedBy(Invoice inv){
      var someData1, someData2 = inv.get some data to do invoice validation;
      return compareDateWithConstrDate(someData1, someData2, this.currentDate);
    }
  }
  
  
SELECTION [QUERYING]


- cel: zbudowac spec ktora ustaw kryteria selecta

- wg ee obie spec [validation i selection] to ten sam concept - roznia sie jedynie impl.

sample: demo ze val/sel - to te same koncepcje
- wez 'zywcem' spec z prev. sample
- w InvoiceRepository add method selectSatisfying(InvoiceSpec is)
- z: all repo data is in mem in List<Invoice> // w realu sa w db ale tu pokazujemy koncept
- teraz w selectSatisfying przeiteruj przez liste i sprawdz ktore Is spelniaja spec i zwroc te Is

sample: sql spec
- u: jest wiele diff impls of spec & repo - dostosuj to do own needs
- sql is very natural way of writing spec!

class DelinquentInvoiceSpecification {
  public Set satisfyingElementtsFrom(InvoiceRepository ir) { // n0: repo jako param - to troche zgrzyt, ale concept is ok
    return is.getAllInvoicesOlderThan(this.currentDate.minus(20dni)); // n1: get data from repo which satisfy spec
  }
  // - sama spec nic nie wie o sql - i to wazne
  // - spec jest czystsza i explicit wyraza intencje biznesowe
}

- client call

  var spec = new "sql based spec for getting delinquent invoices"();
  invoiceRepo.selectSatisfying(spec) // troche 'double dispatch'/overkill ale concept ok


BUILDING TO ORDER [GENERATING]


sample: building from spec
- jak wojsko zamawia jet to mowi: ma miec 2 machy, zasieg 2k km, cena 50M USD
- wojsko nie mowi jak to zaprojektowac - mowi jaka spec maszyna ma spelniac

- wg ee: "mimo ze nie wyglada to spec building to ten sam koncept co przy walidacji/selekcji" 

// gt: dziwny pomysl - zapamieta tylko ze ze spec mozna tworzyc obiekty