# REPOSITORIES


zeby miec obiekt
- albo go wyszukujesz [repo], tworzysz [factory]
- albo robisz travers po asocjacji [z innego obj]

// g
- niezaleznie gdzie [db, vm0 ..] i w jakiej postaci masz e [KlazzA, db-row ..]
  to koncepcynie all these e - stanowia 1 e [w moze roznym stanie]
- jako single point of truth - use db (z sync crud'owania by tx'y)

klient nie moze miec 
- zbyt duzej mozliwosci traversowania po assocjacjach -> it muddles the model
- direct db access [bo nie bedzie uzywal aggs to "crud" data]
  
- agg internals [e/vo] can be accessed only by travers [from the root]

- main repos resp = remove from model techs regarding reading/saving data

- w modelu mamy tylko interface
- klient szuka wg params [obiekty modelu]
- result jest obiektem modelu

repo moze zwrocic
- particular object[s]
- summary information [eg. recap data from few objects]
- calculations on objects
- ...

factory vs repo
- f tworzy obiekty - ktore sa w mem [nie sa z automatu stored]
- r zapisuje obiekty z pamieci do store'a lub czyta ze store do pamieci [reconstitute]

- provide repos to access only agg roots [which can't be accessed by traversal]

- btw: repos ulatwiaja testowanie kodu [bo latwo w miejsce heavy infra wstawic mock]


## 1 QUERYING A REPO


metoda searching by 
- id - zwroci 1 obj
- attr - moze zwrocic many objs
  
- if repo returns calculations - then usually these are calcs done by underlying db

repos can search by
- simple attrs
- specifacation [EE patt] based queries 
  eg. TradeOrderRepo.matching(Criteria c)
- ...


## 2 CLIENT CODE INGORES REPO IMPL; DEVS DO NOT

// big cut
- in short: devs should understand how repos work - to use it optimally
- eg: to not fetch all objs from db by repo and iterate through


## 3 IMPL A REPO


- r impl varies deping on underlying tech [mem, db, file ..]
- thus = many possibilities of impling

recoms
- leave tx control to the client [don't commit after save to repo ...]
- client does commit
  - client can use many repos, changes
  - do 1 commit for all changes
- nie koduj tx w repo - beda prostsze
  - i repos
  - i tx'y


## 4 WORKING WITH YOUR FRAMEWORK


fwk 
- moze wspierac tworzenie repos
- moze byc totalnie przeciw repos

c: 
- entity z old ejb != e from ddd
- ejb home z old j2ee wyglada jak repo = ale to kompletnie co innego

DON'T FIGHT YOUR FRAMEWORKS!!!!!!!
- to dotyczy eg robienie immutable vo w Realm [Realm tego nie ma i nie da sie]


## 5 THE RELATIONSHIP WITH FACTORIES


- f handles beginning of objects L
- r ...     middle/end ...

- r during reconstituting creates object
- many consider r as kind of f
  - from tech PoV it's ok
  - from model PoV - reconstitution is NOT creation [conceptualy 1 is existing, 1is completely new obj]

- teoretycznie r moglo by uzywac f do reconst. obiektow - ale to rzadka praktyka

rozdzielenie r and f - separuje responsibilities
- f - tylko tworzy nowe obiekty
- r - zapisuje/czytuje store'a
  
findOrCreate
- some are mixing f and r and create method findOrCreate
- to absurd, niepotrzebne przy uzywaniu e-s/vo-s