ch07 using the language - extended example


ch07.01 introducing the cargo shiping system


- asocjacja kwalifikowana [qualified]

| Customer |----------*--[ role | Cargo |
                         ^^^^^^^^
- Cargo ma metode getCustomer(string role):Customer
- multiple customers are involved with a Cargo, each playng a diff role [shipper, payer, receiver ..]
- dana role moze grac tylko 1 customer
- dzieki w/w kwalifikacji mamy relacje m-to-1 zamiast m-to-m [bylo by Cargo.Customers:List<Customer>]
// g: acz 
  - bez kwalif. nie bylo by info o role - a to wychodzi inny model
  - w impl. Cust. nic nie wiem o Cargo wiec i mamy 1-to-1
- role moze byc
  - string [super simple case]
  - vo class
  // g: cokowliek co moze byc "key w hash-map"
- n: w samples 'prezydent usa', 'investments' tez nie ma slownika dat, a tylko fakt kwalifikacji

btw
- nie myl kwalifikacji z nazwa relacji w std asocjacji

                    cargos
| Customer |-----------*-- | Cargo |

- Customer ma attr 'List<Cargo> cargos'


- zauwaz ze w modelu v00, class diagram [rys 7.1] - reprezentuje klasy
- nie wiadomo jeszcze ktora klasa to e, vo ...
- w model v00
  - only focus on projecting classes for terms from UL, desc associations
  - totally IGNORE problem of defing stuff as e, vo ...

c: nice pattern: sledzenie historii zmian w app
- EE w modelu zapisuje historie w DeliveryHistory
- explicit define history/cargo events
- don't need Envers or other implicit history tracking events


ch07.02 isolating the domain: introducing the applications


EE wyroznil 3 'serwisy aplikacyjne' (nazywa je "application functions")
AS'y:
- tracking query [sledzenie cargo]
- booking app [przygotowuje cargo]
- incident logging app ["niewazne" ;]

VVVVVI
these classes are coordinators
AS can't work out the answers 
AS searches answers in domain layer


ch07.03 distinguishing entities and value objects


class Customer
- Customer ma identity wazne dla usera
- zatem to e
- ustalenie czym jest ID wymaga talk z expertami domenowymi
- jako ID uzyjemy ID customers z 2nd systemu - do "zglaszania zapotrzebowania" by users
- w v0 - id mozna przepisywac recznie miedzy systemami
- this settles 'continuity of identity' between those systems
- mamy 'rozszerzenie encji'
// g: acz czy to rozsadne id? bo to najtrudniejsza forma id

class Cargo
- dwie identyczne crates [skrzynie] musza byc rozroznialne 
- dlatego Cargo = entities
- id generujemy automatycznie

class HandlingEvent
- HEs to obiekty ktore nie sa interchangable
- thus HE = entity
- podczas dyskusji z 'domain expert' okazuje sie ze HE sa identyfikowane przez: cargoId, completionTime, type
// g: acz czy to rozsadne? takie skomplikowane id?

class Location
- dwa miejsca z ta sama nazwa - nie sa ta sama lokacja
- thus it's entity
- id = auto-generated

class DeliveryHistory
- mega ciekawe
- DHs nie sa interchangable = thus sa e-s
- ale DH ma relacja 1-1 z Cargo
- DH ma ID 'pozyczone' z Cargo

class DeliverySpecification
- kilka Cargos moze miec to samo DS, nie potrzebujemy rozroznienia obiektow
- thus DS is VOs


ch07.03.1 role and other attrs


// role - jako kawalifikator przy Cargo
- role has no history or continuity
- jest to vo - moze byc dzielony miedzy wiele Cargo-Customer associations


ch07.04 designing associations in the shipping domain


- dodajemy traversal directions do diagramu
- w modelu v0 - all jest bidirectional
- vin: bidirectional are problematic in design/code

- traversal direction better express insight of the domain, deeps the model
 
asso Customer-Cargo
- Customer nie jest specyf. dla Cargo
- w diff systemach Customer moze miec wiele rol w interkacji z wieloma obiektami
- thus keep Customer free from any additional responsibilities
- n: jak potrzebujesz wyszukac Cargo by Customer i odwrotnie 
  - no problem: add methods to Cargo repo
  - nadal nie potrzeba by Customer mial ref do Cargo

asso Cargo-DeliveryHistory
- b. ciekawe
- asso zostaje bidirectional bo
  - sledzenie historii jest kluczowe dla Cargo
  - historia musi refowac do jej subject
  
Cargo-DeliverySpecification
- b. ciekawe
- DS jest vo-sem
- vo zwykle nie ma ref'a do owner'a - stad relacja jest directed

circular reference
Cargo --- DeliveryHistory ---> HandlingEvents ---> Cargo [again]
- circular references logically exists often in business
- nie da sie ich 'wyeliminowac' z modelu - musza byc uwzglednione
- da sie to zakodowac acz bywa tricky [g: bo cos trzeba 'lazy-loadowac'?]

inny ciekawy case
HandlingEvent --*-------0..1--> CarierMovement
- kierunkowosc powoduje ze CM nic nie wie o HE
- w modelu widac ze CM moze 'miec' many HE [vide '*'] ale NIE bedzie to zakodowane 


ch07.05 aggregate boundaries


- Customer, Location, CarriesMovement musza byc root aggregates
- bo sa wspoldzielone przez many Cargos
- klasy te tworza 'globalne dane/dane dostepne niezaleznie od innych' stad sa dostepne jako roots

- Cargo tez jest rootem

granica agg Cargo
- DeliveryHistory - wciagamy do agg Cargo - bo NIKT nie bedzie czytal DH bez C
- DeliverySpecifaction - vo bezposrednio refowany przez C thus jest czescia agg Cargo


// g: pytanie do ddd-krk - to blad? raczej
mega-mega-turbo-uwaga
- model
vo wewn. cargo agg           osobny agg
DeliverySpecification ------ Location

DS ma ref do Location [czyli vo ref'uje agg/e - to juz dziwne]
ale asso jest bidir!!! - Location refuje vo's
q: to mozliwe??? to zaprzeczenie ze refujemy tylko root'y agg - nic wewnatrz!!!
n: to blad, bez sensu zeby L mial ref do DS


- wg VV - granice aggs wysznaczamy przez "granice tx'ow" 
- EE w ogole o tym nie mowi, ma inne kryteria graniczenia aggs [raczej skupia sie czy cos jest global czy nie]
// g: pewnie to sie zdezaktualizowalo
// g: sprawdz agg desc in earlier chapter


ch07.06 selecting repositories


- tylko agg root moze miec repo [ale nie musi]
- to jakie repo potrzeba - wynika z potrzeb UC'ow
- np: potrzebujesz w UC wyciagnac Customers ktorzy spelniaja kryteria y - budujesz repo z metoda


ch07.07 walking through scenarios


- co jakis czas testuj koncepcyjnie model - wykonuj scenariusze/UC-e i sprawdzaj czy model dziala

c: impl. roles w Cargo
- uzywamy simple Map customerRoles = new HashMap();
- same klucze/role - pewnie sa zdefinowane w innym miejscu


ch07.08 object creation


od constr wymagamy zeby stworzyl obiekt ktory
- spelnia invariants
- [dla e-s] ma identity
// wpp attrs - set in factory

c: bidirect 1-1 asso Cargo-DeliveryHistory
- means: zadna ze stron nie jest komplenta bez counterparta
- oba obietky musza byc stworzone razem i powiazane - zeby zachowac relacje

constr Cargo(string id) { // n2
  id = id
  deliveryHistory = new DeliverHistory(this); // n1
  // init other attrs
}

n1: robienie bidirec asso
- Cargo jest rootem i zawiera DH
- dlatego C moze wywolac constr. of DH
// q: co z ustawieniem ID na DH

n2: w constr. przekaz all needed attrs tworzace id

- EE recoms ustawianie 'non-identity' attrs poza constr, w factory method
static HandlingEvent HandlingEvent:newLoading(Cargo c, CarrierMovement cm, Date time) { // n1
  var result = new HandlingEvent(c, LOADING_EVENT, time) // n2
  result.setCM(cm); // n3
  return result
}

n1: nazwa factory - oddaje term z UL - "tworzymy loading event"
n2: 
  - constr. pobiera tylko "attrs for id", chociaz to rzeznia - bo bierze caly Cargo
  - HandlingEntity ma id = {cargoId, timestam, type}
n3: non-ident. attr of HE jest ustawiany poza constr

c: 
- EE refuje miedzy agg roots by ref a nie id [vide w/w Cargo, CarrierMovement]
- to sie chyba zmienilo od czasow VV

c: cycle references
- n: jak tworzysz 'cycle of objects' to wszystkie obiekty tworzace cycle musza byc polaczone PRZED commit
- "zadna filozofia" ;]


ch07.09 pause for refactoring: alter design


- czasem trzeba refactor'owac model zeby dalej go rozwijac

performance problem of curr. model
- dodajac HandlingEvent - trzeba tez w 1 tx zmodyfikowac DeliveryHistory
- beda tx fails/locks - jak wielu users bedzie dodawac HE-s
- fix [chyba]: w attr DeliveryHistory.events
  - replace real collection of objects [HE]
  - with query to db ["lazy loading" on access to this attr]
- it allows calling many tx-es without conflicting each other

- w/w budowanie kolekcji DeliveryHistory.events [chyba] rob w HE Repo

// g: w/w to [chyba] std podejscie - gdy agg 1 ma asso do agg 2 i 1 ma wczytac dane 2

- c: w/w trick z DH - rozw. tez problem z circle reference - wg EE it's no more problem


ch07.10 modules in shipping model


c: efekt pakietowania wg infra
- jesli pakietujesz klasy wg infra [np. vo-sy do pakietu z vo, service'y do service'ow ...]
- to finalnie masz
  - w pakietach klasy ktore maja malo ze soba wiele wspolnego [low cohesion]
  - miedzy pakietami: duzo zaleznosci miedzy [high coupling]
- to dokladnie odwrotnosc 'oczekiwan' [high coh in modules, low coupling between m-s]

- podzial na moduly wynika z UL

// g: [pp?] na diagramie sa moduly  = BC-e, bo kazdy adresuje inny typ aplikacji/user'a


ch07.11 intro a new feature: allocation checking


connecting the two systems
- z: booking app korzysta jednoczesnie z local system/UL [cargo repo] i remote system/UL [sales management system]
- prob: booking app korzysta z 2 diff ULs
- fix: translate remote UL to local UL - zeby miec 1 UL i moc dalej robic MDD
- translator class - anty-corruption layer [more ch14]
  - pobiera z remote tylko feats req by local reqs/model
  - re-abstract remote terms to local
  
- create interface representing remote system [sales management system]
- zakoduj interface jako service [domain service]
- nadaj DS'owi nazwe z UL np. AllocationChecker
- n: w nazwie nie ma zadnego suffix Service - pure UL

prob: type of cargo z SLS musimy reprezentowac w local UL
- w remote app [SMS] kategorie sa zbiorem strings z nazwami
- use pattern 'enterprise segment' z analyse patterns fowler'a
  - create w local UL vo EnterpriseSegment - reprezentujacym kategorie Cargo
  - AllocationChecker translates miedzy EnterpriseSegment i SMS's category string
  - n: naturalnie stub of SMS uzywa category as string [native param from SMS, niewidoczne w out domain]

// g: oblukaj ten pattern [dzielisz enterpr. na segmenty wg dimensions: categories, times ..]


ch07.11.3 performance tuning


- tune'ujemy performance AllocationChecker'a
- niektore zapytania do remote system - mozna cache'owac [query o categories]
- niektore musza byc real calls [robienie alokacji transportu]

