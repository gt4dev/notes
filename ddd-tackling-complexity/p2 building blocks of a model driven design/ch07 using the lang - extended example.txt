ch07 using the language - extended example


ch07.01 introducing the cargo shiping system


- asocjacja kwalifikowana [qualified]

| Customer |----------*--[ role | Cargo |
                         ^^^^^^^^
// g: Cargo ma metode getCustomer(string role):Customer
- multiple customers are involved with a Cargo, each plaing a diff role [shipper, payer, receiver ..]
- dana role moze grac tylko 1 customer
- dzieki kwalifikacji role mamy relacje m-to-1 zamiast m-to-m
// g: acz bez kwalif. nie bylo by role, tylko "List customers" - to troche bida
- role moze byc
  - string [super simple case]
  - vo class [
- kwalifikacje (role) rysujemy w malym kwadraciku przyleglym do duzego kwadracika Cargo
- n: w samples 'prezydent usa', 'investments' tez nie ma slownika dat, a tylko fakt kwalifikacji

btw
- nie myl kwalifikacji z nazwa relacji w std asocjacji
- przyklad
                      role
| Customer |-----------*-- | Cargo |

- Customer ma attr 'List<Cargo> role' - bez sensu
- to kompletnie inna asocjacja


- zauwac ze 1st szkic modelu, class diagram [rys 7.1] - reprezentuje klasy
- nie wiadomo jeszcze ktora klasa jest encja, vo ...
- w 1st ver of model 
  - only focus on projecting classes for terms from UL, desc associations
  - totally IGNORE problem of disting. what is e what vo ...


c: sledzenie historii zmian w app
- EE w modelu zapisuje historie w DeliveryHistory
- it's a nice tip/pattern
- explicityly define history/events
- don't need envers or other implicit history tracking events


remember: model constantly changes in 'interative way'
- odkrywamy nowe fakty, poprawiamy model
- kodujemy
- ...


ch07.02 isolating the domain: introducing the applications


w Cargo sample EE wyroznil 3 'serwisy aplikacyjne'
EE nazywa je application functions
AS'y:
- tracking query [obsluga samego cargo
- booking app [przygotowuje Cargo]
- incident logging app [NIEWAZNE co ta AF robi]

VVVVVI
these classes are coordinators
they should not work out the answers - AS szukaja answers w domain layer


ch07.03 distinguishing entities and value objects


class Customer
- Customer ma identity wazne dla usera
- zatem C = e
- ustalenie czyma ma byc ID wymaga ustalen z expertami domenowymi
- jako ID uzyjemy ID customers z 2nd systemu - do zglaszania zapotrzebowania by users
- w v0 - id mozna przepisywac recznie z 2nd to 1st system
- this settles 'continuity of identity' between those systems
- mamy 'rozszerzenie encji'
// g: acz czy to rozsadne, to najtrudniejsze id

class Cargo
- dwie identyczne crates [skrzynie] musza byc rozroznialne 
- dlatego Cargo = entities
- id generujemy automatycznie

class HandlingEvent
- HEs to obiekty ktore nie sa interchanalbe
- thus HE = entity
- podczas dyskusji z 'domain expert' okazuje sie ze HE moze byc identyfikowane przez
  - cargoId, completionTime, type
// g: acz czy to rozsadne?

class Location
- dwa miejsca z ta sama nazwa - nie sa ta sama lokacja
- thus: L = entity
- id = auto-generated

class DeliveryHistory
- mega ciekawe
- DHs nie sa interchangable = thus sa e-s
- ale DH ma relacja 1-1 z Cargo!!!
- DH ma ID 'pozyczone' z Cargo

class DeliverySpecification
- kilka Cargos moze miec to samo DS, nie potrzebujemy rozroznienia obiektow
- thus DS to VOs!!!


ch07.03.1 role and other attrs


// role - jako kawalifikator przy Cargo
- role says sth about the association it qualifies
- but it has no history or continuity

- jest to vo - moze byc dzielony miedzy wiele Cargo-Customer associations


ch07.04 designing assocaitions in the shipping domain


- dodajemy traversal directions do diagramu
- w modelu v0 - all jest bidirectional
- in: bidirectional are problematic in design/code

- traversal direction better express insight of the domain, deeping the model
 
association Customer-Cargo
- Customer nie jest specyf. dla Cargo
- w diff systemach Customer moze miec wiele rol w interkacji z wieloma obiektami
- thus keep Customer free from any additional repsonsibilities
- n: jak potrzebujesz wyszukac Cargo by Customer - no problem, do it on repository level

asso Cargo-DeliveryHistory
- b. ciekawe
- asso zostaje bidirectional bo
  - sledzenie historii Cargo jest kluczowe dla Cargo
  - historia musi refowac do jej cubject
  
Cargo-DeliverySpecification
- b. ciekawe
- DS jest vo-sem
- vo zwykle nie ma ref'a do owner'a - stad relacja jest directed

circular reference
Cargo --- DeliveryHistory ---> HandlingEvents ---> Cargo [again]
- circular references logically exists often in business
- nie da sie ich 'wyeliminowac' z modelu - musza byc uwzglednione
- da sie to zakodowac acz bywa tricky [g: bo cos trzeba 'lazy-loadowac']

ciekawy case
HandlingEvent -*--------0..1-> CarierMovement
- kierunkowosc powoduje ze CM nic nie wie o HE i * w modelu 'nie ma sensu'
- w modelu widac ze CM moze 'miec' many HE ale nie bedzie to zakodowane 


ch07.05 aggregate boundaries


- Customer, Location, CarriesMovement musza byc root aggregates bo
- sa wspoldzielone przez many Cargos
- class'y te tworza 'globalne dane/dane dostepne niezaleznie od innych' - stad beda dostepne jako roots

- Cargo tez jest rootem

granica agg Cargo
- DeliveryHistory - wciagamy do ag Cargo - bo NIKT nie bedzie czytal DH bez C
- DeliverySpeciifaction - vo bezposrednio refowany przez C thus jest czescia agg Cargo


mega-mega-turbo-uwaga
- model
vo wewn. cargo agg           osobny agg
DeliverySpecification ------ Location

DS ma ref do Location [czyli vo ref'uje agg/e - to juz dziwne]
ale asso jest bidir!!! - Location refuje vo's
q: to mozliwe??? to zaprzeczenie ze refujemy tylko root'y agg - nic wewnatrz!!!
n: to blad, bez sensu zeby L mial ref do DS


- wg VV - granice aggs wysznaczamy przez "granice tx'ow" 
- EE w ogole o tym nie mowi, ma inne kryteria graniczenia aggs [raczej skupia sie czy cos jest global czy nie]
// g: pewnie to sie zdezaktualizowalo
// g: sprawdz agg desc in earlier chapter


ch07.06 selecting repositories


- tylko agg root moze miec repo [ale wg potrzeby, moga ale nie musza]
- to jakie repos potrzeba - wynika z potrzeb UC'ow
- np: potrzebujesz w UCx wyciagnac Customers ktorzy spelniaja kryteria y - budujesz repo z metoda - proste


ch07.07 walking through scenarios


- co jakis czas testuj koncepcyjnie model - wykonuj scenariusze/UC-e i sprawdzaj czy model dziala

c: impl. roles w Cargo
- uzywamy simple Map customerRoles = new HashMap();
- klucze/role - pewnie sa zdefinowane w innym miejscu


ch07.08 object creation


od constr wymagamy zeby stworzyl obiekt ktory spelnia
- invariants
- [dla e-s] identity

c: bidirect 1-1 asso Cargo-DeliveryHistory
- means: rzadna ze stron nie jest komplenta bez counterparta
// g: acz samo bidirect - nie mowi ze obie strony sa niekompletne bez siebie
- oba obietky [c, dh] musza byc stworzone razem i powiazane - zeby zachowac relacje

constr Cargo(string id) { n2
  id = id
  deliveryHistory = new DeliverHistory(this);  n1
  // init other attrsn2
}

n1: robienie bidirec asso
- C jest rootem agg i zawiera e DH
- dlatego C moze wywolac constr. of DH
- zeby storzyc bidirect - w robimy DH(this)

n2: w constr. przekaz all needed attrs towrzoca id
- to szczegolnie wazne dla HandlingEntity ktorego id = {cargoId, timestam, type}

c: 
- EE recoms ustawianie 'non-identity' attrs poza constr, w factory method
sample
static HandlingEvent HandlingEvent:newLoading(Cargo c, CarrierMovement cm, Date time) { n1
  var result = new HandlingEvent(c,LOADING_EVENT,time) n2
  result.setCM(cm); n3
  return result
}

n2: constr. pobiera tylko attrs of id: full Cargo
n3: non-ident. attr of HE jest ustawiany poza constr
n1: nazwa factory - oddaje term z UL - "tworzymy loading event"

c: EE refuje miedzy agg root by ref a nie id!


c: cycle references
- n: jak tworzysz 'cycle of objects' to wszystkie obiekty tworzace cycle musza byc polaczone przed commit
- zadna filozofia


ch07.09 pause for refactoring: alter design


- czasem trzeba refactor'owac model zeby moc dalej go zmieniac

performance problem of curr. model
- dodajac HandlingEvent - trzeba tez w 1 tx zmodyfikowac DeliveryHistory
- beda tx fails/locks - jak wielu users bedzie dodawac HE
- fix [chyba]: w attr DeliveryHistory.events
  - replace real collection of objects [HE]
  - with query to db ["lazy loading" on access to this attr]
- it allows calling many tx-es without conflicting each other

- w/w zapytanie o HE dla danego DH - wstaw do HE Repo

- c: w/w trick z DH - rozw. tez problem z circle reference - wg EE it's no more problem


ch07.10 modules in shipping model


c: efekt pakietowania wg infra
- jesli pakietujesz klasy wg infra [np. vo-sy do pakiety vo, service'y do ...]
- to finalnie masz 
  - w pakietach klasy ktore nie maja ze soba wiele wspolnego [low cohesion]
  - a z 2nd side: masz duzo zaleznosci miedzy pakietami/modulami [high coupling 
  - dokladnie odwrotnosc 'oczekiwan' [high coh in modules, low coupling between m-s]

// g: t: mark green sticky - diagram 'ref moduling' 7.8/181

- ok podzial na moduly wynika z UL
// g: pp to sa juz moduly na poziomie BC'ow, bo kazdy address inny typ aplikacji/user'a


ch07.11 intro a new feature: allocation checking


connecting the two systems
- cel: booking app korzysta z local system/UL [cargo repo] i remote system/UL [sales management system]
- prob: booking app korzysta z 2 diff ULs
- fix: translate remote UL to local UL - zeby miec 1 UL i moc robic MDD
- translator class - anty-corruption layer [more ch14]
  - pobiera z remote tylko feats req by local reqs/model
  - reabstract remote terms to local [handy in local model]
  
- create interface representing remote system [sales management system]
- zakoduj interface jako service [domain ser]
- nadaj DS'owi nazwe z UL np. AllocationChecker [w nazwie nie ma zadnego suffix Service - pure UL]

problem: type of cargo z sales management system musimy reprezentowac w local UL
- w SMS categories to set of strings - z nazwami kategorii
- sol0: skopiowac liste categories z SMS to local UL
- sol1: reabstract the domain of other system - tworzymy wlasna reprez.
- ustal z domain expert - jak dodac nowy koncept [kategorie cargo] do UL

use pattern 'enterprise segment' z book analyse patterns '96
// g: oblukaj ten pattern [dzielisz enterpr. na segmenty wg dimensions: categories, times ..]
tnx of it - model bedzie simpler and more expressive
- create class vo EnterpriseSegment - reprezentujacym kategorie Cargo
- dodaj do local domain
- AllocationChecker translates from EnterpriseSegment to SMS's category string
- a sam stub do SMS uzywa category wg reprezentacji z SMS [acz niewidoczne to jest w domain]



ch07.11.3 performance tuning


ch07.12 final look

