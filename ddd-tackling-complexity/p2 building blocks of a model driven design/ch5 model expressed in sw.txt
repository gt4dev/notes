- aby miec dobry "model driven design"
- polaczenie modelu i impl musi byc zrobione na poziomie detail [impl]

- asocjacje latwo sie rysuje na diagramie
- ale sa potencjalnie trudne do zakodowania

c: jesne zdef. czym jest E, VO ...
- zwieksza czytelnosc modelu/kodu, ulatwia projektowanie
- mieszanie definicji - konczy sie choasem

- moduly/namespace'y - musza pochodzic z UL


# 1 ASSOCIATIONS


- przejscie z modelu do impl jest szczegolnie tricky dla asocjacji

- kazda asocjacja z modelu - w programie jest odzwieciecdona properties'ami

asocjacje moge byc oparte na diff mechs
- klasyczne refs [do pojo-s]
- zwracanie obiektu zbudowanego obiektu podczas wolania 'property-get' [look-up do db, ...]

z punktu widzenia modelu 
- widzimy tylko property
- "nie interesuje nas" skad asocjacja pobiera dane/obiekty

w real-life mamy najwiecej relacji jest typu:
- many to many
- bidirectional

- 1st sketches of doain model - tez maja duzo w/w relacji
- ale to b. czesto
  - niepotrzebnie komplikuje model
  - nic nie mowi o rzeczysistej semantyce relacji
  
metody upraszczania asocjacji
- imposing traversal direction
- dodaj kwalifikator [eliminacja multplicity/wielosci/*]
- usun nieistotne asocjacje

- upraszczanie wymaga zrozumienia domeny

- wazne: ogranicz relacje tak mocno jak to mozliwe

c: asocjacja bidirectional - oznacza ze 2 obiekty moga byc zrozumiane tylko razem

sample 
- usa mialo wielu prezydentow
- mamy relacje: 1 to many, bidirect
- ale "nikt" nie startuje od G.Washington'a i pytania "czyim prezedentem byl GW"
- stad mozemy uprosc relacje, zrobic unidirect. 
  | Country | ------[president]-*-> | Person |
- teraz klasa Person nie zalezy od idei "president", klasy Country ..
- n: zeby upraszczac musisz znac model domenowy, sposob jego uzycia

sample - kwalifikowana relacja
- jest tylko 1 prezydent w danym momencie
- uzycie kwalifikatora redukuje relacje do "1 to 1"!!!
- dodatkowo widzimy na modelu wazna regule biznesowa

  | Country |[period] --------[president]--> | Person |
             ^^^^^^^^ kwalif.
             
mega-c
- narzucajac traversal na relacje many-to-many
- robisz z niej relacje 1-to-many
- ktora jest znacznie prostsza w implementacji

- jesli relacja nie wnosi istotnej wartosi do modelu - usun ja


EXAMPLE - ASSOCIATIONS IN A BROKERAGE ACCOUNT

- model
  - brokerage account -----*--> investment
  - ................. --------- customer
- kod
  class BrokerageAccount {
    Set getInvestments() {...}
    Customer getCustomer() {...} 
  }
- c: EE uzywa getter'y, a VV odradza ;]
- w impl. POJO of BrokerageAccount
    Customer getCustomer() {return customer;} // <-- zwroc zainicjowane pole klasy
- w impl. SQL of BrokerageAccount
    Customer getCustomer() {
      zapytaj w RT baze, stworz obiekt Customer, return it // to tylko przyklad, not clean code
    }
- n: z client PoV - nie ma roznicy miedzy w/w impls [pojo, sql]

usuniecie multiplicity miedzy BroAcc - Investment
- z: z b.needs wynika ze BroAcc moze miec tylko jedna (!!!) Inv dla danego stock'a [kij z semantyka]
- nowy model
  - | brokerage account |[stock] -------> | investment |
- nowy kod
  class BorkerageAccount {
    Investment getInvestments(string stock) { // n: zwraca 1 obiekt, ograniczenie jest parametrem w metodzie!!!
      return investments.get(stock); // inv. to mapa, ale to impl. detal, w sql bedzie inaczej, niewazne ;]
    } 
    ...
  }


# 2 ENTITIES

- Es aka 'reference objects'
// q: ciekawe skad ta nazwa

many objects are defined by
- thread of continueity
- identity
a nie przez attrs

example: Person
- has identity that streches from birth to death [and beyond ;]
- zasadniczo all attrs of person mozna zmienic w ciagu zycia [i poza nim ;]
  - phisycal attrs are changing all the time [ultimatelly disappear ;]
  - nazwisko, relacje z biznesami, edukacja ...
- ale to caly czas ta sama osoba
- thus: the most most most imporatant is identity

example: customer
- w app do 
  - do sledzenia "dlugow" beda informacje rachunkach, platnosciach ...
  - sprzedazowym: osoba prowadzaca, ...
- good done identity allows to identity customer in both w/w systems

- w/w apps moga byc mega rozne [rozne langs, bazy ...]
- ale maja wspolne identity - ktore laczy customers w obu/all apps

- e to obiekt zdef. przede wszyskim przez identity
- e moga sie kompletnie-totalnie sie zmieniac w LC
- ale musze utrzymywac
  - thread of continiuty
  - "constant" identity [tz. takie po ktorym mozna obiekt "sledzic"]
  
- e = anything that has 
  - continuity through a life cycle
  - [vvvv imp] distinction independent from attrs
- zatem e rozrozniasz przez id, not attrs

example: 2 transfers on the same: account, day; and the same cash
- to sa osobne tx'y
- maja diff identity [sa e]
- wewn. e mozna re-use attrs [obiekt reprezent. day, cash ...]
  - ale attrs nie maja identity
  
vvv c
- teoret. w app mozesz miec 2 diff classes [z totalnie diff attrs]
- ale jesli beda uzywac TEGO SAMEGO identity [do identyfikacji]
- to opisuja one "ten sam obiekt" [abstract]

- samo identity [jako abstrakt/obiekt] moze miec wazne znaczenie poza app
// g: pewnie do 'rozszerzania' identyf. encji

[bolded def]
- if object is distinguished by id [not attrs]
- klase zrob prosta, focused on 'thread of continuity', identity
- dodaj mozliwosc rozroznienia each object - niezaleznie od jego formy/histori
- n: alert if matching E is done by attrs - it's very suspected


## 2.1 MODELING ENTITIES


- podczas projektowania obiektu wielu mysli sie o attrs i zachowaniach
- ale najwazniejsze w e jest ustanowienie 'continuity'
- wowczas reszta [attrs/zachowania] moga byc "czystsze"
- najlepiej jesli e ma malo attrs/zachowan
- zostaw w e "tylko" the most important attr - esp. these which
  - identify e [g: chodzi o klucz naturalny?]
  - sluza do odnajdywania/match'owanie konkretnych e
- reszte attrs/zachowan - TRY to move to associated with e-s / vo-s

- e-s also coordinate operations on objects nested/associated with these e-s

sample
- model on init
  | customer |<>--------| sales contact |
- both classes have "some attrs"
- redesign a/m attrs to follow a/m rules
- model refined
  | customer |<>--------| sales contact |
  |          |<>--------| business line |
  - do klasy customer wrzucilismy attrs ktore pozwola na wyszukania/match'owania customer - by
    - contact name
    - ...     phone
    - ...     address
    [wczesniej te attrs byly w customer & sales contact]
  - acz to mega zalezy od reqs - np. customer moze miec wiele phone numbers [owner, ksiegowosc, ..]
    - wowczas jakis phone number bedzie w klasie 'sales contact', inny w ...


## 2.2 DESIGNING THE IDENTITY OPERATIONS


- identity musi dawac mozliwosc "zident" danej e - niezaleznie od sytuacji [eg. system rozproszony, data archived ..]
- definicja identity wymaga zrozumienia domeny

- czasem set of attrs can guarantee uniqeness of e in app
- mozna ten set uzyc jako unique id

- czasem nie mamy takiego set
- wowczas dodajemy do e jakies pole z unique cyfra/string/...

// <cut/> troche inf o innych aspektach id-ow

- czasem id musi byc uspojnione miedzy wieloma systemami
- np. medical records exchanged between hospitals [with diff soft]
- w perfect case - pacjenci maja to samo ID w kazdym systemie 
- w realu kazda app ma swoje id's
- wowczas match'owanie diff IDs - mozna zrobic uzywajac 3th ID - wydanych przez nadrzedna instytucje rzadowa
- acz moga byc problems [nie wyszyscy maja common id [dzieci, rezydenci], nie wszyscy chca miec - bo privacy, ...]

// <cut/>


# 3 VALUE OBJECTS

- wiele obiektow nie posiada identity
- obiekty te opisuja rzeczy

- tracking the identity of entities is essential
- ale niepotrzebne id - make soft more complex - nie chcemy tego

- vo to NIE jest "e bez identity"
- vo to obiekty ktore opisuja rzeczy

sample
- color can be are vo
- uzycie color vo moze byc proste [it's simple object]
- but internals of vo moga byc complex [alg. mieszania kolorow]
- ale result to colors mixing = another simple vo object

- vo-s moga zawierac inne vo-s [i to sporo]
- vo-s moga ref'owac entities
- np. map service 
  - moze zwrocic vo reprezentujacy trase (Route)
  - a Route moze ref'owac e-sy reprezentujace miasta: startowe, koncowe, posrednie
  
- vo-s sa czesto przekazywane jako params w komunikatach miedzy objects
- zyja wtedy b. krotko - w czasie wolania operacji

- vo-s sa uzywane jako attrs of: e-s, innych vo-s

- when you care only about attrs of element - make it vo
- don't give it any identity
- treat vo as immutable

conceptual whole [co]
- attrs wewnatrz vo - powinny tworzyc CO [ward cunnigham pattern]
- sample: 
  - masz klase Customer z mieszanka attrs: id, name, phone, street, city ...
  - attrs: street, city ... wydzielamy do osobnej klasy Address = co
  - nowy model | Cusomter |<>------- | Address |

czy Address to VO czy E
- ZALEZY: OD SYSTEMU, "kto pyta"
- przyklady [ale duuuuzo zalezy od reqs]
- jako vo
  - adres jest 'prosta' inf o miejscu dostarczeniu paczki
  - nie ma znaczenia ze wiele diff objects ma te same attrs ...
- jako e
  - adresy tworza hierarchie, kolejne elementy hierarchi uszczegulawiaja adres
  - sledzimy zmiany adresu etc.
- czasem e plus dodatkowo e skonwertowane na vo
  - system laczy all w/w case'y


## 3.1 DESIGNING VO

- vo-s musza byc immutable
- immutability 
  - simplify much
  - perfectly fits "value idea"

- vo-s mozna uzywac jako 
  - attrs encji
  - methods
    - params 
    - rezultat
  .. wywolania metod i masz pewnosc ze nikt nic nie pozmienia
  
- istotna jest wydajnosc
- vo-s zwykle jest b. duzo
- sa immutable = moga byc dowolnie share'owane

when to allow mutablility
- reasons [mainly performance]
  - value changes frequently
  - vo creation/deletion is expensive
  - if replacement disturb clastering/other tech limits 
  - not sharing vo-s
vvvi: if vo is mutable = DON'T SHARE IT

c: DB speed up
- DB wczytuje dane w "page'ach" [czy jakos tak]
- 1 mechanical read = 1 page
- zeby przyspieszyc query - all dane powinny byc w 1 page = kolo siebie
- zrobisz to przez denormalizacje
  - e/agg refuje do lokalnych kopii vo-s [a nie e-s kept in separated tables]
  - jako ze vo sa immutable [replaced] - it's not problem!!!


## 3.2 DEIGNING ASSOCIATIONS THAT INVOLVE VOS


- fewer associations -> better

c: bidirect. associations between vo-s make no sense
- between lang objects [in model is ok]
- bad: vo0 refs vo1, vo1 refs vo0
- ok:  vo0 refs vo1, vo1 refs vo2 with identical attrs like vo0
- if anyway masz bidirect - pp 1 z vo-s jest e
- bidrect between e-s = ok, but hard to maintain


vvvv cont. here


# 4 SERVICES


- sometimes it isn't a thing
- operations don't belong to any object
- it's service

- common mistake: too fast putting operations in services
- ale bledem jest tez pchanie metod do obiektow ktore nie naleza do nich

- do service'a pasuja operacje ktore dzialaja na wielu obiektach
- typowa met. obiektu operuje tylko na nim [?]
- g: service sa bezstanowe [bo nie sa hooked do obiektu]

- service nie ma stanu
- nazwa service's to raczej activity [niz noun]
- operacje to nazwy z UL
- params and results are domain objects [tez z UL]

ch-cs of good service
- operacje sa czescia domeny [ktore nie sa czescia e lub vo]
- interface is defined with elements of domain model
- operation is stateless


### 4.1 SERVICES AND ISOLATED DOMAIN LAYOER


mamy service'y [all cooperating in app]
- domenowe
- aplikacyjne
- infrastruktury

- tech services should lack any business logic

sample: transfer pieniedzy
- transfer realizuje domain service
- bo oper. robiona jest na 2 obiektach: kontach


### 4.2 GRANULARITY


- glowne zastosowanie s = modelowanie zachowan
- dodatkowe = hiding details, decoupling clients from domain [e,vo ..]

- medium-grained service - hides complex flow behind simple method
- fine-grained access to domain - leaks knowlege to caller side


### 4.3 ACCESS TO SERVICES


- s to proste obiekty: interfaces and implementations
- nie trzeba corba, j2ee ...


# 5 MODULES [AKA PACKAGES]


- c: cognitive overload is primary reason for modularing
- it's easier to understand
  - modul details [w/o worrying ab. outer modules]
  - modules interactions [w/o worrying ab. each m details]
- there is a limit - how many things person can understand at once [hence low couping]

- keep
  - low coupling between m-s
  - high cohesion inside m
- it's important on m-s level
- on class level - it's 2nd-ary problem / but "nice to have"

- podzial na m-s wynika wprost z UL
- inside m - keep elems highly coupled together
- nazwa m wynika z UL [np 'customer']


## 5.1 AGILE MODULES


- rzadko refactoruje sie m-s = to blad
- m-s trzeba refaktorowac each time it's needed
- acz jest to troche trudniejsze niz refactor metody ...
- acz czesto podzial na moduly jest staly od poczatku projektu

- brak refactora prowadzi do
  - high coupling between m-s
  - low cohesion inside m


EXAMPLE: PACKAGE CODING CONV. IN JAVA

- EE recoms imports like
  "import some.another.pack.*"
- NOT
  "import some.specific.Klazz"
- to chyba ulatwia refactor potem


## 5.2 THE PITFALLS OF INFRASTRUCTURE DRIVEN DESIGN


trzymaj osobno each layer [layered architecture]:
- infrastructure
- user interface
- domain layer 

- g: old j2ee spec was "totally against MDA/DDD"


# 6 MODELING PARADIGMS

- obecnie dominuje OO paradigm
- niezaleznie od paradygmatu = wspolnym elementem jest UL
  - opisuje jak dziala business
  - technikalia to implementuja

vin: don't fight the impl. paradigm
- w przypadku problemow z impl. modelu w danym paradygmacie -> przemodeluj domene
- zawsze znajdzie sie inny model ktory lepiej pasuje do danego paradygmatu
- acz zmiana modelu nie zmienia UL [chyba?]

