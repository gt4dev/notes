# VALUE OBJECTS


- wiele obiektow nie posiada identity
- obiekty te opisuja rzeczy

- tracking the identity of entities is essential
- ale niepotrzebne id - make soft more complex - nie chcemy tego

- vo to NIE jest "e bez identity"
- vo to obiekty ktore opisuja rzeczy

sample
- color can be are vo
- uzycie color vo moze byc proste [it's simple object]
- but internals of vo moga byc complex [alg. mieszania kolorow]
- ale result to colors mixing = another simple vo object

- vo-s moga zawierac inne vo-s [i to sporo]
- vo-s moga ref'owac entities
- np. map service 
  - moze zwrocic vo reprezentujacy trase (Route)
  - a Route moze ref'owac e-sy reprezentujace miasta: startowe, koncowe, posrednie
  
- vo-s sa czesto przekazywane jako params w komunikatach miedzy objects
- zyja wtedy b. krotko - w czasie wolania operacji

- vo-s sa uzywane jako attrs of: e-s, innych vo-s

- when you care only about attrs of element - make it vo
- don't give it any identity
- treat vo as immutable

conceptual whole [co]
- attrs wewnatrz vo - powinny tworzyc CO [ward cunnigham pattern]
- sample: 
  - masz klase Customer z mieszanka attrs: id, name, phone, street, city ...
  - attrs: street, city ... wydzielamy do osobnej klasy Address = co
  - nowy model | Cusomter |<>------- | Address |

czy Address to VO czy E
- ZALEZY: OD SYSTEMU, "kto pyta"
- przyklady [ale duuuuzo zalezy od reqs]
- jako vo
  - adres jest 'prosta' inf o miejscu dostarczeniu paczki
  - nie ma znaczenia ze wiele diff objects ma te same attrs ...
- jako e
  - adresy tworza hierarchie, kolejne elementy hierarchi uszczegulawiaja adres
  - sledzimy zmiany adresu etc.
- czasem e plus dodatkowo e skonwertowane na vo
  - system laczy all w/w case'y


## 1 DESIGNING VO


- vo-s musza byc immutable
- immutability 
  - simplify much
  - perfectly fits "value idea"

- vo-s mozna uzywac jako 
  - attrs encji
  - methods
    - params 
    - rezultat
  .. wywolania metod i masz pewnosc ze nikt nic nie pozmienia
  
- istotna jest wydajnosc
- vo-s zwykle jest b. duzo
- sa immutable = moga byc dowolnie share'owane

when to allow mutablility
- reasons [mainly performance]
  - value changes frequently
  - vo creation/deletion is expensive
  - if replacement disturb clastering/other tech limits 
  - not sharing vo-s
vvvi: if vo is mutable = DON'T SHARE IT

c: DB speed up
- DB wczytuje dane w "page'ach" [czy jakos tak]
- 1 mechanical read = 1 page
- zeby przyspieszyc query - all dane powinny byc w 1 page = kolo siebie
- zrobisz to przez denormalizacje
  - e/agg refuje do lokalnych kopii vo-s [a nie e-s kept in separated tables]
  - jako ze vo sa immutable [replaced] - it's not problem!!!


## 2 DEIGNING ASSOCIATIONS THAT INVOLVE VOS


- fewer associations -> better

c: bidirect. associations between vo-s make no sense
- between lang objects [in model is ok]
- bad: vo0 refs vo1, vo1 refs vo0
- ok:  vo0 refs vo1, vo1 refs vo2 with identical attrs like vo0
- if anyway masz bidirect - pp 1 z vo-s jest e
- bidrect between e-s = ok, but hard to maintain
