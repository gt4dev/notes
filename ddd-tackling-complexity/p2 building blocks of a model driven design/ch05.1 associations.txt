# ASSOCIATIONS


- przejscie z modelu do impl jest szczegolnie tricky dla asocjacji

- kazda asocjacja z modelu - w programie jest odzwieciecdona properties'ami

asocjacje moge byc oparte na diff mechs
- klasyczne refs [do pojo-s]
- zwracanie obiektu zbudowanego podczas wolania 'property-get' [look-up do db, ...]

z punktu widzenia modelu
- widzimy tylko property
- "nie interesuje nas" internals asocjacji [czy ref, czy lookup ..]

w real-life najwiecej relacji jest typu:
- many to many
AND
- bidirectional

- 1st sketches of domain model - tez maja duzo w/w relacji
- ale to b. czesto
  - niepotrzebnie komplikuje model
  - nic nie mowi o rzeczywistej semantyce relacji
  
metody upraszczania asocjacji
- imposing traversal direction
- dodaj kwalifikator [eliminacja */multplicity/wielosci]
- usuniecie nieistotnych asocjacji

- upraszczanie wymaga zrozumienia domeny

- wazne: ogranicz relacje tak mocno jak to mozliwe

- asocjacja bidirectional - oznacza ze 2 obiekty moga byc zrozumiane tylko razem

sample 
- usa mialo wielu prezydentow
- mamy relacje: 1 to many, bidirect
- ale "nikt" nie startuje od G.Washington'a i pytania "czyim byl prezedentem"
- mozemy uprosc relacje - zrobic unidirect.
  | Country | ------[president]-*-> | Person |
- teraz klasa Person nie zalezy od idei "president", klasy Country ..

sample - kwalifikowana relacja
- jest tylko 1 prezydent w danym momencie
- uzycie kwalifikatora redukuje relacje do "1 to 1"!!!
- dodatkowo modelu pokazuje wazna regule biznesowa

  | Country |[period] --------[president]--> | Person |
             ^^^^^^^^ kwalif.
             
- dodajac unidirect. traversal na relacje many-to-many
- robisz relacje 1-to-many
- ktora jest znacznie prostsza w implementacji

- usun relacja ktora nie wnosi wartosci do modelu [np. nie potrzebujes danej wiedzy]


EXAMPLE - ASSOCIATIONS IN A BROKERAGE ACCOUNT

- model
  - brokerage account -------*-> investment
  - ................. ---------- customer
- kod
  class BrokerageAccount {
    Set getInvestments() {...}
    Customer getCustomer() {...} 
  }
- c: EE uzywa getter'y, a VV odradza ;]
- impl. BrokerageAccount
  - POJO
    Customer getCustomer() {return customer;} // <-- zwroc zainicjowane pole klasy
  - SQL
    Customer getCustomer() {
      zapytaj w RT baze, stworz obiekt Customer, return it // to tylko przyklad, not clean code
    }
- z client PoV - nie ma roznicy miedzy w/w impls [pojo, sql]

usuniecie multiplicity BroAcc ---*-> Inv
- z: z b.needs wynika ze BroAcc moze miec tylko jedna (!!!) Inv dla danego stock'a [kij z semantyka]
- nowy model
  - | brokerage account |[stock] -------> | investment |
- nowy kod
  class BorkerageAccount {
    Investment getInvestments(string stock) { // n: zwraca 1 obiekt, ograniczenie jest parametrem w metodzie
      return investments.get(stock); // inv. to mapa, ale to impl. detal, w sql bedzie inaczej, niewazne ;]
    } 
    ...
  }


