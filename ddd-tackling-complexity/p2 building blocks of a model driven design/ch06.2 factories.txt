# FACTORIES

- use f to create agg [or any other complex object]

analogia
- jest silnik samochodu i fabryka silnikow
- silnik siebie nie tworzy - ma inne zadanie
- identycznie w OO - sa obiekty i fabryki
- resps of
  - creating object
  - object 'logic' 
  .. are diff -> can't be mixed

- yet only call of obj constr by client
- makes client hard dependent to object
- trudno potem zmieniac object bez zmiany klienta

klient
- nie powien tworzyc obiektow
- powinien ich tylko uzywac

- creation in in domain layer
- but [usually] it's not strictly expressed in UL/domain

factory patterns
- f method
- abstract f
- builder [da sie tu rozbic budowe na etapy]
- ...

reqs for good f
- creation is atomic
- after creation
  - all invariants are satisfied
  - state is consistent
- f returns [rather] abstract type


## 1 CHOOSING FACTORIES AND THEIR SITES


- zwykle f jest przypiete do domain object
  - ma wtedy dostep do init data for new object
- [rzadziej?] f jest sandalone
  - glownie gdy tworzony jest veery complex object


wayA: place f on object which owns created object

sample
- you need to add element to existing agg
- add f method on the root
- client does't know agg internals
- agg is resp. for assuring consistency of 
  - new object
  - agg itself after adding new object

sample

<root>        <f method>                     <agg internal e>
purchaseOrder.newItem(productNumber,quantity):PurchaseItem

- sample "identical" like in chapter:aggs
  PurchaseOrder ----> LineItem -----> Product
- f na root tworzy internal e
- klient [pewnie AS] dostaje new object i (chyba) sam dodaje go do PO
  - bo f tylko tworzy new object - not adds it to root
- PI ma local id [relative to agg] thus f is part of agg


wayB: place f on object spawning new object
- "object with f" doesn't own created object
- lokalizacja pozwala to zaoszczedzic "przepychaniu danych" miedzy obiektami

sample

<root>           <f method>                 <root>
brokerageAccount.newBuy(stockSymbol,amount):TradeOrder
accNumb = a123                              brokerAccoundId = a123
customer = 'john'                           stockSymbol = sthFromParam
                                            amount = sthFromParam
- TO jest osobnym agg
- TO jest wypelniony danymi z BA - stad f najlepiej bylo otworzyc na BA


## 2 WHEN CONSTR IS ALL YOU NEED


- zwykle chcemy f-s
- ale czasem best jest direct constr call

cases
- obj nie jest czescia hierarchi, nie uzywa polimorfizow, interface'ow ...
- dla client'a wazna jest impl [gdzies w strategy patt]

- vi: avoid calling constrs inside constrs of other classes


## 3 DESIGNING THE INTERFACE


// cut


## 4 WHERE DOES INVARIANT LOGIC GO


- f jest odpowiedzalna za stworzenie obj z invariants staisfied from init


## 5 ENTITY FACTORIES VS VO FACTORIES


- vo f - od razu tworzy finalna wersje obj [bo vo jest immutable]
- vo e - raczej tworzy e w minimalnej wersji


## 6 RECONSTITUTING STORED OBJECT


- use case'y: odtworzenie obiektu wczytanego z sieci, bazy ...
// g: jaka diff z repo? chyba rzadki case?
- czasem jest case: init data sa incorrect - then
  - obj. can't be re-created
  - i moze trzeba usunac invalid init data [in db, file ..]