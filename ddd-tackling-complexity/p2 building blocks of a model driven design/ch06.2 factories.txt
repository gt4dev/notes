vvvv cont. here

# FACTORIES

- use f to create agg [or any other complex object]

analogia
- jest silnik samochodu i fabryka silnikow
- silnik siebie nie tworzy - ma kompletnie inne zadanie
- identycznie w OO - sa obiekty i fabryki

- resps of
  - creating object
  - object 'logic' 
  .. are diff -> can't be mixed

- "only" call of obj constr by client
- makes client hard dependent to object
- trudno potem zmieniac object bez zmiany klienta

klient
- nie powien tworzyc obiektow
- powinien ich tylko uzywac

- creation is done in domain layer
- but [usually] it's not strictly expressed in UL/domain

factory patterns
- f method
- abstract f
- builder
- ...

reqs for good f
- creation is atomic
- after creation
  - all invariants are satisfied
  - state is consistent
- f returns [rather] abstract type


## 1 CHOOSING FACTORIES AND THEIR SITES


- f jest zwykle metoda hooked on existing domain object
  - ma wtedy dostep do init data from 'host'
- [rzadziej?] f jest sandalone
  - glownie gdy tworzony jest veery complex object


n: way A & B - both are f hooked on existing object

way A: place f on object which owns created object

sample: you need to crete obj to add it to existing agg
- place f method on the root
- client does't know agg internals
- agg is resp. for assuring consistency of 
  - new object
  - agg itself after adding new object

sample

<root>        <f method>                     <agg internal e>
purchaseOrder.newItem(productNumber,quantity):PurchaseItem

- sample v. similar to ch:aggs
  PurchaseOrder ----> LineItem -----> Product
- f na root tworzy internal e
- klient [pewnie AS] dostaje new object i sam dodaje go do PO
- bo f tylko tworzy new object - not adds it to root
- PI ma local id [relative to agg] thus f must be part of agg


way B: place f on object spawning new object
- "object with f" doesn't own created object
- lokalizacja pozwala to zaoszczedzic "przepychania danych" miedzy obiektami

sample

<root>           <f method>                 <root>
brokerageAccount.newBuy(stockSymbol,amount):TradeOrder
accNumb = a123                              brokerAccoundId = a123
customer = 'john'                           stockSymbol = sthFromParam
                                            amount = sthFromParam
- trade order [TO] jest osobnym agg
- TO jest wypelniony danymi z BA 
- stad f najlepiej bylo dodac f na BA


## 2 WHEN CONSTR IS ALL YOU NEED


- zwykle chcemy f-s
- ale czasem best jest direct constr call

cases
- obj nie jest czescia hierarchi, nie uzywa polimorfizow, interface'ow ...
- dla client'a wazna jest impl [gdzies w strategy patt]

- vi: avoid calling constrs inside constrs of other classes


## 3 DESIGNING THE INTERFACE


// cut


## 4 WHERE DOES INVARIANT LOGIC GO


- f jest odpowiedzalna za stworzenie obj z staisfied invariants


## 5 ENTITY FACTORIES VS VO FACTORIES


- vo f - od razu tworzy finalna wersje obj [bo vo jest immutable]
- vo e - raczej tworzy e w minimalnej wersji


## 6 RECONSTITUTING STORED OBJECT


- use case'y: odtworzenie obiektu wczytanego z sieci, bazy ...
// g: jaka diff z repo? chyba rzadki case?
- czasem jest case: init data sa incorrect - then
  - obj. can't be re-created
  - moze trzeba usunac invalid init data [in db, file ..]