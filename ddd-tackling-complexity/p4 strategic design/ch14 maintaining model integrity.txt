ch14 maintaining model integrity


przyklad
- team1 [z domany: payments] - stworzyl obiekt Charge
- team2 [z doemny: invoices] - stwierdzil ze im brakuje 'pola x' w Charge i dodali to pole
- a to blad: oba zespoly powinny dogadac 
  - czy dodac to pole do Charge 
  - czy moze teams powinny miec osobne modele
- finalnie: utworzono osobne modele i 2 osobne klasy: CustomerCharge / SupplierCharge

mega fundamentalny req:
model musi byc wewn. spojny, all terms maja to samo znaczenie, nie zawiera sprzecznych rules
termy sa jednoznaczne [unambigous]

unification - stanu 'internal consistency of model'

model niespojny jest bezuzyteczny!

w big systemach - nie da sie stowrzyc one big consistent model
  tj: da sie ale to strasznie duuuuzo kosztuje time/money - i jest bez sensu
musisz miec kilka mniejszych modeli
jak masz kilka modeli to niektore moga sie rozjerzdzac [acz kluczowe elementy trzeba probowac zachowac spojne]

c: ee sam kilka razy probowal kodowac 'one big model' i dzis uwaza ze to byl blad


ch14.1 bounded context


- w big projects musimy miec many models
- inaczej kod bedzie guggy, difficult to understand
  - ciezko uzywac 1 big model

c
- czasem od razu widac ze mamy rozne modele [eg. system 1 integruje sie z systemem 2 - oba maja own models]
- czasem nie widac, jak w sample z Suppliercharger i CustomerCharger

c: czasem w 1 zespole uzywamy 2 modele np: stary i nowy model ...

- technicznie translacja danych miedzy modelami zwykle jest prosta
- wazniejsze jest uzgodnienie terms miedzy modelami etc..

- kazdy model musi miec explicitly okreslony zakres/granice jego uzywania [context]
- w ramach granic model musi byc unified [spojny]

context = granice uzywania modelu, granice moga byc 'wyznaczone' przez 
- org. zespolu
- stwierdzenie ze model uzywamy w okreslonej czesci app
- fizyczne granice w kodzie [folder, osobna schema w bazie lub wyizolowane struktury]

- w ramach granic - trzymaj model striclty consistent

- kodujac model "nie przejmu sie" co dzieje sie za modelem ;]


example: booking context
- n: kod integrujacy diff BC - nie siedzi w BC ale jest miedzy BC'ami

w example pokazujemy zla praktyke
- mamy 2 zepoly w ramach 1 project - typowy case
- kazdy zespol pracuje na own BC
- teams musza koordynowac dane, concepcje ...

jest zle bo
- zepsoly NIE widza ze pracuja na diff ctx'ach - dosc to typowy case
- teams robia integracje 'nieregularnie/ad hoc' - jak jest potrzeba

a powinny
- okreslic BCe
- zastosowac konkretna strategie integracji [ee tu propojuje shared kernel]
- 1 of 1st tasks: okreslamy relacje miedzy oboma BC'ami [booking, voyage schedule]

- n: dzielenie kodu/danych - powinno byc robione B. OSTROZNIE
// g: ale powinno, zeby nie duplikowac stanow, kodu - just do it but ostroznie


recog. splinters within BC
- jest wiele symptomow - ze w 1 bc mamy zamurowane kilka bc'ow
- top prob: interfejsy [obiektow domeny?] nie pasuja do siebie
  - latwo to wylapac w fazie continuous integration
- inny: confusions of UL

zwykle sa 2 typy problemow - zw. z laczeniem 2 BC'ow w 1 BC
- duplicated concepts
  - mamy kilka miejsc w modelu ktore wyrazaja ten sam lub podobny concept
  - jak sie zmienia 1 rzecz to aktualizujemy w kilku miejscach [!!!]
- false cognates
  - more tricky
  - ludzie okreslaja tego samego term do okreslenia diff things
  - przyklad "Charge" z ch start


ch14.2 continuous integration


- kiedy wiele osob procuje na 1 bc to model ma MOCNA tendencje do fragmentacji
- przy 3-4 osoby to powazny problem, a wiecej = wiekszy problem

- fragmentacja modelu na mniejsze - konczy na model coherency

problemy gdy devs zmieniaja istniejacy kod [objawy fragmentacji?]
- po zmianach - old obiekty/relacje nie dzialaja tak jak pierwotnie zakladano
- dev nie wie ze dany feat istnieje - i duplikuja ten feat/lub robia podobny
- dev     wie ...                   - ale i tak to duplikuje - zeby nie zepsuc istniejacych feats

ci oznacza ze wszystkie prace sa czesto/ciagle merge'owane/integrowane w finalny produkt
przez ci masz szyki feedback jesli cos nie dziala z integracja

ci [jak WSZYSTKO!!! w DDD] operuje na 2 poziomach
- model concepts
  - mc are integrated by continues communication among team members
  - by hammering out UL, ciagle ciczenia UL na roznych case'ach
  // g: concepts are integrated!!! not only code; by team talks
  - rzadko uzywana formalnie
- implementacji
  - done by contin: builds, tests
  
MUST DO
- odpalaj testy automatyczne
- bezlitosnie cwicz UL zeby zespol mial wspolny poglad na model
  // g: pp nie da sie bez talks oprawocac shared concept [jak np. offline]


ch14.3 context map


- ludzie w diff zespolach moga byc nieswiadomi granic BC'ow - moga nieswiadomie
  - tworzyc nadmiarowe interakcje
  - rozmywac granice miedzy bc'ami
  
- bc'e powinny miec interakcje - jesli ich model maja tendencje do przeciekania 1 to 2nd

- avoid re-use code between bc'e - to dosc ryzykowne [ale chyba z wyjatkiem shared kernel]
  // g: tu pewnie chodzi o kod modelu domeny, a nie infra or 'entity supertype' ...
- integracje funkcjonalnosci i danych - musza przechodzic przez translacje

- mozesz zredukowac niezrozumienie przez narycowanie context map z pokazaniem relationships miedzy bc'ami

- identify each model in project and define its bounded context
// g n: formalnie jest rozroznienie bc od modelu
- nazwij kazdy bc [wg needs z UL]
- opisz kazdy punkt interakcji miedzy bc'ami, pokaz translacje tej interakcji, pokaz any sharing [pp of model/impl]

- map already existing terrain, not planned one

mapa mozna dowolna forme
- diagram
  - tylko 'chmurki' z nazwami ctx
  - 'chmurki' z wylistowanymi konkretnymi klasami w bc ...
- opis
- zwykla dyskusja // g: dosc ulotna forma mapy

- mapa musi byc rozumiana przez wszystkich w projekcie

c: jesli znajdziesz problem przy tworzeniu mapy [np. niekonsystentny bc]
- moze oznacz taki bc na mapie, dragonem ;]
- kontynuuj rozpisywanie calej mapy bc'ow
- nie zatrzymuj sie na problemach - zaplanujesz ich fix po zrobieniu mapy


example: two contexts in shipping app
- app ma feat: podczas book'owania jest auto-gener. routing paczek
- c: RoutingService 
  - uzywa intent-revelaing i side effect free functions
  - result from RS jest okreslony przez assertion: RS zwraca Itinerary ktore spelnie 'RouteSpecification'

c: 
- EE poczatkowo chcial zakodowac internals of RS uzywajac modelu caller'a [booking] ale to bylby blad
- wyszlo - ze 
  - RS uzywa klas modelu tylko na in/out
  - internals robia bardzo 'dziwne' obliczenia - i kompletnie nie bazuje on na modelu 'caller'a'
// g: wewn. alg. jest niezalezny od zewn. caller'a - czesto tez masz ten case!

- n: niektore translacje miedzy bc'ami sa NIEMOZLIWE lub mega utrudnione [bo modele sa np. bardzo rozna i brakuje danych]

bc: booking    |                             |  bc: transport network
               |                             |
 | Routing |------> | Booking-Transport |    |
 | Service |   |    | Translator        |    |
           |   |                             |   | Transport |
           |------------------------------------>| Service   |
               |                             |

- budujemy translatory miedzy modelami [dla args and result of metods]
- tutaj: Booking-Transport Translator
- nad tym obiektem i jego test suite'm - pracuja zespoly z OBU BC'OW
- translator NIE nalezy do zadnego BC'a
- n: obiekt musi byc prosty [translator]
- translator musi byc dobrze stestowany UT'ami - zeby uniknac problemow po zmianach w 1 z BC'ow

- w example: RS jest z bc:booking i odpowiada za koordynacje dzialan miedzy BC'ami
- RS dziala mega prosto/klasycznie
  - RS wola metody TransportService z bc:transport!!! [zadnej magii, dodatkowych warstw ..]
  - wczesniej oczywiscie RS wola translator - zeby przygotowac params dla TS i potem ocnvert response
  
// g n: zauwaz ze oba zespoly dzialaja w miare niezaleznie

- c: RS latwo mega-przetestowac - bo sklada sie z SEFF

- kluczem do sukcesu integracji sa UT'y RS
- testy wolaja RS - podaja set RoutingSpecification i sprawdzaja result
- to baza do wspolpracy obu zespolow


- bez swiadomych dzialan - diff bc'e beda sie znieksztalcac, beda nachodzic na siebie
// g: trzeba to pilnowac, nie jest to 'samograj'
- sol:
  - explicitly define BCs and ContextMap
  - [g: iteratively] unify models and relations
  
// g q: jak testowac integracje
// - oba zespoly buduja test suite na translator [ktory jest dosc prymitywna klasa]
// - zespol od RoutingService - testuje ten service [ale pp w polaczeniu z mocked "2nd context service"]
// - zespol od '2nd bc' - testouje ich serwis 'normalnie' [bez przejmowania sie RS etc]

organizing and docing CMaps
- dwa istotne pts
  - nazwij BC [z UL]
  - kazdy musi wiedziec gdzie leza granice BC'a [wrzucaj bc do osobnych pakietow, ..]
- w kontrze VV - EE jednak doc'uje projekt 'nieformalnymi' diagramami etc [VV chce tylko kod]


ch14.4 relationships between BCs


cele strategii/patterns
- providing targets for succesully org-ing dev work
- giving vocabulary for desc-ing organization

- if w realu 'exiting code' moze miec inne patterny niz pokazane przez ee
- then 
  - opisz to asis now
  - z kazdym next refactorem - staraj sie zblizac do docelowego patternu [PC]
  
- patterns cover THE MOST COMMON cases [not all!]


ch14.5 shared kernel


- mamy 2x bc
- integracja feats miedzy nimi jest baaardo mala
- to overhead przez CI - moze byc zbyt wysoki
- lub jesli takiego CI nie ma [bo nie ma skill'a, etc]

- nieskordynowane zespoly pracuja na blisko dzialajacych apps // q: to mozliwe u ee?
- mimo ze apps sa spokrewnione - to co teams produkuja - nie musi pasowac do siebie
- z: mamy 2 rozlaczone bc'e
  - zespoly traca kupe czasu na translacje
  - jednoczesnie oba modele sa "slabe" bo nie uzywaja 'wspolnego [czesciowo] UL'

- wyznacz podzbior domeny - dzielone przez oba zespoly
- podzbior zawiera: kod, scheme db ...
- podzbior NIE moze byc modyfikowany bez konsultacji miedzy teams

- po zmianach SK - musza OBU zespolom przejsc testy [ktore pewnie sa obok SK]

??? o co chodzi
- wg EE SK to czesto 'core domain' or podzbior 'generic domain' [or both at once]
- acz z 2nd side - twierdzi ze SK musi byc maly - strange ...
  
- bc'e integruja sie przez shared-kernel 
- a w innych czesciach moga sie dodatkowo integrowac przez 'translacje'

// ddd-reference-2015
- SK powoduje baaardzo bliska relacje miedzy BC'ami
- SK musi byc maly


ch14.6 customer/supplier development teams


ch14.7 conformist


ch14.8 anticorruption layer


ch14.9 separate ways


ch14.10 open host service


ch14.11 published language


ch14.12 unifying elephant


ch14.13 choosing you model context strategy


ch14.14 transformations

