ch14 maintaining model integrity


przyklad
- team1 [z domany: payments] - stworzyl obiekt Charge
- team2 [z doemny: invoices] - stwierdzil ze brakuje 'pola x' w Charge i je dodali
- blad bo oba zespoly powinny dogadac
  - czy dodac nowe pole do Charge 
  - czy teams powinny miec osobne modele
- finalnie: utworzono osobne modele z klasami: CustomerCharge / SupplierCharge

mega fundamentalny req:
- model musi byc wewn. spojny
  - termy sa jednoznaczne [unambigous]
  - nie ma sprzecznych rules

- unification - stan 'internal consistency of model'

- model niespojny jest bezuzyteczny!

- w big systemach - nie da sie stworzyc "one big consistent model"
- tz. da sie ale to strasznie duuuuzo kosztuje time/money = jest bez sensu

- c: jak masz kilka modeli to niektore moga sie rozjerzdzac [acz kluczowe elementy trzeba probowac zachowac spojne]

- c: ee sam kilka razy probowal kodowac 'one big model' i dzis uwaza ze to byl blad


ch14.1 bounded context


- big project musi byc podzielony na many models
- inaczej bedzie buggy, difficult to understand

c
- czasem od razu widac ze mamy rozne modele, eg: system A integruje sie z systemem B
- czasem nie widac, eg: sample z SupplierCharger i CustomerCharger

c: czasem w 1 zespole [!!!] uzywamy 2 modele eg: stary i nowy model, etc ..

- technicznie translacja danych miedzy modelami zwykle jest prosta
- trudniejsze jest uzgodnienie terms miedzy modelami [co na co sie transformuje] etc...

- kazdy model ma explicitly okreslony zakres/granice jego uzywania [context]
- w ramach granic model jest unified [spojny]

context = granice uzywania modelu, granice moga byc 'wyznaczone' przez 
- org. zespolu
- 'powiedzenie' ze model uzywamy w danej czesci app
- fizyczne granice w kodzie [folder, osobna schema w bazie lub wyizolowane struktury]
- ...

- kodujac model "nie przejmu sie" stanem poza nim ;]


example: booking context
- kod integrujacy BC'e - 'siedzi' miedzy BC'ami, nie siedzi w BC

zla praktyke
- mamy 2 zepoly w ramach 1 project [to jest typowy i ok]
- kazdy zespol pracuje nad own BC - ale o tym nie wiedza [dosc typowy case]
- teams musza koordynowac dane, koncepcje ...
- ale integracje robia 'nieregularnie/ad hoc'

good praktyka - zespoly powinny
- okreslic BCe [graice]
- zastosowac konkretna strategie integracji BC'ow, np. shared kernel
  - okreslamy relacje miedzy oboma BC'ami to 1 of 1st tasks

- dzielenie kodu/danych - powinno byc robione BARDZO OSTROZNIE
// g: ale powinno, zeby nie duplikowac stanow, kodu - do it but ostroznie


2 typowe problemy - zw. ze zlaczeniem 2 BC'ow w 1 BC
- duplicated concepts
  - mamy kilka miejsc w modelu ktore wyrazaja ten sam lub podobny concept
  - jak sie zmienia 1 rzecz to aktualizujemy w kilku miejscach [!!!]
- false cognates
  - more tricky
  - ludzie okreslaja tego samego term do okreslenia diff things
  - przyklad "Charge" z poczatku ch 


ch14.2 continuous integration


- kiedy wiele osob pracuje na 1 bc to model ma MOCNA tendencje do fragmentacji
- juz przy 3-4 osoby to powazny problem!

- fragmentacja modelu niszczy model coherency

problemy devs przy zmienie istniejacego kodu
- po zmianach - old obiekty/relacje nie dzialaja tak jak pierwotnie zakladano
- dev nie wie ze dany feat istnieje - i duplikuje go lub robi podobny
- dev wie o feat ale i tak go duplikuje - zeby nie zepsuc istniejacego kodu

CI oznacza ze wszystkie prace [modele?] sa ciagle integrowane (czesto merge'owane) w finalny produkt
CI daje szyki feedback jak integracja nie dziala

CI [jak WSZYSTKO!!! w DDD] operuje na 2 poziomach
- model concepts - integration is done by
  - continues talks among team members
  - ciagle ciczenie/testowanie UL na roznych case'ach
  // g: concepts are also integrated!!!
  - c: tech. rzadko zformalizowana
- implementtion - integr. is done by conti. builds, tests
  
MUST DO
- odpalaj testy automatyczne
- "bezlitosnie" cwicz UL zeby zespol mial wspolny poglad na model
// g: pp nie da sie bez talks oprawocac big, "cross team" concept [jak np. offline w mobi]


ch14.3 context map


ludzie w diff zespolach moga byc nieswiadomi granic BC'ow, moga
- tworzyc niezaplanowane interakcje
- rozmywac granice miedzy bc'ami
  
- bc'e maja tendencje do "przeciekania" miedzy soba 

- avoid re-use code between bc'e - to dosc ryzykowne [pp z wyjatkiem shared kernel]
// g: pp chodzi o kod modelu domeny, a nie infra ...

- integracje funkcjonalnosci i danych - musza przechodzic przez translacje

- mozesz zredukowac niezrozumienie przez narycowanie context map z pokazaniem relationships miedzy bc'ami

- identify each model in project and define its bounded context
// g n: formalnie jest rozroznienie bc od modelu
- nazwij kazdy bc [zgodnie z UL]
- opisz kazdy punkt interakcji miedzy bc'ami, pokaz translacje interakcji, pokaz sharings [pp of model/impl]

- map already existing terrain, not planned one

mapa mozna DOWOLNA forme
- diagram
  - 'chmurki' z nazwami ctx
  - 'chmurki' z wylistowanymi konkretnymi klasami w bc ...
- text
- zwykla dyskusja // g: dosc ulotna forma ;]

- mapa musi byc rozumiana przez wszystkich w projekcie

c: jesli znajdziesz problem przy tworzeniu mapy [np. niekonsystentny bc]
- oznacz taki bc na mapie "dragonem" ;]
- dokonczy rozpisywanie reszty mapy
- zaplanujesz fix "dragonow"


example: two contexts in shipping app

bc: booking    |                             |  bc: transport network
               |                             |
 | Routing |------> | Booking-Transport |    |
 | Service |   |    | Translator        |    |
           |   |                             |   | Transport |
           |------------------------------------>| Service   |
               |                             |

- app ma feat: podczas book'owania jest auto-gener. routing paczek
- c: RoutingService 
  - uzywa intent-revealing + seff
  - result from RS jest okreslony przez assertion: RS zwraca Itinerary ktore spelnie 'RouteSpecification'

c: 
- EE poczatkowo chcial zakodowac internals of RS uzywajac modelu caller'a [booking] ale to bylby blad
- wyszlo - ze
  - RS uzywa klas modelu caller'a tylko na in/out
  - internals robia skomplikowane obliczenia - thus nie pasuja one do modelu caller'a
// g n: wewn. alg. jest niezalezny od zewn. caller'a - Twoj czeste case!

- n: czasem translacje miedzy bc'ami sa NIEMOZLIWE lub mega trudne [bo np. modele sa bardzo rozne, brakuje danych ..]

- budujemy translatory miedzy modelami [dla args and result of metods]
- tutaj: Booking-Transport Translator
- nad BTT i jego test suite - pracuja zespoly z OBU BC'OW
- translator NIE nalezy do zadnego BC'a
- translator musi [i jest] prosty
- translator musi byc dobrze stestowany UT'ami - zeby uniknac problemow po zmianach w 1 z BC'ow

- w example RS jest z booking i koordynuje dzialan miedzy BC'ami
- RS dziala mega prosto
  - wola metody TransportService z bc:transport!!! [zadnej magii, dodatkowych warstw ..]
  - wczesniej oczywiscie RS wola translator - zeby przygotowac params dla TS i potem ocnvert response
  
// g n: zauwaz ze oba zespoly dzialaja w miare niezaleznie

- RS latwo przetestowac - bo sklada sie z SEFF!

- kluczem do sukcesu integracji sa UT'y RS
- testy wolaja RS - podaja set RoutingSpecification i sprawdzaja result
- to baza do wspolpracy obu zespolow
// g t: doczytaj jak test dzialaja

- bez dzialan bc'e beda sie psuc, nachodzic na siebie
// g: trzeba to pilnowac, nie jest to 'samograj'
- thus
  - explicitly define BCs and ContextMap
  - [iteratively] unify models and relations
  
// g q: jak testowac integracje
// - oba zespoly buduja test suite na translator [ktory jest dosc prymitywna klasa]
// - zespol od RoutingService - testuje ten service [ale pp w polaczeniu z mocked "2nd context service"]
// - zespol od '2nd bc' - testouje ich serwis 'normalnie' [bez przejmowania sie RS etc]

organizing and docing CMaps
- dwa istotne pts
  - nazwij BC [z UL]
  - kazdy wie gdzie sa granice BC'a [wrzucaj bc do osobnych pakietow, ..]
- w kontrze VV - EE jednak doc'uje projekt 'nieformalnymi' diagramami etc [VV chce tylko kod]


ch14.4 relationships between BCs


cele strategi/patterns
- providing targets for succesully org-ing dev work
- giving vocabulary for desc-ing organization

- w realu 'exiting code' moze miec inne patterny niz pokazane przez ee
- then 
  - opisz to asis now
  - z kazdym next refactorem - staraj sie zblizac do docelowego patternu
  
- patterns cover THE MOST COMMON cases [not all!]


ch14.5 shared kernel


- mamy 2x bc
- integracja feats miedzy nimi jest baaardo mala
- thus overhead rom CI - moze byc zbyt wysoki

- nieskordynowane zespoly pracuja na blisko dzialajacych apps // q: to mozliwe u ee?
- mimo ze apps sa spokrewnione - to co teams produkuja - nie musi pasowac do siebie
- z: mamy 2 rozlaczone bc'e
  - zespoly traca kupe czasu na translacje
  - jednoczesnie oba modele sa "slabe" bo nie uzywaja 'czesciowo wspolnego UL'

sol
- wyznacz podzbior domeny - dzielone przez oba zespoly
- podzbior zawiera: kod, scheme db ...
- podzbior jest modyfikowany TYLKO po konsultacjach miedzy teams

- po zmianach SK - musza OBU zespolom przejsc testy [ktore pewnie sa obok SK]

???
- wg EE SK to czesto 'core domain' or podzbior 'generic domain' [or both at once]
- acz z 2nd side - twierdzi ze SK musi byc maly - strange ...
  
- bc'e integruja sie przez shared-kernel 
- a w innych czesciach moga sie dodatkowo integrowac przez 'translacje'

// ddd-reference-2015
- SK powoduje baaardzo bliska relacje miedzy BC'ami
- SK musi byc maly


ch14.6 customer/supplier development teams

// ddd-ref-2015
- mamy 2 zespoly: upstream [wysyla dane] / downstream [pobiera dane]
- US moze miec sukces niezaleznie od DS
- DS - zeby miec sukces - potrzebuje wsparcia US [zeby jakies uslugi wystawic ..]

- DS moze byc zdany na 'laske' US
- US moze byc hamowany przez DS [bo boi sie ze przez zmiany cos zepsuje w DS]

sol
- ustal jasna relacje cust-supp miedzy teams
- potrzeby z DS - sa planowane, budzetowane i impled w US
- mamy scheduler, commitment [kazdy wie co robic] ...

- us moze traktowac ds jako customer [podczas planowania, prac ..]

- opracuj WSPOLNIE automated acceptance tests - ktore beda testowac wystawiany z upstream interfejs
// g: upstream wystawia 'interfejs'
- us dodaje testy do swojego 'test suite' - i nie martwi sie wiecej ze cos spieprzy swoimi zmianami w ds


// book
- glowny flow danych: od us do ds
- ale moze byc tez (lekki) flow w 2nd side
// g: n ze oba kierunki integracji moga byc obsluzone przez 1 interfajs [w us]

typowo: oba systemy 
- obsluguja innych users [maja mocno rozdzielne modele, bc-e]
- sa napisane w innych technologiach [co wymusza rozdzielnosc]

czesto ds ma prawo veta na zmiany w us  
albo kooper. jest cumbersome
i utrudnia to rozwij obu bc'ow/modeli

podczas planowania w us - just address ds needs, plan works for some iteration 123 ...

// g: c: ut'y sa po stronie upstream, chociaz to ds bedzie pp wolal serwis us i to ds [pp] powinien testowac us [?]
// ale nie - testy akcept. sa po stronie us
// dzieki temu us od razu widzi jak cos spieprzy w 'kontrakcie'

ds ma sie zachowywac jak 'customer'
us dopytuje ds jak co ma dzialac ... std relacja z customer'em

testy sa UBER CRUCIAL!!!
uruchamiane po stronie us ale kodowane razem z ds

cust/supp - moze byc uzywany miedzy firmami [na zasadzie std relacji z cust - ktorego 'powazamy' ;]



ch14.7 conformist


ch14.8 anticorruption layer


ch14.9 separate ways


ch14.10 open host service


ch14.11 published language


ch14.12 unifying elephant


ch14.13 choosing you model context strategy


ch14.14 transformations

