ch14 maintaining model integrity


przyklad
- team1 [z domany: payments] - stworzyl obiekt Charge
- team2 [z domeny: invoices] - stwierdzil ze brakuje 'pola x' w Charge i je dodal
- blad - oba zespoly powinny dogadac
  - czy dodac nowe pole do Charge 
  - czy miec osobne modele
- finalnie: utworzono osobne modele z klasami: CustomerCharge / SupplierCharge

mega fundamentalny req: model jest wewn. spojny
- termy sa jednoznaczne [unambigous]
- nie ma sprzecznych rules

- unification - stan 'internal consistency of model'

- model niespojny jest 'bezuzyteczny'

w big systemach 
- nie da sie stworzyc "one big consistent model"
- lub to duuuuzo kosztuje time/money = jest bez sensu

- jak masz kilka modeli to niektore moga sie rozjezdzac
- kluczowe elementy trzeba probowac zachowac spojne

- c: ee sam kilka razy kodowal 'one big model' i dzis wie ze to byl blad


ch14.1 bounded context


- big project musi byc podzielony na many models
- inaczej bedzie buggy, difficult to understand, ...

c
- czasem od razu widac ze mamy rozne modele, eg: system A integruje sie z systemem B
- czasem nie widac, jak w/w sample z SupplierCharger / CustomerCharger

c: czasem w 1 zespole [!] uzywamy 2 modele eg: stary i nowy, etc ..

- techniczna translacja danych miedzy modelami zwykle jest prosta
- trudniejsze jest uzgodnienie terms miedzy modelami [co na co sie transformuje, etc...]

- kazdy model ma explicitly okreslone granice stosowania [context] 
// g: tj pp wiemy ktore subdomains, features obsluguje
- w ramach granic model jest unified [spojny]

context = granice uzywania modelu
granice moga byc 'wyznaczone' przez 
- org. zespolow
- 'powiedzenie' ze model uzywamy w danej czesci app
- fizyczne granice w kodzie [folder, osobna schema w bazie lub wyizolowane struktury]
- ...

- kodujac model "nie przejmu sie" stanem poza nim


example: booking context
- kod integrujacy BC'e - 'siedzi' miedzy BC'ami, nie siedzi w BC

zla praktyke
- mamy 2 zepoly w 1 project [i to jest ok]
- kazdy zespol pracuje nad own BC - ale o tym nie wiedza [typowy case]
- teams czasem/'ad hoc' koordynuja dane, koncepcje ...

good praktyka - zespoly
- okreslily granice BC-ow
- okreslily strategie integracji BC'ow, np. shared kernel

- okreslenie typ relacji miedzy oboma BC'ami to "1st task"

- dzielenie kodu/danych miedzy bc'ami - powinno byc robione BARDZO OSTROZNIE
// g: ale powinno, zeby nie duplikowac stanow, kodu


2 typowe problemy - zw. ze zlaczeniem 2 BC'ow w 1 BC
- duplicated concepts
  - mamy kilka miejsc w modelu ktore wyrazaja podobny [lub ten sam] concept
  - jak sie zmienia 1 rzecz to aktualizujemy w kilku miejscach [!]
- false cognates [bit tricky]
  - ludzie okreslaja tego samego term do okreslenia diff things
  - przyklad ww klasa "Charge"


ch14.2 continuous integration


- kiedy wiele osob pracuje na 1 bc to model ma MOCNA tendencje do fragmentacji
- przy 3-4 osoby to powazny problem!

- fragmentacja niszczy coherency

general problems on changing existing code
- po zmianach - old obiekty/relacje nie dzialaja tak jak pierwotnie zakladano
- dev nie wie ze dany feat istnieje - duplikuje go lub robi podobny
- dev wie o feat ale duplikuje go - zeby nie zepsuc istniejacego feat

- CI daje szybki feedback o problemach

CI dziala na 2 poziomach [jak wszystko w DDD] 
- model concepts
  - continues talks among team members
  - ciagle cwiczenie UL na roznych case'ach
  // g: concepts are also integrated!!!
- implementation = conti. builds, auto-tests


MUST DO
- odpalaj testy automatyczne
- "bezlitosnie" cwicz UL zeby zespol mial wspolny poglad na model
// g: pp nie da sie bez talks oprawocac big, "cross team" concept [jak np. offline w mobi]


ch14.3 context map


ludzie w diff zespolach moga byc nieswiadomi granic BC'ow
to moze 
- rozmywac granice miedzy bc'ami
- tworzyc nadmiarowe interakcje miedzy bc'ami
  
- bc'e maja tendencje do "przeciekania" miedzy soba 

- avoid re-using code between bc'e - to dosc ryzykowne [pp z wyjatkiem shared kernel]

- integracje funkcjonalnosci i danych - musza przechodzic przez translacje

- zredukujesz niezrozumienie przez narysowanie CM

- identify each model in project and define its bounded context
- nazwij kazdy bc [zgodnie z UL]
- opisz kazdy punkt interakcji miedzy bc'ami, pokaz translacje, sharings, ...
// g: formalnie model jest czescia bc

- map already existing terrain, not planned one

use any map form
- diagram chmurek z
  - nazwami ctx
  - wylistowanymi konkretnymi klasami w bc ...
- zwykly text
- zwykla dyskusja

- mapa musi byc rozumiana przez wszystkich w projekcie

c: jesli znajdziesz problem przy tworzeniu mapy [np. niekonsystentny bc]
- oznacz taki bc "dragonem" ;]
- dokonczy rozpisywanie reszty mapy
- zaplanuj fix "dragonow"


example: two contexts in shipping app
- feat: podczas book'owania jest auto-gener routing paczek

bc: booking    |                             |  bc: transport network
               |                             |
 | Routing |------> | Booking-Transport |    |
 | Service |   |    | Translator        |    |
           |   |                             |   | Transport |
           |------------------------------------>| Service   |
               |                             |

- c: RoutingService 
  - uzywa intent-revealing + seff
  - result from RS jest okreslony przez assertion: RS zwraca Itinerary ktore spelnie 'RouteSpecification'

c: 
- EE chcial zakodowac RS uzywajac modelu bc:booking - ale to bylby blad
- wyszlo - ze
  - RS uzywa klas modelu bc:booking tylko na in/out
  - impl robi skomplikowane obliczenia - nie pasujace do modelu bc:booking
// g: wewn. alg. jest niezalezny od caller'a - czesty case!

- n: czasem translacje miedzy bc'ami sa NIEMOZLIWE lub mega trudne [bo np. modele sa bardzo rozne, brakuje danych ..]

translator miedzy modelami [dla args and result of metods]
- Booking-Transport Translator
- BTT i jego test suite - koduja zespoly z OBU bc'ow
- translator NIE nalezy do zadnego BC'a
- translator musi byc 
   - prosty
   - dobrze stestowany UT'ami - zeby uniknac problemow po zmianach w 1 z BC'ow

- ww RS jest z booking, koordynuje dzialan miedzy BC'ami
- RS jest mega prosty
  - wola metody TransportService z bc:transport!!! [zadnej magii, dodatkowych warstw ..]
  - przed/po call - RS wola translator - zeby przygotowac params dla TS i odebrac response
  
// g: zauwaz ze oba zespoly dzialaja w miare niezaleznie

- RS latwo przetestowac - sklada sie z SEFF

- kluczem do sukcesu integracji sa UT'y RS
- testy wolaja RS z params i sprawdzaja result
- to baza do wspolpracy obu zespolow


- bez dzialan bc'e beda sie psuc, nachodzic na siebie
// g: trzeba granic pilnowac, nie jest to 'samograj'
- thus
  - explicitly define BCs and ContextMap
  - [iteratively] unify models and relations
  
// g q: jak testowac integracje
// - oba zespoly buduja test suite na translator [ktory jest 'prymitywna' klasa]
// - zespol od RoutingService - testuje ten service [ale pp w polaczeniu z mocked TS service]
// - zespol od '2nd bc' - testuje TS serwis 'normalnie' [bez przejmowania sie RS]

organizing and docing CMaps
- dwa istotne pts
  - nazwij BC [z UL]
  - kazdy wie gdzie sa granice BC'a [wrzucaj bc do osobnych pakietow, ..]
- w kontrze VV - EE jednak doc'uje projekt 'nieformalnymi' diagramami etc [VV chce tylko kod]


ch14.4 relationships between BCs


cele patterns
- show well org-ed relations between bc-s
- set vocabulary for desc-ing organization

- current system moze miec inne patterny niz showed by ee
- opisz je dokladnie asis now
- z kazdym refactorem - staraj sie isc do docelowego ee pattern
  
- patterns cover THE MOST COMMON cases [not all!]


ch14.5 shared kernel


- its very strong interdependency
- SK powoduje baaardzo bliska relacje miedzy BC'ami

- czasem overhead of CI [miedzy bc'ami] jest too high
- to szczegolnie widoczne kiedy
  - teams nie maja skill'a w CI
  - big team dzielimy na mniejsze ze wzgl. organizacyjnych
    - stosowanie CI tutaj to overhead - moze powinni oni wspoldzielic czesc UL/model/code?

sol
- zespoly wydzielaja maly fragment UL/modelu/kodu/bazy/... - ktory wspoldziela
- oznacz explicit shared obszar [g: np. pakiet]
- ten obszar moze byc zmieniany TYLKO w konsultacji miedzy zesplami
// g: nawet jak projekt nie uzywa BC'ow [big bull of mad] to zmiany w 'other BC-s' musza byc konsultowane z owner'ami

- define CI - ktory bedzie pilnowal by SK byl maly i spojny [g: sensie UL] i by pasowal do UL'i innych BC-ow/teams
- po zmianach SK - OBU zespolom musza przejsc testy [ktore pp leza obok SK]

- SK musi byc maly

- use case
- mamy 2 rozlaczone bc'e
- zespoly traca kupe czasu na translacje
- jednoczesnie oba modele sa "slabe" bo nie uzywaja 'czesciowo wspolnego UL'

c: te same bc'e moga integrowac sie przez shared-kernel i jednoczesnie przez inne mechs


ch14.6 customer/supplier development teams


- mamy 2 zespoly: upstream [narzuca zmiany] / downstream [nie ma wplywu na zmiany]
- US moze miec sukces niezaleznie od DS
- DS - zeby miec sukces - potrzebuje wsparcia US
- c: US moze byc hamowany przez DS - bo boi sie zmiany - zeby nie zepsuc DS

c: czesto jest problem z dogadaniem sie
- ds ma prawo veta na zmiany w us  
- cooper jest cumbersome
.. utrudnia to rozwij obu bc'ow

sol
- ustal relacje cust-supp miedzy teams
- potrzeby z DS - plannuj i realizuj w US [np. w iteracjach realizuj new feats]

- cooper w cust/supp jest zformalizowana [wspolne: planowanie, rozw. problemow, pakiet testow]

- us traktuje ds jako customer [podczas planowania, impl ..]
- ds zachowuje sie jak 'customer'

- testy sa UBER CRUCIAL!!!
- opracuj WSPOLNIE automated acceptance tests - do testowania interfejsu z upstream
- us dodaje testy do swojego 'test suite' 
- us moze zmieiac swoj kod - nie martwi sie ze cos spieprzy w usludze
// g: upstream wystawia 'interfejs' - ale pp niezawsze


// book
- glowny flow danych: od us do ds
- ale moze byc tez (lekki) flow w 2nd side
// g: n ze oba kierunki integracji moga byc obsluzone przez 1 interfajs [w us]

typowo: oba systemy 
- obsluguja innych users [maja mocno rozdzielne modele, bc-e]
- sa napisane w innych technologiach [co wymusza rozdzielnosc]

// g: 
// ut'y [testy akceptacyjne] sa po stronie upstream, chociaz to ds wola serwis us
// dzieki temu us od razu widzi jak cos spieprzy w 'kontrakcie'

- cust/supp - moze byc uzywany miedzy firmami, na zasadzie relacji z supp-'szanowany-cust'
- cust jest traktowany bardzo powaznie [cust nie 'blaga o features']
- c: moze byc wielu customers - ich rzadania moga byc "uwspolnione"
  
example
- analyses pobiera dane z booking [zeby wyliczyc optymalne strategia zarabiania: wyzszy overbooking, 1st book for high contracts ..]
- duzo danych trzeba przeslac z us do ds
- c: us potrzebuje tool do reliable notifying ds o 'zmianionych danych' i jakis 'export utility'
// g: dane z us do ds nie musza isc serwisem, moze byc inny kanal

c: ee czesto widzial cus-sup pattern, czesto nieformalnie zorg, gdzie management zespolow dogadywal zmiany miedzy bc'ami
// g: miekkie skills sa potrzebne

- cus-sup sprawdza sie best jak oba teams maja wspolny top management


cont. here vvv


ch14.7 conformist


// reference
case: 
- mamy us/ds
- us nie ma zadnej "motywacji" zeby realizowac needs of ds

- c: tylko altruizm moze motywowac us zeby dawac promises dla ds - ale to bardzo malo pp w realizacji

- ds musi nauczyc sie pracowac z tym co ma aktualnie dane, nie moze oczekiwac wiecej

kontrowersyjne
- wyeliminuj zlozonosc tranlacji miedzy bc'ami - przez niewolnicze dostosowanie sie do modelu us
- to 'srednie' rozw. dla designers - ale podjescie conformity ENORMOUSLY simplify integration
// g: to dosc dziwne - bo dla kazdego innego podejscia brak translacji 'uprosci integracje'

- bierzesz UL z us

- c: altruizm wystarczy tylko na pobranie z us do ds tylko wyjasnienia jak to dziala


// book

- confor - moze warto sotsowac kiedy supp/cust zachodzi miedzy 'obcymi firmami', bez wspolnego managementu
inne cases
- supp ma many customers i nie wszystkich ceni
- supp zmienia model dzialania i porzuca stary model

sciezki integracji
- ds rezygnuje z us bo np
  - zyski sa przeszacowane
  - koszty sa niedoszacowane
  .. i to oznacza relacje 'SEPARATED WAYS'
- musimy korzystac z us [bo polityka, bo wazne dane wystawia ..]
  - przez ANTI-CORRUPTION LAYER
    - bo model us nie podoba nam sie i chcemy sie od niego odizolowac
  - CONFORMIST - jesli model us jest w miare ok

- w confor - zaleznosc ds od us jest turbo duza

- confor - jest podobny do shared kernel
- bo czesc modelu/kodu jest wspolna
- ale
  - w SK - mamy kooperacje miedzy teams
  - w confo - zgadzamy sie na all co us daje

// g: ale ten model chyba [wg tego co SS mowil] jest raczej nieuzywany


ch14.8 anticorruption layer


// ref15
- w typowo miedzy bc'ami mamy only translations
- ale podczas intergracji z trydnym zespolem/systemem - translacja ma 'agresywny ch-er' - ACL

how it works
- ds client tworzy 'isolating layer' ktory wyrazi features of us w termach 'ds UL'
// g: ale std translacje - tez zmieniaja lang [chyba]

zwykle nie chcesz zalezec od zewn. modelu [bo np. jest niespojny]

// book

- acl = tranlation layer z dodatkowymi fasadami, trnaslatorami, adapterami

- z: mamy system w budowie ktory integruje sie przez duuuzy interfejs z innym systemem
- trudnosc z "polaczeniem i rozdzieleniam" obu modeli moze overwhelm intencje o dobrym modelu w new system
- finalnie new model bedzie przypominal model z old systemu

- old systems maja zwykle week models
- acz integracja czesto jest MUST HAVE i musimy sie integrowac
- acz integracja jest mega dobra forma re-use'a old systemu

c
- czesto nowy system musi cooper z wieeeeeeeloma old systemami
- pp nowy model bedzie pod wplywem modeli starych systemow
- moze nastapic 'corruption' of new model!!!

- w integracji czesto skupiamy sie na technikalaich [uzgodnienie transportu, modeli danych ...]
- czesto jest pomijane upewnienie sie ze modele pasuja do siebie semantycznie
- czesto devs sa w bledzie kiedy wymieniamy mega podobne dane miedzy systemami - i mysla ze znacza one 'to samo'
- zwykle NIE jest to to samo!!!
- zwykle wystepuja subtelne ale wazne roznice w znaczeniu danych

c
- jesli widzimy wrecz identyczne dane w 2 systemach
- to zwykle BLEDEM jest robienie interfejsu do 2nd systemu i operaowanie na LL [bo to pp rozne dane]

n: wg ee: interface = interkacja, polaczenie miedzy systemiami (a nie Java syntax)

operowanie na LL interfajsie powoduje ze
- nie wyrazimy dobrze termow z 2nd systemu
- zabrudzimy nasz model 'zle zrozumianymi' termami z 2nd systemu

SOL
- musisz stworzyc acl ktory wystawi feats of 2nd system - uzywajac terms naszego systemu

- acl to translator koncepcji / zachowan z jednego bc w inny

- acl sam z siebie moze byc calkiem big/complex piece of soft
// g: i to rozroznia acl od 'std translation layers'

interf. wystawiony z acl
- zwykle ma forme kilku serwisow [uzywajacych w 'local UL']
- c: czasem ma forme entity [tak, entity]

IMPLING ACL
- acl zawiera: fasady, adaptery, translatory, serwisy ...
- ta struktura to tylko propozycja od ee 
- fasada - wystawia 'raw methods' of external system, wola extern system, dziala na outer system model
- adapter - transformuje wywolania i dane z naszego systemu na outer i odwrotnie
- serwis - wystawiony do wywolan dla naszego bc, wola adaptery etc...
- translator 
  - adapter wie jak wywolac fasade
  - transformacje danych sa robione w translatorze

// g: acl zawiera 'translator' 
// thus 'translator' to mech. ktory transformuje dane z 1 to other class

// g: global n: detale patternow etc ... doczytuj w ksiazce, sam tego nie wymyslaj

notes
1 your bc wola zewn. system, ale czasem zewn. system wola your bc [np. jakis event zwrotny etc]
  - robisz wtedy 2-directed acl
2 gdzie wrzucic acl
  - czasem jest na serwerze z your bc, czasem dziala na serwerze z outer system, 
  - czasem czesci dziala tu i tu [linia podzialu jest np. na adapter'ach - roznie]
// g: remember ze acl - glownie oddziela od CONCEPTUAL CORRUPTION [a nie tech. problems]
3 if possible - zlec po stronie outer-system wykonanie serwisow pod twoje potrzeby
  - zaoszczedz to w cholere roboty
4 olewasz to, a to blad - szeroka integracja jest czaslochlonna
  - kupa roboty z translatorami, przemodelowaniem outer model na nasz ...
    - duza zadan = moze sie to wymknac z kontroli
  - mozna zniszczyc integrity of our bc model
  - czsem lepiej uproscic integracje = uzyc conformist
5 do acl mozesz dodac features: logging calls, auditing ..

acl uzywamy glownie gdy nie mamy wyplywu na zewn. system
ale czasem mozemy uzyc do integracji z outer OWN system - szczegolnie gdy outer system ma inny model

EXAMPLE: LEGACY BOOKING APP
- acl glownie chroni nasz model przed zewn. wplywami
- nasz model jest 'mega-odizolowany' od outer system
- thus: mozemy poczatkowo sie z kims zintegrowac acl'em, a z czasem odciac od niego [przejac czesc feats]

chinski mor
- dynastia ktora go budowala - upadla finansowo przez to
- w przypadku acl podobnie - koszty izolacji moga byc wyzsze niz benefity


ch14.9 separate ways


// ref15

- c: musisz byc ruthless jesli chodzi o def. wymagan ;]
- jesli BC'a maja malo znaczaca relacje - to nalezy ja przeciac i znalezienie work-around [prostszy niz integracja]
- integr. jest ZAWSZE EXPENSIVE a czasem zyski sa male


// book

nieoczywiste:
- koszty integracji
  - koniecznosc koordynacji zespolow
  - wymuszenie kompromisow w zespolach
- problemy
  - zespol moze nie byc gotowy organizacyjnie, moze nie wypuszczac reqed feats na czas ...
  - ciezko przygotowac model ktory zaadresuje 'own needs' i needs of outer team
    // g: tu EE jest niespojny bo pisal ze nie patrzysz poza bc

- czesto integracji nie warto robic [na poziomie modeli, bc'ow]
// g: czesto jako model widzisz dane - ale pamietaj tez o BEHAVIOURS!!!

- zamiast integrowac - pozwol dev'om znalezc "inne rozwiazanie"
- zintegruj features na poziomie ui, middleware ...
  - ale tu tez na tym wyzszym poziomie - minimalizuj wymiane danych miedzy BC'ami
  - to turbo wygodne [vs integr. na poziomie modelu]
  
EXAMPLE: INSURANCE ...
- byl projekt ktory integrowal feats dla agantow, obsluge odszkodowan ...
- po roku byl fail - nie wypracowali rozwiazania - pp bylo za trudne
- sol: stworzyli set malych apps - ktore integrowaly sie na poziomie 'ui'
- tu byl sukces!
- ale potem wrocili do old way - i znowu byl fail ;]
// g: Ty czesto laczysz diff models na poziomie models - a to bez sensu


ch14.10 open host service


// ref15

- jak bc-e integruja sie pojedynczo miedzy soba - robienie osobnych translacji miedzy nimi ma sens
  - kazdy ("bc caller") zachowuje spojny wewn. model
  - dla kazdego bc-a z ktorym sie integrujesz - tworzysz 'integration layer'
- ale jak 1 bc integruje sie z wieeeeeloma innymi bc'ami
  - to robienie indywidualnych tranlacji nie ma sensu, zwalnie development
  - potem trzeba to jeszcze utrzymywac ...
// g: trans-layer zawsze jest ale czy zawsze transluje UL miedzy BC'ami? 
// t: sprawdz projs of vv, pilo ...

SOL
- wystaw dany podsystem jako "protokol" / serie serwisow
- jak trzeba - dodawaj nowe feats - na potrzeby all clients

- ale jak masz wsrod klientow - 1 special - to dla niego mozesz przygotowac translotor, zeby ten need obsluzyc ...
// g: cos tu nie rozumiem

- w tej relacji all clients sa ds, wiekszosc w roli conformisty, ale czesc zbuduje ACL
// g: moze conformista nie jest zly jak masz w miare dobre relacje miedzy zespolami, dobry model z us ...
// g: in worst case zrob just ACL ;]

// book

- to calkiem complex - stworzyc interfejs uzywany przez wiele zespolow
- thus - rob to tylko jesli masz duzo klientow [tysiace?]
- klienci sa coupled do modelu OH
  // g: acz moga uzyc acl


ch14.11 published language


// ref15

- dodajemy common lang miedzy 2+ bc'ami [kazdy BC ma own UL, transformujemy go na PL i potem na UL of next BC]

- useful - jesli ktorys nie mozemy korzystac z modelu z bc'ow bo jest too complex or too poor

n: jesli ktorys z modeli uzyjemy jako PL - to trudno go potem rozwijac, zostaje zamrozony

// g: pub-LANG - to forma UL?

SOL
- use WELL-DOCED shared [published] language
- to jezyk POSREDNI miedzy BC'ami wiec robimy translacje z BC1 na PL i z PL na BC2

- many industreis have ready to use "data interchange PLs"
- firmy wewn. tez moga zdef taki PL

- PL jest czesto uzywany z OHS


// book

sample cases
- integrujemy 2 stare systemy, nie wiemy jakim modelem wymieniac dane/interakcje
- app A i B maja wymieniac dane, nie wiemy ktora app do ktorej ma sie dostosowac
  - moze nie moga sie wzajemnie uzalezniac - thus uzyj PL
  - uzycie modelu jednej z apps - zamrozi jej model na zmiany
  
- c: OHS uzywa model domeny do wymiany danych miedzy systemami // g: really?
- w PL publikujemy specjalny jezyk/protokul

c
- xml i dtd defs wiele standards w przemysle/biznesie
- to forma PL

EXAMPLE: ..
- EE robil system ze many users mialo laczyc sie do DB2 - ale majac tylko 1 lic. na DB2
- EE opracowal PL [podzbior sql'a db2] i dzialalo [n: tu PL byl 'techniczny', nie domanowy - ale przyklad oddaje intencje PL ;]

EXAMPLE: CHEMISTRY
- jest PL do opisu czastek chemicznych Chemical Markup Language
- use it do wymiany danych (o str. checmicznych) miedzy apps

c: jak mamy protokul PL - to mega giga duuuuzo outer tools moze z niego korzystac
np. w/w CML jest uzywany przez apps do wizualizacji czastek etc...
daje to mega potencjal

// g: moze PL ma sens w przypadku gdy tych integracji jest duuuuzo [jak ohs]


ch14.12 unifying elephant


example
- few blind men - ma inna wizje elephant - jeden widzi sciane, inny waz ...
- jesli oni sie nie integruja - to nie ma znaczenia ta wizja

- n: mamy jeden model [elephant] roznie opisany = not unified

- each blind men - creates own bc with it's model of elephant

zintegrujmy w/w bc-e
- sample bc-e
  - | elephane |-------|> | wall |
  - | elephane |-------|> | tree |
  - | elephane |-------|> | snake |
  - ...
- men chca share'owac infa o elephant [np. lokacja]
- aktualnie each bc ma juz own property for location [rozne: location, positions, gps-metrics ..]
- kazdy bc ma own PoV 'czym jest elephant'
- c: kazdy men bedzie twierdzil ze to jego model jest ok
- ale all bc-e maja wspoldzielic elephant-location

- z: po dluuugich i ciezkich dyskusjach men zauwazyli ze rozmawiaja o czyms jednym
- powstal nowy diagram relacji miedzy bc'ami [dosc hc]

- vin: diff apps can desc the same reality but from diff PoV
- to implikuje problems - jak apps maja sie dogadac, jak update'owac

n
- model polaczonych bc-ow jest 'bez sensu' ale dziala [owner'zy nie odkryli jeszcze calej prawdy o modelu]
- nowe insighe sie pojawia i trzeba do zrefaktoryzowac

- jak masz wiele bc'ow do integracji to dopracuj ich perspektywy patrzenia w domain 
- zeby byly spojne [unified] - zeby kazdy widzial 'slonia'

c
- there is no way for blind men to see whole elephant
- this prob can be fixed - if they realize their view on bc's are incomplete


ch14.13 choosing your model context strategy


n/w to lista opcji jak mozesz rozwinac context map - jak juz masz zdef. curr. CM

1. team decission or higher
- zespoly okreslaja granice bc'ow i relacje miedzy nimi
- ew. ktos "z gory" podejmuje taka decyzje
- zespoly MUSZA znac granice bc'ow i relacje miedzy nimi

c: czesto polityczne decyzje wplywaja na granice bc'ow i ich relacje

2. putting ourselves in context
przyklad zawezenia obszaru dzialania
- typowo bedziesz w proj. 'under change' i bedzie sie on komunikowal z 2nd system
- your system bedzie skaldal sie z 2x bc i beda one gadac z 2x inne bc'e
- in 1st you will be interested in your bc's, as 2nd: relacjami z other bc's

3. transforming boundries
- jest nieograniczona liczba przesuwania granic bc'ow
- ale bedziesz mial czynniki
  - favoring large bc
    - 1 unified model [UM] pozwala plynniej realizowac zadania z user PoV
    - latwiej zrozumiec 1 UM niz 2 rozdzielone i zintegrowane
    - translacja miedzy M moze byc trudna a wrecz NIEMOZLIWA!!!
    - ..
  - favoring small bc
    - no overhead w komunikacji miedzy devs [mniejsze modele, latwiej uzgodnic zmiany]
    - mniejsze CI [bo mniej kodu, mniejsze zespoly ..]
    - latwiej ogarnac kognitywnie maly model - mniejsze "IQ" wymagane do devs

4. accepting that ...
- czesto twoja app zalezy od innych, legacy systems
  - i to ok [bo re-use]
- czesto w legacy mamy contradictions - i nie bardzo mozna je uznac ze 'formalne bc-e'
// g: czym zatem jest legacy system, not-bc?

5. relationships with exter. systems
// g: bo masz relations to other bc [ale w Twojej app] i other bc w innych apps
mozliwe drogi
- separated ways
- if must integrate
  - conformist
    - use if have large legacy i dorabiasz do niego extension
    - nie modyfik. tego large system
    - c: ee podaje sample of excell spreadsheet - jako 'legacy' i dodajesz do niego extension
    - oplaca sie jesli translacje miedzy bc'ami byly by wieksze niz dodanie samej funkcjonalnosci
    - c: wg ee w confo tez da sie zrobic good design [mimo weak model]
    - c: ee zaleca w confo przerobic src model na bardziej explicite w kierunku Twoich needs
  - acl
    - jak nowy system pp bedzie duuuzy to moze warto oddzielic sie od legacy przez acl
    
    
6. the system under design

- sud - to projekt ktory budujesz
- w sud decydujesz ile ma byc bc i jakie relacje
example
- do 1 bc jak masz < 10 osob i funkcje sa highly related

z czasem, jak system robi sie wiekszy to moze 
- podziel go na osobne bc'e integrated with shared-krenel
- gdzie kazdy BC ma < 10 osob

ale teams moge sie clash'owac
- bo modele sie rozjechaly i maja inne needs
- bo management sie nie dogaduje
- ...
jak nie da sie clash rozwiazac [albo nie chcesz ich rozw.] to idz w 'separated ways'

- typowo 1 team robi 1 bc [or many bc-s]
- odwrotnie: n-teams robi 1 bc jest raczej klopotliwe


7. caterging to special needs

- w ramach 1 biznesu - rozne grupy moga miec rozny zargon [ul]
- mimo ze all ma wspolna baze
- ustandaryzowanie zargonu moze byc hard i nieefektywne

- jak masz diff modele ale nie integrujace sie - to nie ma problemu - kazdy gada po swojemu i ok

- acz czasem integracja 'zargonow' pozwala oszczedzic bo ulepszamy model w 1 bc a nie kilku
- i pp integracja bedzie robic translacje [bez acl] or shared-kernel [totalnie bez translacji]
// g: w SK totalnie oszczedzasz na tranlacjach


8. deployment

- uzgadniasz w cust/supp - kto, co, kiedy wypuszcza
- warto miec "translation layers" w 1 procesie zeby miec ich 1 wersje 
// g: acz to czasy pre-microserive'owe - to sie moglo zmienic


9. trade-off

- nice chart 
  - x - poziom komunik. miedzy teams
  - y - poziom kontroli nad bc'ami
- if x,y max -> maybe use single bounded context
- if x,y weaker -> to moze: sk, if weaker - cust/supp
- if x,y = zero -> separated ways


10. proj. under way

// cut, nothing


ch14.14 transformations

czesto bedziesz musial
- przesuwac granice bc'ow
- zmieniac relacje miedzy bc'ami

- podziel bc na mniejsze - to proste
- merge'owanie i zmiana relacji - to trudne

- ee pokaze kilka 'representative' big changes

1. merge 'separated ways' -> 'shared kernel'
- bc warto merge'owac gdy duplikacja data/behaviours miedzy bc'ami jest duza
- sk warto uzyc gdy translations overhead jest za wysokie

etapy
e1: upewnij sie ze kazdy model jest unified
e2: ustaw proces tech. build'owania/ci obu projektow
  - SK musi miec test suite - ktory testuje model fragment SK po wbudowaniu w part. bc
e3: wydziel do sk jakis maly fragment, zduplikowany w obu bc'ach
e4: eliminuj dalsze duplikacje
... etc

2. merge to CI
// cut

3. phasing out legacy system
- legacy konczy zywot i go wycinamy
- to kilkuletni proces
// cut ...

4. ohs to public language
// cut ...



PARTNERSHIP **

- only in reference-2015

case: 2 bc'e razem fails or succeed

- brak koordynacji - powoduje fail obu projektow/bc'ow
- bo jesli feat A ma byc wystawiony z systemu A dla B [i odwrotnie] a nie jest - to oba systemy maja fails

- zla koordynacja spowolni oba systemy - bo bedzie strach przed zmianami, oczekiwanie na zmiany ...

sol
- wymus partership miedzy zespolami budujacymi bc'e
- powolaj proces do koordynacji prac w obu zespolach
- zespoly razem zarzadzaja koordynacja
- zespoly kooperuja nad dostarczaniem interfejsow for needs of both systems
- trza zrobic schedul poszczeg. features zeby calosc byla zaplanowana i gotowa do integracji na czas

- zbuduj test suite ktory bedzie
  - definiowac interfejsy miedzy bc'ami
  - udowadnial ze dobrze dzialaja i spelniaja wymagania klientow [2nd side]
// g: takie testy to baza [chyba] all integracji
// g: pp testy powinny byc po stronie supplier'a - odpalane jako czesc CI serwera


BIG BALL OF MUD **

- w old big systems - modele sa mixed, boundries are inconsistent/vague
- proba zrozumienia tego jest helpless

btw
- dobrze zdef. granice bc'ow to efekt wysilkow [a nie samograj]
- inaczej bc'e sie rozjerzdzaja, termy staja sie niejednoz, sprzeczne!
- tworzy sie BBOM

sol
- otoczyc caly syf granica i oznaczyc jako BBOM
- ABSOLUTNIE NIE baw sie wewn BBOM jakiegos sophisticated modeling
- ten syf czesto przechodzi do innych bc'ow!!!!!