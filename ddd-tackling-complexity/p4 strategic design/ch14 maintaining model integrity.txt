ch14 maintaining model integrity


przyklad
- team1 [z domany: payments] - stworzyl obiekt Charge
- team2 [z doemny: invoices] - stwierdzil ze brakuje 'pola x' w Charge i je dodali
- blad - oba zespoly powinny to dogadac
  - czy dodac nowe pole do Charge 
  - czy miec osobne modele
- finalnie: utworzono osobne modele z klasami: CustomerCharge / SupplierCharge

mega fundamentalny req:
- model musi byc wewn. spojny
  - termy sa jednoznaczne [unambigous]
  - nie ma sprzecznych rules

- unification - stan 'internal consistency of model'

- model niespojny jest bezuzyteczny!

- w big systemach - nie da sie stworzyc "one big consistent model"
  - tj: da sie ale to duuuuzo kosztuje time/money = jest bez sensu

- c: jak masz kilka modeli to niektore moga sie rozjezdzac [acz kluczowe elementy trzeba probowac zachowac spojne]

- c: ee sam kilka razy kodowal 'one big model' i dzis wie ze to byl blad


ch14.1 bounded context


- big project musi byc podzielony na many models
- inaczej bedzie buggy, difficult to understand, ...

c
- czasem od razu widac ze mamy rozne modele, eg: system A integruje sie z systemem B
- czasem nie widac, jak w/w sample: SupplierCharger / CustomerCharger

c: czasem w 1 zespole [!!!] uzywamy 2 modele eg: stary i nowy model, etc ..

- technicznie translacja danych miedzy modelami zwykle jest prosta
- trudniejsze jest uzgodnienie terms miedzy modelami [co na co sie transformuje] etc...

- kazdy model ma explicitly okreslony zakres/granice jego uzywania [context]
- w ramach granic model jest unified [spojny]

context = granice uzywania modelu, granice moga byc 'wyznaczone' przez 
- org. zespolu
- 'powiedzenie' ze model uzywamy w danej czesci app
- fizyczne granice w kodzie [folder, osobna schema w bazie lub wyizolowane struktury]
- ...

- kodujac model "nie przejmu sie" stanem poza nim!


example: booking context
- kod integrujacy BC'e - 'siedzi' miedzy BC'ami, nie siedzi w BC

zla praktyke
- mamy 2 zepoly wewn. 1 project [i to jest ok]
- kazdy zespol pracuje nad own BC - ale o tym nie wiedza [dosc typowy case]
- teams musza koordynowac dane, koncepcje ...
- ale integracje robia 'nieregularnie/ad hoc'

good praktyka - zespoly powinny
- okreslic BCe [granice]
- zastosowac konkretna strategie integracji BC'ow, np. shared kernel
  - typ relacji miedzy oboma BC'ami to "1st task"

- dzielenie kodu/danych - powinno byc robione BARDZO OSTROZNIE
// g: ale powinno, zeby nie duplikowac stanow, kodu - but very ostroznie


2 typowe problemy - zw. ze zlaczeniem 2 BC'ow w 1 BC
- duplicated concepts
  - mamy kilka miejsc w modelu ktore wyrazaja ten sam lub podobny concept
  - jak sie zmienia 1 rzecz to aktualizujemy w kilku miejscach [!!!]
- false cognates
  - more tricky
  - ludzie okreslaja tego samego term do okreslenia diff things
  - przyklad "Charge" z poczatku ch 


ch14.2 continuous integration


- kiedy wiele osob pracuje na 1 bc to model ma MOCNA tendencje do fragmentacji
- juz przy 3-4 osoby to powazny problem!

- fragmentacja modelu niszczy model coherency

problemy devs przy zmienie istniejacego kodu
- po zmianach - old obiekty/relacje nie dzialaja tak jak pierwotnie zakladano
- dev nie wie ze dany feat istnieje - i duplikuje go lub robi podobny
- dev wie o feat ale i tak go duplikuje - zeby nie zepsuc istniejacego kodu

- CI oznacza ze wszystkie prace [modele?] sa ciagle integrowane (czesto merge'owane) w finalny produkt
- CI daje szyki feedback jak integracja nie dziala

- CI [jak WSZYSTKO!!! w DDD] operuje na 2 poziomach
- model concepts - integration is done by
  - continues talks among team members
  - ciagle ciczenie/testowanie UL na roznych case'ach
  // g: concepts are also integrated!!!
  - c: tech. rzadko zformalizowana
- implementation - integr. is done by conti. builds, tests
  
MUST DO
- odpalaj testy automatyczne
- "bezlitosnie" cwicz UL zeby zespol mial wspolny poglad na model
// g: pp nie da sie bez talks oprawocac big, "cross team" concept [jak np. offline w mobi]


ch14.3 context map


ludzie w diff zespolach moga byc nieswiadomi granic BC'ow, moga
- tworzyc niezaplanowane interakcje
- rozmywac granice miedzy bc'ami
  
- bc'e maja tendencje do "przeciekania" miedzy soba 

- avoid re-use code between bc'e - to dosc ryzykowne [pp z wyjatkiem shared kernel]
// g: pp chodzi o kod modelu domeny, a nie infra ...

- integracje funkcjonalnosci i danych - musza przechodzic przez translacje

- mozesz zredukowac niezrozumienie przez narysowanie context map z pokazaniem relationships miedzy bc'ami

- identify each model in project and define its bounded context
// g n: formalnie jest rozroznienie bc od modelu
- nazwij kazdy bc [zgodnie z UL]
- opisz kazdy punkt interakcji miedzy bc'ami, pokaz translacje interakcji, pokaz sharings [pp of model/impl]

- map already existing terrain, not planned one

mapa mozna DOWOLNA forme
- diagram
  - 'chmurki' z nazwami ctx
  - 'chmurki' z wylistowanymi konkretnymi klasami w bc ...
- text
- zwykla dyskusja // g: dosc ulotna forma ;]

- mapa musi byc rozumiana przez wszystkich w projekcie

c: jesli znajdziesz problem przy tworzeniu mapy [np. niekonsystentny bc]
- oznacz taki bc na mapie "dragonem" ;]
- dokonczy rozpisywanie reszty mapy
- zaplanujesz fix "dragonow"


example: two contexts in shipping app

bc: booking    |                             |  bc: transport network
               |                             |
 | Routing |------> | Booking-Transport |    |
 | Service |   |    | Translator        |    |
           |   |                             |   | Transport |
           |------------------------------------>| Service   |
               |                             |

- app ma feat: podczas book'owania jest auto-gener. routing paczek
- c: RoutingService 
  - uzywa intent-revealing + seff
  - result from RS jest okreslony przez assertion: RS zwraca Itinerary ktore spelnie 'RouteSpecification'

c: 
- EE poczatkowo chcial zakodowac internals of RS uzywajac modelu caller'a [booking] ale to bylby blad
- wyszlo - ze
  - RS uzywa klas modelu caller'a tylko na in/out
  - internals robia skomplikowane obliczenia - thus nie pasuja one do modelu caller'a
// g n: wewn. alg. jest niezalezny od zewn. caller'a - Twoj czeste case!

- n: czasem translacje miedzy bc'ami sa NIEMOZLIWE lub mega trudne [bo np. modele sa bardzo rozne, brakuje danych ..]

- budujemy translatory miedzy modelami [dla args and result of metods]
- tutaj: Booking-Transport Translator
- nad BTT i jego test suite - pracuja zespoly z OBU BC'OW
- translator NIE nalezy do zadnego BC'a
- translator musi [i jest] prosty
- translator musi byc dobrze stestowany UT'ami - zeby uniknac problemow po zmianach w 1 z BC'ow

- w example RS jest z booking i koordynuje dzialan miedzy BC'ami
- RS dziala mega prosto
  - wola metody TransportService z bc:transport!!! [zadnej magii, dodatkowych warstw ..]
  - wczesniej oczywiscie RS wola translator - zeby przygotowac params dla TS i potem ocnvert response
  
// g n: zauwaz ze oba zespoly dzialaja w miare niezaleznie

- RS latwo przetestowac - bo sklada sie z SEFF!

- kluczem do sukcesu integracji sa UT'y RS
- testy wolaja RS - podaja set RoutingSpecification i sprawdzaja result
- to baza do wspolpracy obu zespolow
// g t: doczytaj jak test dzialaja

- bez dzialan bc'e beda sie psuc, nachodzic na siebie
// g: trzeba to pilnowac, nie jest to 'samograj'
- thus
  - explicitly define BCs and ContextMap
  - [iteratively] unify models and relations
  
// g q: jak testowac integracje
// - oba zespoly buduja test suite na translator [ktory jest dosc prymitywna klasa]
// - zespol od RoutingService - testuje ten service [ale pp w polaczeniu z mocked "2nd context service"]
// - zespol od '2nd bc' - testouje ich serwis 'normalnie' [bez przejmowania sie RS etc]

organizing and docing CMaps
- dwa istotne pts
  - nazwij BC [z UL]
  - kazdy wie gdzie sa granice BC'a [wrzucaj bc do osobnych pakietow, ..]
- w kontrze VV - EE jednak doc'uje projekt 'nieformalnymi' diagramami etc [VV chce tylko kod]


ch14.4 relationships between BCs


cele strategi/patterns
- providing targets for succesully org-ing dev work
- giving vocabulary for desc-ing organization

- w realu 'exiting code' moze miec inne patterny niz pokazane przez ee
- then 
  - opisz to asis now
  - z kazdym next refactorem - staraj sie zblizac do docelowego patternu
  
- patterns cover THE MOST COMMON cases [not all!]


ch14.5 shared kernel


// ref

shared kernel
- sharing a part of the model and its code is a very strong interdependency
- czasem overhead of cont. integration [miedzy bc'ami] seems to be too high w ctx
- to szczegolnie widoczne kiedy
  - teams nie maja skill'a dla CI 
  - one team is too big - i dzielimy duuzy BC/team na mniejsze glownie ze wzgl. organizacyjnych
- i kiedy tak rozdzielone teams - stosuja CI - to jest to overhead - bo moze powinny realnie wspoldzielic czesc UL/model/code?

sol
- zespoly wydzielaja maly fragment UL/modelu/kodu/bazy/... - ktory beda wspoldzielic
- oznacz explicit shared obszar [g: np. pakiet]
- ten obszar moze byc zmieniany TYLKO po konsultacji miedzy zesplami
// g: nawet jak projekt nie uzywa BC'ow [HPortalen] to zmiany w 'other BC-s' musza byc konsultowane z owner'ami

- define CI - ktory bedzie pilnowal by SK byl maly i spojny [g: sensie UL] i by pasowal do UL'i innych BC-ow/teams

- SK powoduje baaardzo bliska relacje miedzy BC'ami
- SK musi byc maly


// book

- nieskordynowane zespoly pracuja na blisko dzialajacych apps
- mimo ze apps sa spokrewnione - teams produkuja nie pasujace produkty
- z: mamy 2 rozlaczone bc'e
  - zespoly traca kupe czasu na translacje
  - jednoczesnie oba modele sa "slabe" bo nie uzywaja 'czesciowo wspolnego UL'

sol
- wyznacz podzbior domeny - dzielone przez oba zespoly
- podzbior zawiera: kod, scheme db ...
- podzbior jest modyfikowany TYLKO po konsultacjach miedzy teams

- po zmianach SK - OBU zespolom musza przejsc testy [ktore pewnie sa obok SK]

- bc'e integruja sie przez shared-kernel 
- a w innych czesciach moga sie dodatkowo integrowac przez 'translacje'


ch14.6 customer/supplier development teams


// ddd-ref-2015
- mamy 2 zespoly: upstream [wysyla dane] / downstream [pobiera dane]
- US moze miec sukces niezaleznie od DS
- DS - zeby miec sukces - potrzebuje uslug z US

mozliwe ze
- DS jest zdany na laske US
- US jest hamowany przez DS [bo boi sie zmiany zeby nie zepsuc DS]

sol
- ustal relacje cust-supp miedzy teams
- potrzeby z DS - plannuj, budzetuj, impl w US
- tworzymy scheduler, commitment na prace [kazdy wie co robic] ...

- us traktuje ds jako customer [podczas prac planowania, prac ..]

- opracuj WSPOLNIE automated acceptance tests - ktore beda testowac wystawiany z upstream interfejs
- us dodaje testy do swojego 'test suite' - i nie martwi sie wiecej ze cos spieprzy swoimi zmianami w ds
// g: upstream wystawia 'interfejs'


// book
- glowny flow danych: od us do ds
- ale moze byc tez (lekki) flow w 2nd side
// g: n ze oba kierunki integracji moga byc obsluzone przez 1 interfajs [w us]

typowo: oba systemy 
- obsluguja innych users [maja mocno rozdzielne modele, bc-e]
- sa napisane w innych technologiach [co wymusza rozdzielnosc]

- czesto ds ma prawo veta na zmiany w us  
- albo kooper. jest cumbersome
- i utrudnia to rozwij obu bc'ow/modeli

podczas planowania w us - just address ds needs, plan works for some iteration 123 ...

// g: c: ut'y sa po stronie upstream, chociaz to ds bedzie pp wolal serwis us i to ds [pp] powinien testowac us [?]
// ale nie - testy akcept. sa po stronie us
// dzieki temu us od razu widzi jak cos spieprzy w 'kontrakcie'

- ds ma sie zachowywac jak 'customer'
- us dopytuje ds jak co ma dzialac ... std relacja z customer'em

- testy sa UBER CRUCIAL!!!
- uruchamiane po stronie us ale kodowane razem z ds
- bez testow - us bedzie paralizowany obawa przed zmianami!!!

- cust/supp - moze byc uzywany miedzy firmami [na zasadzie std relacji z cust - ktorego 'powazamy' ;]

- imp n: cooper w cust/supp jest zformalizowana [wspolne: planowanie, rozw. problemow, pakiet testow]

imp factors
- cust jest traktorwane bardo powaznie [a nie jak ktos kto 'blaga o features']
  - n: moze byc wielu customers - ich rzadania moga byc "uwspolnione"
  
example
- analyses pobiera dane z booking [zeby wyliczyc optymalne strat. zarabiania: wyzszy overbooking, 1st book for high contracts ..]
- duzo danych trzeba przeslac z us do ds
- c: us potrzebuje tool do reliable notifying ds o 'zmianionych danych' i jakis 'export utility'
// g: dane z us do ds nie musza isc serwisem, moze byc inny tool
// q: q skad ds wie co sie zmienilo? calosc przelicza? a: pp zalezy to od case'a

c: ee czesto widzial cus-sup pattern, czesto nieformalnie zorg, gdzie mgt zespolow dogadywal zmiany miedzy bc'ami
// g: miekkie skills sa potrzebne

cus-sup sprawdza sie best jak oba teams maja wspolny top management


ch14.7 conformist


// reference
case: 
- mamy us/ds
- us nie ma zadnej "motywacji" zeby realizowac needs of ds

- c: tylko altruizm moze motywowac us zeby dawac promises dla ds - ale to bardzo malo pp w realizacji

- ds musi nauczyc sie pracowac z tym co ma aktualnie dane, nie moze oczekiwac wiecej

kontrowersyjne
- wyeliminuj zlozonosc tranlacji miedzy bc'ami - przez niewolnicze dostosowanie sie do modelu us
- to 'srednie' rozw. dla designers - ale podjescie conformity ENORMOUSLY simplify integration
// g: to dosc dziwne - bo dla kazdego innego podejscia brak translacji 'uprosci integracje'

- bierzesz UL z us

- c: altruizm wystarczy tylko na pobranie z us do ds tylko wyjasnienia jak to dziala


// book

- confor - moze warto sotsowac kiedy supp/cust zachodzi miedzy 'obcymi firmami', bez wspolnego managementu
inne cases
- supp ma many customers i nie wszystkich ceni
- supp zmienia model dzialania i porzuca stary model

sciezki integracji
- ds rezygnuje z us bo np
  - zyski sa przeszacowane
  - koszty sa niedoszacowane
  .. i to oznacza relacje 'SEPARATED WAYS'
- musimy korzystac z us [bo polityka, bo wazne dane wystawia ..]
  - przez ANTI-CORRUPTION LAYER
    - bo model us nie podoba nam sie i chcemy sie od niego odizolowac
  - CONFORMIST - jesli model us jest w miare ok

- w confor - zaleznosc ds od us jest turbo duza

- confor - jest podobny do shared kernel
- bo czesc modelu/kodu jest wspolna
- ale
  - w SK - mamy kooperacje miedzy teams
  - w confo - zgadzamy sie na all co us daje

// g: ale ten model chyba [wg tego co SS mowil] jest raczej nieuzywany


ch14.8 anticorruption layer


ch14.9 separate ways


ch14.10 open host service


ch14.11 published language


ch14.12 unifying elephant


ch14.13 choosing your model context strategy


ch14.14 transformations



PARTNERSHIP **

- only in reference-2015

case: 2 bc'e razem fails or succeed

- brak koordynacji - powoduje fail obu projektow/bc'ow
- bo jesli feat A ma byc wystawiony z systemu A dla B [i odwrotnie] a nie jest - to oba systemy maja fails

- zla koordynacja spowolni oba systemy - bo bedzie strach przed zmianami, oczekiwanie na zmiany ...

sol
- wymus partership miedzy zespolami budujacymi bc'e
- powolaj proces do koordynacji prac w obu zespolach
- zespoly razem zarzadzaja koordynacja
- zespoly kooperuja nad dostarczaniem interfejsow for needs of both systems
- trza zrobic schedul poszczeg. features zeby calosc byla zaplanowana i gotowa do integracji na czas

- zbuduj test suite ktory bedzie 
  - definiowac interfejsy miedzy bc'ami
  - udowadnial ze dobrze dzialaja i spelniaja wymagania klientow [2nd side]
// g: takie testy to baza [chyba] all integracji
// g: pp testy powinny byc po stronie supplier'a - odpalane jako czesc CI serwera