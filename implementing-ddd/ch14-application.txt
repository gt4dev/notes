vvvv cont here

# CH14 Application


- application - set of components (model, ui, infrastructure ..) assembled to support domain (business)

  
## user interface


### rendering domain objects


- sa spory jak renderowac domenowe obiekty na UI
- na UI czesto trzeba 
  - pokazac dane z wielu agregatow
  - wykonac modyfikacje tylko 1 A


### Render DTO from Aggreagte Instances


- popularne podejscie
- mozemy pokazac na view stan z wielu roznych agregatow
- DTO ma atrybuty ktore sa "bezposrednio" potrzebne na widoku
- impl
  - AS wola Repos zeby wybrac interesujace As
  - AS przekazuje As do DTO Assembler (Fowler EAA)
  - DTO Assembler z As tworzy DTO
  - AS zwraca DTO
- c: assembler moze dane z A dociagac przez lazy-loading
- c: 
  - AS sam nie tworzy DTO i nie przepisuje danych z A
  - jest rozdzial responsibilities - AS koordynuje zadania
    - wyciagnac As
    - przekazac As do DtoAssembler'a ..
- DTO jest istotne gdy mamy remote calls
  - bez remote calls - DTO moze prowadzic do accidental complexity
  - bo mozliwe ze DTO bedzie podobne do obiektow domenowych - a to bez sensu
- n: projektuj DTO by ukrywac wewn. strukture agregatow
  - DTO maja zbierac dane na potrzeby konkretnych ekranow
- DTO Assembler nie powinien grzebac wewn. agregatu


### use a mediator to publish aggregate internal state


- c: mediator - inne nazwy: double dispatch, callback
- patt. rozwiazuje problem tight couplingu miedzy modelem domenowym (As) a klientami
- klient (AS, DtoAssembler) nie powinien grzebac wewn. A - bo to tight coupling
- agregat publikuje swoj STAN (nie strukture) przez mediatora

class BacklogItem {
  public void provideTaskIterest(TaskInterest interest) {
    // agregat sam (znajac swoja internal struct) ustawia stan mediatora
    interest.informTaskCount(aggregInternalField.Count());
    interest.informType(anotherInternalField.Type().toString());
    ...
  }

- A moze miec serie metod ustawiajacych rozne obiekty mediatora, np: provideBacklogItemInterest(..), provideSthElseInterest(..)
- klient (AS) pobiera A, i wywoluje metode provideSthInterest(..)
- M NIE moze byc specyficzny dla view/use-case!!!
- M informuje o stanie agregatu (ukrywajac wewn. strukture)
- c: M jest tez uzywany przy walidowaniu encji
- c: niektorzy uwazaja ze dodawanie metod provide..Interest to przekroczenie respons. agregatow


### render aggregate instance from a domain payload object


- c: to pattern od VV
- use it gdy klient z modelem dziala na tej samej VM
- dzialanie
  - wez kilka agregatow
  - wrzuc je 'zywcem' do DPO (note: it's DOMAIN-P-O, czyli domenowy)
  - AS tworzy obiekty DPO podobnie jak DTO
  - AS zwraca DPO
  - VM/P sam odpytuje A o dane dla widoku
- ryzyka
  - V jest mocno zbindowany do A - dlatego warto tu uzyc mediator
- c: jak DPO oposzcza AS - to przestaje dzialac lazy-loading (bo call opuscil tx)
  - ale mozna uzyc tzw. eager-loading
- c: tx zwracajacy dane ustaw na 'ready-only'

  
### state representations of aggregate instances


- wazne jesli app wystawia uslugi REST'owe
- dosc podobne do DTO - tylko tu wystawiamy REST'y
- n: REST'y sa projektowane pod potrzeby konkretnych use-case'ow


### use case optimal repository queries


- zamiast z agregatu wyciagac pelne agregaty - czasem lepiej uzyc tzw. use case optimal query
- do Repo dodajesz query metody, zwracajace VO - pokazujace stan agregatow
- VO sa pisane pod dany UC'a (jak w tytule) ale chyba nadal musza byc domain specific
- zwracamy VO klientowi
- VO vs DTO
  - VO jest domain specific (modeluje domene)
  - DTO jest app specific (spelnia wymagania klientow AS)
- c: UC-OQ sa podobne do CQRS
  - 1st: sa wystawiane przez repos z modelu podczas 
  - 2nd (CQRS) ma oddzielna infra pobierania danych
- c: more w CH:repositries


### dealing with multiple, disparate clients


- useful gdy masz roznych klientow do jednego AS, np: http, rest, xml ...
- idea
  - pisz AS niezalezne od typu klientow
  - dodaj do metod AS parametr: DataTransformer - specyficzny dla danego typu klienta
- np: calendarAppService.calendarWeek(date, new CalendarWeekXmlDataTransformer()):CalendarWeekDate
- zwracany obiekt CalendarWeekDate ma metode value()
  - value() jest pp overriden dla kazdego konkretnego transformera
  - value() daje resultat w wymaganym formacie (xml, ..)
- transformery moga zwracac: DTO!, DPO!, json, csv ...
- n: ew. pomysl o hexa/port-adapter jako alter


### rendition adapters and handling user edits


- czasem masz case ze pokazujesz user'ow domenowe dane, user je edytuje i zapisuje
- jak to zakodowac - mocno zalezy od fmwk uzytych w UI
- VV zaleca uzycie PresentationModel
- c: inne nazwy PM = Model-View-Presenter, PassiveView ...
- mamy tu tzw. passive view - view tylko wyswietla dane, kontrolki zbieraja interakcje
- sposoby renderowania view
  - Vs same sie renderuja na bazie PM
    - VV reced way bo nie ma couplingu PM -> V
  - Vs are generated by PM
- PM dziala jak adapter
  - maskuje detale modelu domeny
  - daje props i zachowania wazne dla view
- PM podejmuje decyzje bazujac na modelu
  - np. czy pokazac jakas kontrolke - przez props w PM (ale wyliczony z modelu)
- c: dodatkowa zaleta: PM moze wystawic get/set-ery (na potrzeby UI fwk) wrapujac model 
  - a tego nie wolno robic modelowi (dla PM to ok)
- PM moze uzywac dowolnej technika czytania modelu (DTO, DPO, Mediator ..)
- PM ma metody "listenery przyciskow", stan pol ...
- PM nie moze stanowic sam z siebie AS'a, bo to pomiesza respons!!!
  - PM tylko prezentuje "dane"
  - AS ma troche inne resps


## Application services


- czasem UI prezentuje dane z wielu BC'ow uzywajac niezaleznych PM's
- AS sa bezposrednimi klientami domain modelu
- AS koordynuja serie zadan wewn. use case (1 metody AS)
- metody AS okreslaja granice transakcji, tj: 1 metoda = 1 tx
- zajmuja sie tez security
- powinny byc bardzo cienkie - tylko wolanie zadan, koordynowanie z modelu


### sample AS


- VV w AS czasem rozdziela interfejs od impl. a czasem nie
- przyklad: interface TenantIdentiyService
- all metody dotycza tylko zmian/czytania tenant'a 
- n: tworz osobne AS'y dla waznych feats modelu (a nie 1 AS na caly model)
- metody w AS
  - modyfikuja T
  - zwracaja szczegoly (nawet caly A Tenant!)
      tenant(TenantId tid):Tenant 
- n: AS sluzy do czytania na potrzeby UI
- wg VV
  - czasem UI moze znac detale model domeny
    - jak masz tylko 1 klienta to coupling az tak nie boli (zaleznie od sytuacji)
  - czasem AS'y ukrywaja szczegoly modelu domeny
    - zwracaja DTOs a params to prymitywy, commandy
    - ma to sens jak masz wielu klientow, moze nawet roznych, nie masz kontroli nad klientami, domena sie czesto zmienia ...
- zatem input/output w AS moga byc
  - obiekty domenowe (TenantId, Tenant, ..)
  - DTO, prymitywy (string, int, ..), command (na wejsciu)
- zaden z tych sposobow nie jest zly lub dobry - all zalezy od sytuacji
  - jak uzywasz prymitywow to ukrywasz model, latwiej go potem zmieniac, ale tracisz validacje ...
  - DTOs trzeba napisac, moga wprowadza accidental complexity, niepotrzebne obiekty w pamieci ...
- c: VV nigdy nie uzywac postfix'ow DTO, VO ... zeby okreslic typ obiektu
- metody AS uzywaja anotacji
  - @Transactional - command
  - @Transactional(readOnly=true) - query
  - @PreAuthorize(hasRole('someRole')) - ze SpringSecurity
  - n: ALL AS methods maja ALL ww attrs
- c: SS tez przestrzega przed tworzeniem zbyt wielu warstw - zeby nie robic accidental complexity
