# ch10 aggregates

- grupowanie encji i vo w agregaty to jeden z mniej zrozumiałych tematów DDD

- typowy problem to robienie zbyt duzych agg (i zagniezdzanie full entities)
- nie mozna tez pociac agg na 'zbyt male' bo to nie chroni invariants


## 1 using aggregates in the scrum core domain

- samples base on bc=apm


### 1.1 1st attempt: large-cluster aggregate

- assume Product is very large agg
- contains objects: BacklogItem, Release, Sprint ..

- klasa wyglada prosto
- ale stworzy tone problems
  - many tx will fail (conflicts)
    - q: czyli w "1 user env" to wygodne i ok podejcie?

optimistic concurrency
- class Product extends ConcurencySafeEntity
- CSE impls optimistic concurrency
dzialanie OC
- CSE zawiera pole concurrencyVersion (tabel ma kolumne concurrency_version)
- podczas zapisu E - jesli numer wersji jest starszy niz juz zapisany w bazie - to update jest odrzucany
- hbm uzywa elem <version> do wskazania pola
sample
- user A i B pracuja na tym samym obiekcie Product,ver=1
- A dodaj BacklogItem i robi commit, teraz ver=2
- B dodaje Release i probuje zrobic commit - tx fails bo ma stale ver

c: nadpisywanie zmian w key-value stores
- przy kazdym zapisie agg - zapisywana jest jego CALA zawartosc
- to nappisuje zmiany innych user'ow nawzajem
- to niedopuszczalne

n: poza fails of tx - large agg has other probs
- wydajność
- skalowalność


### 1.2 2nd attempt: multiple aggregates

consider another model
- 4 aggrs: Product, BacklogItem, Release, Sprint
- each refs Product by ProductId (identity of Product)

comparing to prev. model
- signature of Product methods will change
- w large jest
  Product { void ScheduleSprint("params desc sprint, w/o any IDs")
- w small jest
  Product { Sprint ScheduleSprint("params identyczne")
- mega zmiana
  - w large jest command
  - w small jest querry 
    - dziala jak factory (tworzy i zwraca agregat)

uzycie w AS
MyAS { 
  public void planProductBacklogItem(
    aTenantID, aProductID 
    aSummary, aCategory, aBacklogItemType, aStoryPoint) 
- all params as primitives / strings!!!
- metoda konwertuje strings w VO
  - ID'kie przez "new TenantId(tenandId)"
  - reszta przez "static methods/factorie" w VO
      BacklogItemType.valueOf(backlogItemType):BacklogItemType
- z repo wyszukujemy agg Product
- i wywolujemy na nim
    product.planBacklogItem("params juz jako VO"):BacklogItem
- zwrocony agg BI dajemy do
    biRepo.Add(bi)
    
c: VV uzywa konwencji prefix'owania method params with 'a'

c: w 'small agg' nie ma problemu konfliktu tx'ow (mozna tworzyc dowolna || ilosc aggs)

c: w modelu 'large' mozna ustawic HBM/optimisticLock=false 
- eliminuje to problem z konfliktami tx (przy dodawaniu new BI ..)
- ale zostaly by inne problemu



## 2 rule: model true invariants in consistency boundaries

- zeby odkryć agregaty w BC musimy odkryć prawdziwe niezmienniki (invariant) modelu - musimy!!!
- niezmienniki wyznaczaja zawartość agregatu

- inwariant = reguła biznesowa która musi być zawsze consistent/utrzymana
- prosta i skuteczna definicja

typy konsystencji
- transactional consistency TC
- eventual consictency EC

inwariant dotyczy tylko TC

przykład
- inwariant c = a + b
class Agg1 { 
  // pola A, B, C
  // operacje 
- cokolwiek się dzieje, niezależnie jakie operacje sawywołane = invariant zawsze musi być spełniony

c: agregat wyznacz TC boundary (obszar zawsze konsystentnych danych)
- zatem E nested in Agg jest konsystentne

- zwykle C zapewnia TX
- wowczas podczas commit wszystko wewn. granic agregatu musi byc C
- czyli w "tmp states" inwariant nie musi byc zachowany (ale musi podczas commit)

- BC modyfikuje tylko 1 agg w tx

- do zaproj. agg trzeba wykonac analize tx!!! co kiedy ma byc C
- duzo zalezy od UI - ile aggs bedzie modyf. przy 1 use case, powinien modyf. 1 agg

- agg wyznaczaja granice consistency (a nie tworza graf obiektow)


## 3 rule: design small aggregates

std problems with large aggs
- tx conflicts
- perfomrance
- scalability

another problem - sample
- assume large agg Product with 1k of BIs, Sprints, Releases ...
- jak chcesz dodac new BI
- to musisz wczytac ALL BIs (mimo ze ich nie potrzebujesz)
- to problem wydajnosci i pamieci
- n: pozostale E (Release, Sprint ..) ustaw jako lazy-loading i nie sa one wczytywane

- large agg tworza nieprawdziwe invariants
- dla "pozornej" wygody tworza mega grafy obiektow

small agg
- only root entity with attrs (possibly as VO)

przyklad "niejawnych invariants"
- w Product attrs name and desc sa zwykle zmieniane razem - stad sa w 1 agg

hint
- przy projektowaniu modelu mysl czy dany koncept
  - czy bedzie sie zmienial w czasie
  - czy mozna go kompletnie wymienic
.. if 2nd - project it as VO

c: if you re-analyse your model - probably you'll see that many many E can be replaced with VO

c: w avg projekcie biznesowym
- 70% aggs ma 1 E (plus props as VO)
- 30% aggs ma 2-3 E
.. acz all zalezy od reqs


### 3.1  don't trust every use case

- typowa specyfikacja opisuje use cases
- trzeba do niej dolaczyc decyzje o tworzeniu agg

- czesto specyfikaca wymaga modyfikacji wielu agg
- nalezy ustalic czy
  - mozna rozbic to na kilka mniejszych tx
  - realnie potrzebna jest 1 big tx

note
- if you try to modify many aggs in 1 tx - to moze ze zle ustaliles invariant (zbyt szeroko)
- moze trzeba polaczyc kilka aggs w nowy agg (z nowymi granicami spojonsci) - zaproj. nowy "koncept"

another option - use eventaul consistency
- but check if delay is acceptable


## 4 rule: reference other aggregates by identity

- jak proj. obiekt to kusi wizja duzego grafu obiektow (compositional structure) z opcja dalekiej nawigacji

wazne
- agg MOZE miec ref do root'a innego agregatu
- ale ref'owany agg NIE lezy w consistency boundary tego agg
- sample
  class BacklogItem : ConcurrencySafeEntity {
    Product product
  }


if in 1 tx you must modify many agg - it's v strong info that there is 
- bad consistency boundary
- some UL notion wasn't discovered yet

- jesli mimo dodatkowych analiz - problem pozostaje - moze trzeba uzyc eventual consistency


### 4.1 making aggregates work together through identity reference

- prefer refing between aggs by their ID
- sample
  class BacklogItem : ConcurrencySafeEntity {
    ProductId product
  }

- refing by ID avoids 'eager loading' refed aggs
- model 
  - is faster (less time take load to mem)
  - consumes less mem

VVVVVVVVVVVV cont here

### 4.2 model navigation

10 4 2  model Navigation

Jak robić Nawigacje mając tylko id?
Podejście 1
Niektórzy używają repozytoria wołane ze środka,  tak ze środka, agregatu  żeby doczekać dane
Nazywa się to 'disconnected domain model'
Jest to forma lazy-loading,  ciekawe

Podejście 2, rekomendowane,
Użyj repository lub dService  do doczytania danych ( w zasadzie chodzić to może tylko o drugi agregat) przed  tym( tak przed)  jak będziesz w te dane potrzebował( potrzebował w tym pierwotnym agregacie)

Przykład
Na agregacie backlog item  chcemy wywołać metodę  jak na stronie 362
Dane do metody Przygotowujemy wcześniej
Wczytujemy agregat Team
Alternatywą byłoby  posiadanie referencji do Team w agregacie  backlog item,
Ale to byłoby problematyczne

To podejście uwalnia agregat od zależności od repozytorium lub DS
Ale w przypadku bardzo skomplikowanych domen można,  warto przekazać  jako parametr metody ref do repo lub DS( tak jako parametr metody,  Ciekawe czemu nie jako pole klasy)
Wówczas agregat robi Double dispatch żeby dociągnąć dane

Pamiętaj że Jakkolwiek nie wyciągasz danych  w jednej transakcji modyfikujesz tylko jeden agregat


Używanie id do robienia refów  utrudnia nawigowanie po stronie ui ( które czytają stan agregatu)
Czasem Wymaga to użycia kilku repozytoriów żeby  pobrać pełne dane dla use Case
Może to powodować problemy wydajnościowe Jeśli tak warto rozważyć theta joins  lub cqrs

Ciekawostka hbm wspiera ww t-joins
Pozwala to odczytać chyba kilka powiązanych agregatów w jednym zapytaniu
T-joint to po prostu hbm zapytania które zwracają 2 różne ale powiązane obiekty, prosta sprawa, 

### 4.3 scalability and distribution

10 4 3  scalability and Distribution

Agregaty ryfują się nawzajem przez identity
Z tego powodu mogą być używany w szerokiej skali
Prawie Infiniti scalability można osiągnąć( Jak podaje gościu z Amazona) 
Nie ma Problemu ze skalowalnośćia  Storage

Na kwestia
Typowy projekt DDD zawiera wiele bc
Ponieważ refy agregatami są  typu id  to możemy refować agregaty z  dalekich bc ( chyba jestem  pewny)
W szczególności jeśli wysyłamy domain Events zawierające id agregatu,  i siejemy to na wiele bc
Naturalnie w takim środowisku transakcje rozproszone są między systemy,  mamy   consistent State eventually

## 5 rule: use eventual consistency outside the boundary

10 5  role use eventual consistency...

ee Mówi  Co musi być zrobione żeby zachować modhel consistency  kiedy wiele agregatów musi być zmienionych przy jednym request
W skrócie,  use eventual consistency

Ta zasada dotyczy się bardzo dużych skale( gdzie bardzo dużo agregatów ma być modyfikowanych' jednocześnie')  oraz małych skale z kilkoma agregatami
Chyba ee ma na myśli nawet Case: batch processing( Kiedy rzeczywiście mnóstwo agregatów jest modyfikowanych)

Uzgodnij z ekspertami domenowymi czy dopuszczalne jest  delay  pomiędzy modyfikacjami instancji

Jak realizować eventual consistency
Przykład na 365
Masz agregat  backlog item
Ma on metodę typu Command  na przykład comitTo
Komenda na koniec wysyła event  który jest asynchronicznie konsumowany subscribers
Each subscriber  execute in a separate transaction, keeping  the rule  of modifying one aggregate in one transaction
Zauważ że metoda Command wysyła event  backlog item komitet
Zauważ że backlog item ma ref do Sprint id,  backlog item nie jesteśmy zainteresowani  niczym więcej,  encja Sprint lub  inne subscriber  po evencie zmodyfikuje stan Sprint( Sprint Doda do siebie informacje o nowym item) 

What if modification  fails  on subscriber side
Modification can be retried  jeśli subskrajber nie potwierdzi sukcesu do mechanizmu messaging
Message will be redelivered  do momentu aż osiągniemy consistency
There Can Be many   prób  dopóki messaging nie otrzyma potwierdzenia
Można ustawić limit prób
Wówczas po failu  może trzeba będzie skompensować transakcje  albo przynajmniej zaraportować problem żeby  user mogły zareagować

Ciekawostka, VV rekomenduje robienie  powtórzeń nieliniowo, znaczy każda następna próba jest robiona Z
 opóźnieniem jednej sekundy dwóch sekund 4, 8 i tak dalej
 

### 5.1 ask whose job it is

10 5 1   ask whose job it is

Czasem trudno określić Czy można  transactional or eventual consistency
Z powodów technicznych niektórzy ( zwykle ci używający cqrs) preferują eventual consistency,
Inni( ci którzy używają klasycznego podejścia no cqrs)   transactional consistency
Ale to bzdura

Według e e Trzeba sprawdzić  czyim zadaniem  jest zapewnienie konsystencji   danych
Jeśli to zadania Użytkownika który wykonuje use-case -  Wykonaj zadanie w transakcji 
Jeśli to zadanie innego użytkownika lub systemu to Wykonaj zadanie w eventual consistency

## 6 reason to break the rules



### 6.1 r1: user interface convinience



### 6.2 r2: lack of technical mechanism



### 6.3 r3: global transacitons



### 6.4 r4: query performance



### 6.5 adhering to the rules



## 7 gaining insight through discovery



### 7.1 rethinking the design, again



### 7.2 estimating aggregate cost



### 7.3 common usage scenarios



### 7.4 memory consumption



### 7.5 exploring another alternative design



### 7.6 implememnting eventual consistency



### 7.7 is it the team member's job?



### 7.8 time to decision



## 8 implementation



### 8.1 create a rool entity with unique identity



### 8.2 favor value object parts



### 8.3 using law of Demeter and tell, don't ask



### 8.4 optimistic concurrency



### 8.5 aboid dependency injection