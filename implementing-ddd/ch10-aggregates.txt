# ch10 aggregates

- tworzenie aggs z encji i vo to jeden z mniej zrozumiałych tematów DDD

- typowy problemy - robienie aggs zbyt
  - duzych (za wiele e-s)
  - malych (to nie chroni invariants)


## 1 using aggregates in the scrum core domain


- samples base on BC APM


### 1.1 1st attempt: large-cluster aggregate


- Product is large agg with e-s:: BacklogItem, Release, Sprint ..
- struktura jest prosta
- ale tworzy duzo problemow
  - many tx will fail (due to conflicts)
// g: p/p w "1 user app" to ok

optimistic concurrency
- class Product extends ConcurencySafeEntity (CSE)
- CSE impls optimistic concurrency
dzialanie OC
- CSE zawiera pole concurrencyVersion (tabela ma kolumne concurrency_version)
- podczas zapisu E - jesli numer wersji w obiekcie jest starszy niz w bazie -> update jest odrzucany
- hbm uzywa elem <version> do cfg OC (i wskazania pola)
sample
- user A i B pracuja na tym samym obiekcie Product,ver=1
- A dodaj BacklogItem i robi commit, teraz P.ver=2
- B dodaje Release i probuje zrobic commit - tx fails bo ma stale ver

c: nadpisywanie zmian w key-value stores
- przy kazdym zapisie agg - zapisywana jest jego CALA zawartosc
- to nadpisuje zmiany innych user'ow nawzajem
- to niedopuszczalne

n: poza fails of tx - large agg has other probs
- wydajność
- skalowalność


### 1.2 2nd attempt: multiple aggregates


consider model
- 4 small aggs: Product, BacklogItem, Release, Sprint
- each refs Product by ProductId (identity of Product)

comparing to "large model"
- signature of Product methods will change
  large agg
    Product { void ScheduleSprint("params desc sprint, w/o any IDs")
  small agg
    Product { Sprint ScheduleSprint("params identyczne")
- mega zmiany
  - w large jest command
  - w small jest querry [factory: tworzy i zwraca agg]

uzycie w AS [small agg ver]
- class MyAppService / public void planProductBacklogItem(
    aTenantID, aProductID 
    aSummary, aCategory, aBacklogItemType, aStoryPoint) 
- all params = primitives / strings
  - g: analog. postac jest w DB
- AS konwertuje primitives/strings do VO
  - ID'kie przez "new TenantId(tenandId)"
  - reszta przez "static methods/factorie" w VO
    BacklogItemType.valueOf(backlogItemType):BacklogItemType
- z repo wyszukujemy agg Product and do call
    product.planBacklogItem("params jako VO"):BacklogItem
- stworzony agg BI dajemy do repo
    biRepo.Add(bi)
    
c: VV prefix'uje params metody przez 'a': aProductID, aBacklogItemType

- w 'small agg' nie ma problemu konfliktow tx-es
- mozna rownolegle tworzyc dowolna ilosc aggs

- w modelu 'large' mozna ustawic HBM/optimisticLock=false 
- eliminuje to problem z konfliktami tx (przy wersjonowaniu)
- ale zostaja inne problems


## 2 rule: model true invariants in consistency boundaries


- zeby odkryć agregaty (w BC) musimy odkryć true invariants modelu - musimy!!!
- niezmienniki wyznaczaja zawartość/granice agg

- inwariant = reguła biznesowa która musi być zawsze consistent
- prosta i skuteczna definicja

typy konsystencji
- transactional consistency TC
- eventual consistency EC

- inwariant dotyczy tylko TC

przykład
- class Agg1 { 
  // pola a, b, c
  // operacje 
  }
- inwariant c = a + b
- cokolwiek się dzieje, niezależnie jakie operacje sa wywołane = invariant zawsze jest spełniony

- agregat wyznacza TC boundary (obszar zawsze konsystentnych danych)

- consistency zwykle zapewnia TX
- podczas commit wszystko wewn. granic agregatu musi byc consistent
- czyli w "temporary state" inwariant nie musi byc zachowany
  - ale raczej powinien

- BC modyfikuje tylko 1 agg w 1 tx

- do zaproj. agg trzeba wykonac analize tx-es - co kiedy ma byc consistent

duzo zalezy od UI
- ile aggs modyf. przy 1 use case
- powinien modyfikowac 1 agg

- agg wyznaczaja granice consistency
- a nie tworza graf obiektow "do nawigacji"!!!


## 3 rule: design small aggregates


std problems of large aggs
- tx conflicts
- performance
- scalability

sample perfoarmance problem [1 of many]
- assume >large< agg Product with 1k of BIs, Sprints, Releases ...
- chcesz dodac new BI
- musisz wczytac ALL BIs (mimo ze ich nie potrzebujesz)
- to problem wydajnosci i pamieci
- n: pozostale E (Release, Sprint ..) sa lazy-loading [nie beda wczytywane]

another probs of >large agg<
- maja zle invariants
- dla "pozornej" wygody nawigacji - tworza duze grafy obiektow

niejawne invariants
- w Product attrs name and desc sa zwykle zmieniane razem - stad sa w 1 agg

hint
- przy modelowaniu mysl czy dany element
  - bedzie sie zmienial w czasie
  - mozna go kompletnie wymienic
.. if 2nd - project it as VO

- if you'd re-analyse your model 
- probably you'll find many Es which can be replaced with VO

c: w "avg" projekcie biznesowym
- 70% aggs ma 1 E (plus props as VO)
- 30% aggs ma 2-3 E
.. acz to zalezy od reqs


### 3.1  don't trust every use case


- typowa specyfikacja opisuje tylko use cases
- trzeba dodac decyzje o tworzeniu aggs

- czesto specyfikacja wymaga modyfikacji wielu agg w 1 req
- nalezy ustalic czy
  - mozna rozbic 1 tx na kilka mniejszych
  - realnie potrzeba 1 big tx

n
- if you modify many aggs in 1 tx - to moze ze zle ustaliles invariant
  - moze trzeba przemodelowac kilka aggs w nowy "koncept" (z nowymi granicami)
- or use eventual consistency
  - but check if delay is acceptable


## 4 rule: reference other aggregates by identity


- kuszaca jest wizja grafu obiektow z opcja deep navigation

wazne
- agg MOZE miec ref do root'a innego agregatu
- ale ref'owany agg NIE lezy w consistency boundary tego agg
- sample
  class BacklogItem : ConcurrencySafeEntity {
    Product product
  }


if in 1 tx you modify many aggs - it's strong info that there is 
- bad consistency boundary
- some UL notion wasn't discovered yet

- jesli mimo dodatkowych analiz - problem pozostaje - moze trzeba uzyc eventual consistency


### 4.1 making aggregates work together through identity reference


- prefer refing between aggs by ID
- sample
  class BacklogItem : ConcurrencySafeEntity {
    ProductId product
  }
- refing by ID avoids 'eager loading'
- and model
  - is faster (less time take load to mem)
  - consumes less mem


### 4.2 model navigation


how to navigate with ID
- way 1 - "disconnected domain model"
  - call repos from inside of agg - to fetch needed agg data
  - form of lazy-loading
- way 2 - recommended
  - use repo or DS to load 2nd agg data
  - pass this agg data to 1st agg on calling its methods

sample: call of agg method BacklogItem.assignTeamMemberToTask(TeamMemberId, Team, TaskId)
- create method MyAppService.assignTeamMemberToTask(..) which
  - prepare params needed by agg's method
  - read agg Team from repo
  - call BI agg with fetched Team agg
    - nie wnikam - ale pp BI potrzebuje calego Team zeby cos wyliczyc?

- way 1 is ok for complex domains
  - pass to called method ref to repo/DS 
    // q: why not make repo field of class?
  - agg robi double dispatch to dwl needed data
- way 2 frees agg from deping on repo/DS

- but in each way - modify 1 agg in 1 tx

c: ui and navigations
- using IDs for refing between aggs make navigation hard
- but navigation is useful in UI
- in such case
  - either: read data req on UI from few repos [but it's slow]
  - or: use "HBM theta joins" or CQRS

c: hbm and theta joins
- it allows to read a few diff aggs in 1 hbm query
- hbm then returns related (but diff type) objects


### 4.3 scalability and distribution


- aggs ref themselves by ID
- amazon guy says: "almost infinity scalability can be achieved"

other plus
- in app there are many BCs
- as refs are done by ID then you easy ref aggs from other BCs
- useful if you
  - modify agg and send DEvent
  - DEvent has IDs of parties involved in this change
- naturally
  - txes are divided between BCs
  - eventual consistency is used


## 5 rule: use eventual consistency (EC) outside the boundary


wg EE 
- to keep consistency and modify many aggs in 1 request - use eventual consistency
- this rule regards all 'modify aggs cases', eg:
  - few aggs modified "in 1 req"
  - many aggs modified in batch processing

- you must agree with domain experts that delayed txes / changes are ok

EC sample
- agg has command BacklogItem.commitTo(Sprint s)
- method at the end sends event BacklogItemCommited
  - n: send is sync, but consumption on subsciber side is async
- subers
  - run in separated TX (to keep rule: modify 1 agg in 1 tx)
  - one of subers - react on a/m -> adds info about new BI to agg: Sprint

what if modification fails on suber side
- modification can be retried
  - if suber doesn't ack that modification is done [or failed] -> event is redelivered
    // q: how queue gets info that event handled/failed?
- try many times until 'event is handled' [and consistency achieved]
- there should be limit of retries - after it app should
  - either compensate tx
  - or at least report problem to user/admin - to react - cause state in inconsistent!!!
    
c: do non-linear retires
- each next delivery do with longer and longer delay
- start with delay 1s, then 2s, then 4s - until limit
 

### 5.1 ask whose job it is


- sometimes it's hard to guess which consistency to apply (tx \/ eventual)
- wg EE - assess whose responsibility is to assure consistency
  - if user (who calls particular use-case) - do task in 1 tx
  - if another user or system - do task in EC


## 6 reason to break the rules


- czasem można zapisać kilka aggs w 1 tx
- ponizsze 4 powody nie sa jedyne ;]


### 6.1 r1: user interface convinience


- user na 1 ekranie tworzy kilka nowych aggs np. BacklogItems
- taki UC obsługujemy w 1 metodzie  
- np. AS.planBatchOfBacklogItems[productId, tenantId, BItemDesc[] newItems]
- AS.plan... tworzy klika instancji agg: BItems i dodaje je kolejno do BItemRepo, >w 1 tx<

- nie ma problemu z niezachowaniem invariants - bo tworzymy nowe BItems

- n: zachowanie inwariants jest kryterium czy mozna zlamac "agg-rule"


### 6.2 r2: lack of technical mechanism


- using eventual consistency reqs some infra (messaging, timers, background threads ..)
- some projs don't have it - sad but true

way1
- as we can't use EC -> proj p/b will end with large aggs
- this will decrese performance/scalaebility
way2
- strive to create small aggs 
- if reqs can't be changed --> no choice: you can modify many aggs in 1 tx


### 6.3 r3: global transacitons


- if you use global, 2-phase TX-es - then it looks ok to modify many aggs in 1 tx
  - although it DOESN'T force us to do so
- if possible - avoid even here modifying many aggs in 1 tx


### 6.4 r4: query performance


- sometimes you must have "live" ref from agg1 to agg2
  - due to ease doing fetching data ...
- you can do it but remember about "performance" [etc.] problems


### 6.5 adhering to the rules


- there can be many reasons to break rules
- in long term
  - keeping rules - ease project
  - breaking - make it hard


## 7 gaining insight through discovery


// apply agg rules and check influence on model


### 7.1 rethinking the design, again


current state
- domain is divided on small elements
- aggs ref each other by id

sample
- if sum of hours in Tasks in BacklogItem == 0 -> auto set BI as done
- it's invariant and BI and Tasks are kept in 1 agg (BI)


### 7.2 estimating aggregate cost


technika BOTE [back of the envelope]
- estymuje ilosci obiektow bioracych udzial w danym UC/...
- przyklad
  - zgrubienie określ czas trwania Sprint, ilość Tasks in Sprint ... 
  - zgrubnie policz ilosc obiektów BItem, Task ...
  - wyszlo: np. 144 obiekty na zaladowanie 1 BI w typowym use case


### 7.3 common usage scenarios


problem z optimistic concurrency
- umozliw 2+ userom dodawanie nowych task, bez wzajemnej blokady BI [sam Task niech blokuja]
- nie moze byc ze dodanie Task do BI zwieksza wersje OC na BI
- trzeba wyłączyć hbm optimistic lock [p/p na BI]
- default OC = version, ustaw OC = false
  - OC=version sie nie sprawdzi
  - modyfikujemy wiele diff tasks by wielu users

- ustawienie mech. OC zalezy od konkretnego UC 
- ustawiamy na bazie heurystyki ["przypuszczenia" jakie ustawienie bedzie dzialac w danym zestawie UCes]
- zakladamy jak userzy beda sie zachowywac - co wcale nie musi sie sprawdzic i w realu strategia moze byc zla
- acz zawsze niedopuszczalne jest nadpisywanie danych by users ;]


### 7.4 memory consumption


// just count objects created during UC

sample of "double lazy load"
- Tasks from BacklogItem are lazy-loaded
- lazy-loaded are also EstimationLogEntry (part of Task)

- wg VV podczas UC ladowanych jest 25 obiektow - "to nieduzo"

although 'double lazy ..' but wg VV
- optimizing it - should be done after tests/analyses - is it real problem
- not "now", hmm .. strange


### 7.5 exploring another alternative design


// ch tests alter approaches to agg boundaries

idea: wydzielic Task jako osobny agg (poza agg BI)
- pros
  - save memory (less objects are loaded)
  - eliminate lazy loading
- cons: delay in setting BI status to done (due to EC)
- but if business accept it -> idea is accepted
- naturalnie invariant 'auto-set BI to done' znika


### 7.6 implememnting eventual consistency


// q: jak robione jest message redelivery (after failure)

example - use EC to set BI 'done'
- agg has command Task.estimatedHoursRemaining()
- on end it sends event EventTaskHoursRemainingEstimated
- event has attrs BacklogItemID, TaskID, hoursRemaining, ...
- suber of a/m event - calls DS which
  - get BI, Task z repo (by IDs from event)
  - calls BI.estimateTaskHoursRemaining(event.hoursRemaining, task)
    - this sets BI state to done if no more hours remain

optimalization
- instead of reading all Tasks for BI (to calc remaining hours)
- rather create specialized method in repo
  - TotalBacklogItemTaskHoursRemaining(tenantId, biId)
  - which on DB level calcs remaining hours of BI (w/o loading objs to mem)

waiting for EC and refresh UI
- app quickly update Task but BI with delay (due to EC)
- problem: what to show on UI: task is modified but BI not yet
- maybe message: "BI state is being calculated, refresh soon"
- gt: slabe, lepiej owrapowac calosc w await


### 7.7 is it the team member's job?


// nothing special


### 7.8 time to decision


// nothing special


## 8 implementation


// nothing special


### 8.1 create a rool entity with unique identity


// nothing special

- class Product extends ConcurrencySafeEntity
- CSE (layer SuperType) gives 
  - surrogate identity
  - optimistic concurrency versioning

- class Product has property Set<ProductBacklogItem>
- don't mistake it with BacklogItem
- it's represents sorting of BIs

- Product ma id: domenowe i surrogate
- w konstruktorze Product jest tylko id domenowe
- surrogate jest pp ustawione przez db


### 8.2 favor value object parts


- parts of agg try to model as VO

- Product ma ref do Tenant przez TenantId
- Product i Tenant sa z diff BC
- wiec musza być ref'owane przez Id
- aggs z innych BC refuj tylko przez Id
- acz wewnatrz BC tez refujemy przez Id

integrate BCs
- Product ma ref do ProductDiscussion [VO]
- VO ProductDiscussion represents agg Discussion from another BC
- PD jest eventually consistent względem zmian w Discussion BC
- update'y sa propagowane do obiektu Product [do attr PD]
  - za pomoca eventu
  - w "delayed" tx

- ProductBacklogItem is an E [could be VO]
- as VO there'd be performance problem
  - in case of sorting change
  - trzeba by wywalic old collection of VOs i wstawic nowa collection
- as we use E - we set only attr 'ordering' [and quickly change sorting]

- w w/w case: tech wplynal na model domenowy
- acz pp niewiele - bo z client PoV nie widzimy duzej diff miedzy vo/e
  - w e ustawiamy attr "sorting"
  - w vo byla by zamiana calej kolekcji [?]
- if we'd use key-value store then we'd use VO [not E]
- anyway 
  - seems techs highly influence impl details of model
  - but semantic of model stays the same [?]


### 8.3 using law of Demeter and tell, don't ask


design principles:
- law of demeter
- tell, don't ask

both promo hiding infos


LOD
- promotes using 'least needed knowledge'
- sample: client (C), server (S)
- when C calls S - C should
  - only know how to call command/querry on S
  - NOT know S internals [properties ...]
- esp: C should not call internal parts of S
- if such call is needed then
  - S exposes method which delegates to internal part
  - and C calls exposed method
- recap: metoda obiektu moze wolac inne metody
  - nalezace do tego obiektu
  - parametrow przekazanych tej metodzie
  - obiektu ktory stworzyla
  - of self-contained parts [obiektow zagregowane [w sensie UML] w "this"]


TDA
- mowimy obiektowi co ma zrobic
przyklad
- bad: C pyta S o dane, decyduje co robic, kaze S to robic
- good: C "mowi" S co ma zrobic [C wola command on S]

SAMPLES
- client calls
    void Product.reorderFrom(BacklogItemId anId, int anOrdering) { ... }
- it's command
- client has "least knowledge" to perfom call
  - params are "primitive", 100% needed [no polution]
  - internals of Product are not know to client
  
- client calls
    Set<ProductBI> Product.backlogItems() { ... }
- it's querry
- n: it's return ProductBI [VO] not BI [E]
  - PBI is small [least knowledge]
  - it doesn't publish "internals" of P

- caly kod w klasie should minimize keeping knowlegde [use minimun to perform task]

- TDA/LOD są podobne
- TDA prosciej stosowac

- LOD zakazuje klientowmi nawigowac po grafie obiektow (eg. agg)
- TDA
  - pozwala na nawigacje [nie zakazuje jej ;]
  - wymusza modyfikacje stanu agg przez commands

- czasem proj agg moze stosowac tylko TDA [bez LOD]


vvvv cont. here


### 8.4 optimistic concurrency


- gdzie ustawic attr. version OC?
- assume set it only on root entity of agg
  - and increas it on ANY change agg boundries [even in sub-E]
- ale to "srednie": brudzi kod logiki [technikalmiali], jest czesto niepotrzebne ...
// q: to jak chronimy invariants - gdy sub-E maja own versions

- z: uzywamy hbm
- kiedy w agg Product zmieniamy name/desc/.. -> podbijamy version of root
- it's ok/easy
- ale prob: jak zmieniac ver kiedy zmienia sie order of BacklogItems
  - bo modyf. ProductBacklogItem nie jest widziana przez HBM jako zmiana Product [przez mech. version'owania]
- teor. mozna to obejsc przez sztuczne podbijanie agg/Product przy zmianie PBI
Product.reorderFrom(..) {
  // read ProductBacklogItem
  // modify PBI
  version(version() + 1) // sztucznie podbij Product.version
}
- probs with w/w
  - Product.version zmienia sie takze jesli call to reorderFrom(..) nie zmienia kolejnosci
  - wyciek infra do modelu
  
fix
- przy modyf PBI nie musimy podbijac P.version
- PBI moga miec own OC
- OC bedzie chronic modyf. single PBI przez wielu users

c
- PBI sluzy tylko i wylacznie do sortowanie BIs wewn. Product
- jest sub-E, ma ref do TenantId, ProductId ... -> hence
- hance VIN
  - sub-E moga refowac do innych E/aggs - ale tylko przez ID [p/p]
  - a zakaz jest refowania z sub-E do innych aggs po 'ref' [p/p]

- versioning all E parts doesn't work in every case
- sometimes [to protect invariants] we must modify root version
  
alter way
- use hooks provided by hbm
- cfg root version-ing as dirty and manually handle OC
- ale trzeba uzyc bidirectional relation - co EE bardzo odradza
  - mozna uzyc w rzadkich cases
  - ale nie dla mech. potrzeb OptimisticConcurreny
    
alter way
- podziel agg na mniejsze i uzywaj std OC
- niezalecane - bo domene ksztaltuje infra
- ale moze byc uzasadnione wielkoscia, wydajnoscia root'a

- wg VV problemu nie ma w techs gdzie agg zapisujemy jako calosc [mongo, riak ..]
- gt: ale pewnie sa problemy z brakiem OC ;]


### 8.5 avoid dependency injection

- injecting repos or DS to aggs - is bad
- bo aggs moga przez to robic look-up'y/dociagaja inne aggs
- reced way: find all aggs before calling command on agg (which needs these pre-loaded aggs)
- 'disconnected domain model' is not reced

- racze wstrzykuj Repos, DS do AS etc.