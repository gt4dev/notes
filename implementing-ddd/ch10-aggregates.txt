# ch10 aggregates

- tworzenie aggs z encji i vo to jeden z mniej zrozumiałych tematów DDD

- typowy problemy - robienie aggs zbyt
  - duzych agg (i zagniezdzanie full entities)
  - malych - bo to nie chroni invariants


## 1 using aggregates in the scrum core domain

- samples base on BC APM


### 1.1 1st attempt: large-cluster aggregate

- assume Product is very large agg
- contains objects: BacklogItem, Release, Sprint ..
- struktura jest prosta
- ale tworzy duzo problems
  - many tx will fail (due to conflicts)
// q: czyli w "1 user app" to ok podejcie?

optimistic concurrency
- class Product extends ConcurencySafeEntity (CSE)
- CSE impls optimistic concurrency
dzialanie OC
- CSE zawiera pole concurrencyVersion (tabel ma kolumne concurrency_version)
- podczas zapisu E - jesli numer wersji w obiekcie jest starszy niz juz w bazie -> update jest odrzucany
- hbm uzywa elem <version> do cfg OC i wskazania pola
sample
- user A i B pracuja na tym samym obiekcie Product,ver=1
- A dodaj BacklogItem i robi commit, teraz ver=2
- B dodaje Release i probuje zrobic commit - tx fails bo ma stara ver

c: nadpisywanie zmian w key-value stores
- przy kazdym zapisie agg - zapisywana jest jego CALA zawartosc
- to nadpisuje zmiany innych user'ow nawzajem
- to niedopuszczalne

n: poza fails of tx - large agg has other probs
- wydajność
- skalowalność


### 1.2 2nd attempt: multiple aggregates

consider another model
- 4 aggs: Product, BacklogItem, Release, Sprint
- each refs Product by ProductId (identity of Product)

comparing to prev. model
- signature of Product methods will change
  large agg
    Product { void ScheduleSprint("params desc sprint, w/o any IDs")
  small agg
    Product { Sprint ScheduleSprint("params identyczne")
- mega zmiana
  - w large jest command
  - w small jest querry
    - dziala jak factory (tworzy i zwraca agg)

uzycie w AS [small agg ver]
  MyAS : public void planProductBacklogItem(
    aTenantID, aProductID 
    aSummary, aCategory, aBacklogItemType, aStoryPoint) 
- all params as primitives / strings
  - g: i taka postac maja tez czesto w DB
- AS konwertuje primitives/strings w VO
  - ID'kie przez "new TenantId(tenandId)"
  - reszta przez "static methods/factorie" w VO
    BacklogItemType.valueOf(backlogItemType):BacklogItemType
- z repo wyszukujemy agg Product and call
    product.planBacklogItem("params juz jako VO"):BacklogItem
- zwrocony agg BI dajemy do
    biRepo.Add(bi)
    
c: VV prefix'uje params metody przez 'a': aProductID, aBacklogItemType

c: w 'small agg ver' nie ma problemu tx-konfliktow
- mozna rownolegle tworzyc dowolna ilosc aggs

c: w modelu 'large' mozna ustawic HBM/optimisticLock=false 
- eliminuje to problem z konfliktami tx (przy wersjonowaniu)
- ale zostaja inne problems


## 2 rule: model true invariants in consistency boundaries

- zeby odkryć agregaty (w BC) musimy odkryć true invariants modelu - musimy!!!
- niezmienniki wyznaczaja zawartość/granice agg

- inwariant = reguła biznesowa która musi być zawsze consistent
- prosta i skuteczna definicja

typy konsystencji
- transactional consistency TC
- eventual consictency EC

- inwariant dotyczy tylko TC

przykład
- class Agg1 { 
  // pola A, B, C
  // operacje 
  }
- inwariant c = a + b
- cokolwiek się dzieje, niezależnie jakie operacje sa wywołane = invariant zawsze musi być spełniony

- agregat wyznacz TC boundary (obszar zawsze konsystentnych danych)
- n: E nested in agg jest konsystentne z calym agg

- C zwykle zapewnia TX
- wowczas podczas commit wszystko wewn. granic agregatu musi byc C
- n: czyli w "tmp states" inwariant nie musi byc zachowany (musi podczas commit)

- BC modyfikuje tylko 1 agg w tx

- n: do zaproj. agg trzeba wykonac analize tx - co kiedy ma byc C!!!
- duzo zalezy od UI
  - ile aggs bedzie modyf. przy 1 use case
  - powinien modyfikowac 1 agg

n
- agg wyznaczaja granice consistency
- a nie tworza graf obiektow "do nawigacji"!!!


## 3 rule: design small aggregates

std problems with large aggs
- tx conflicts
- performance
- scalability

sample perf. problem [1 of]
- assume >large< agg Product with 1k of BIs, Sprints, Releases ...
- chcesz dodac new BI
- musisz wczytac ALL BIs (mimo ze ich nie potrzebujesz)
- to problem wydajnosci i pamieci
- c: pozostale E (Release, Sprint ..) ustaw jako lazy-loading [nie beda wczytywane]

another probs of >large agg<
- tworza nieprawdziwe invariants
- dla "pozornej" wygody nawigacji - tworza mega grafy obiektow

- small agg = root entity with attrs (possibly as VO), czasem dodatkowe sub-E

c: "niejawne invariants"
- w Product attrs name and desc sa zwykle zmieniane razem - stad sa w 1 agg

hint
- przy modelowaniu mysl czy dany koncept
  - czy bedzie sie zmienial w czasie
  - czy mozna go kompletnie wymienic
.. if 2nd - project it as VO

c: if you'd re-analyse your model - probably you'll find many Es which can be replaced with VO

c: w avg projekcie biznesowym
- 70% aggs ma 1 E (plus props as VO)
- 30% aggs ma 2-3 E
.. acz all zalezy od reqs


### 3.1  don't trust every use case

- typowa specyfikacja opisuje use cases
- trzeba do niej dolaczyc decyzje o tworzeniu agg

- czesto specyfikacja wymaga modyfikacji wielu agg/request
- nalezy ustalic czy
  - mozna rozbic 1 tx na kilka mniejszych
  - realnie potrzeba 1 big tx

n
- if you modify many aggs in 1 tx - to moze ze zle ustaliles invariant
- moze trzeba polaczyc kilka aggs w 1 nowy -> zaproj. nowy "koncept" w modelu (z nowymi granicami)
- or use eventual consistency
  - but check if delay is acceptable


## 4 rule: reference other aggregates by identity

- kuszaca jest wizja duzego grafu obiektow (compositional structure) z opcja dalekiej nawigacji

wazne
- agg MOZE miec ref do root'a innego agregatu
- ale ref'owany agg NIE lezy w consistency boundary tego agg
- sample
  class BacklogItem : ConcurrencySafeEntity {
    Product product
  }


if in 1 tx you must modify many agg - it's strong info that there is 
- bad consistency boundary
- some UL notion wasn't discovered yet

- jesli mimo dodatkowych analiz - problem pozostaje - moze trzeba uzyc eventual consistency


### 4.1 making aggregates work together through identity reference

- prefer refing between aggs by IDs
- sample
  class BacklogItem : ConcurrencySafeEntity {
    ProductId product
  }
- refing by ID avoids 'eager loading'
- plus model
  - is faster (less time take load to mem)
  - consumes less mem


### 4.2 model navigation

how to navigate with only ID
- way 1 - "disconnected domain model"
  - call repos from inside of agg - to fetch needed data
  - form of lazy-loading
- way 2 (reced)
  - use repo or DS to load 2nd agg data
  - pass this data to 1st agg when you call its methods

sample
- let's call agg BacklogItem.assignTeamMemberToTask(TeamMemberId, Team, TaskId)
- create assignTeamMemberToTask in AS!!!
- in AS method
  - prepare params needed by agg's method
  - read agg Team from repo
  - do call with a/m objects

- way 2 frees agg from deping on repo/DS
- way 1 is ok for complex domains
  - pass to called method ref to repo/DS 
    // q: why not make repo field of class?
  - agg robi double dispatch to dwl needed data

- but in each way - modify 1 agg in 1 tx

c: ui and navigations
- using IDs for refing between aggs make navigation hard 
- but it's useful in UI
- in such case 
  - either: read data req on UI from few repos [but it's slow]
  - or: use "HBM theta joins" or CQRS

c: hbm and theta joins
- it allows to read a few diff aggs in 1 hbm (not sql) query
- hbm then returns related (but diff type) objects


### 4.3 scalability and distribution

- aggs ref themselves by ID
- amazon guy says: "almost infinity scalability can be achieved"

other plus
- in app there are many BCs
- as refs are done by ID then you easy ref aggs from other BCs
- useful if you
  - modify agg and send DEvent
  - DEvent has IDs of parties/agg involved in this change
- naturally: 
  - txes are divided between BCs
  - eventual consistency is used


## 5 rule: use eventual consistency (EC) outside the boundary

wg EE 
- to keep consistency and modify many aggs in 1 request - use eventual consistency
- this rule regards all cases, eg:
  - few aggs modified "in 1 req"
  - many aggs (during batch processing)

- you must agree with domain experts that delay between modifying objects is ok

EC sample
- agg has method/command BacklogItem.commitTo(Sprint s)
- method at the end sends event BacklogItemCommited
  - n: send is sync, but consumption on subsciber side is async
- subers
  - run in separated TX (to keep rule: modify 1 agg in 1 tx)
  - one of subers - react on a/m -> adds info about new BI to agg: Sprint

what if modification fails on suber side
- modification can be retried
  - if suber doesn't ack that modification is done [or fail] -> event is redelivered
    // q: how queue gets info that event handled/failed?
- try many times until 'event is handled' [and consistency achieved]
- there should be limit of retries - after it app should
  - either compensate tx
  - or at least report problem to user/admin - to react - cause state in inconsistent!!!
    
c: do non-linear retires
- next delivery tries do with longer and longer delay
- start with delay 1s, then 2s, then 4s - until limit
 

### 5.1 ask whose job it is

- sometimes it's hard to guess which consistency to apply (tx / eventual)
- wg EE - assess whose responsibility is to assure consistency
  - if user (who calls particular use-case) - do task in 1 tx
  - if another user or system - do task in EC


## 6 reason to break the rules

- czasem można zapisać w kilka aggs w 1 tx
- ponizej 4 powody nie sa jedyne


### 6.1 r1: user interface convinience

- user na 1 ekranie tworzy kilka nowych aggs np. BacklogItems
- taki UC obsługujemy w 1 metodzie  
- np. AS.planBatchOfBacklogItems[productId, tenantId, BItemDesc[] newItems]
- AS.plan... tworzy klika instancji agg: BItems i dodaje je kolejno do BItemRepo, >w 1 tx<

- nie ma tu problems z niezachowaniem invariants - bo tworzymy nowy BItems

- n: p/p zachowanie inwariants jest kryterium czy mozna zlamac dana agg-rule


### 6.2 r2: lack of technical mechanism

- using eventual consistency reqs some infra (messaging, timers, background threads ..)
- some projs don't have it - sad but true

way1
- as we can't use EC -> proj p/b will end with large aggregates
- this will decrese performance/scalaebility
way2
- strive to create small aggs 
- if reqs can't be changed --> no choice: you can modify many aggs in 1 tx


### 6.3 r3: global transacitons

- if you must use global, 2-phase TX-es - then it looks ok to modify many aggs in 1 tx
- but it DOESN'T directly force us to so
- if possible - avoid even here modifying many aggs in 1 tx


### 6.4 r4: query performance

- sometimes you must have "live" ref from agg1 to agg2
  - due to ease doing fetching data ...
- you can do it but remember about "perfomrance etc." problems


### 6.5 adhering to the rules

- there can be many reasons to break rules
- in long term 
  - keeping rules ease project, 
  - breaking -> make it hard
- if you keep rules you will have
  - consistency where it's needed
  - performance
  - scaleability


## 7 gaining insight through discovery

// apply agg rules and check influence on model


### 7.1 rethinking the design, again

current state
- domain is divided on small elements
- aggs ref each other by id

sample
- if sum of hours in Tasks in BacklogItem == 0 -> auto set BI as done
- it's invariant and BI and Tasks are kept in 1 agg (BI)


### 7.2 estimating aggregate cost

technika BOTE [back of the envelope]
- estymuje ilosci obiektow bioracych udzial w danym UC/...
- przyklad
  - zgrubienie określ czas trwania Sprint, ilość Tasks in Sprint ... 
  - zgrubnie policz ilosc obiektów BItem, Task ...
  - wyszlo: np. 144 obiekty na zaladowanie 1 BI


### 7.3 common usage scenarios

problem z optimistic concurrency
- musi być możliwość że dwóch użytkowników users dodaje nowe taski i nie blokują nawzajem BI [bo Task to ok, niech blokuja]
- nie moze byc ze dodanie Task do BI zwieksza wersje OC BI
- trzeba wyłączyć hbm optimistic lock
- default OC = version, ustaw OC = false
  - OC=version sie nie sprawdzi
  - modyikujemy wiele tasks by many users
- ustawione na BI [p/p]

c: 
- dopuszczala jest taka LL zmiana mimo ze ustawiamy cechy "domain model"
- widac ze ustawienie OC zalezy od konkretnego UC 
  - stanowi heurystyke ["przypuszczenia" co sie bedzie sprawdzac]
  - zakladamy jak userzy beda sie zachowywac - a to wcale nie musi byc true [i w rezultacie moze byc many 'failed tx']
- acz niedopuszczalne jest nadpisywanie danych by users


### 7.4 memory consumption

// just count objects created in UC

c: double lazy load ;]
- Tasks from BacklogItem are lazy-loaded
- lazy-loaded are also EstimationLogEntry (part of Task)
- wg VV podczas UC ladowanych jest 25 obiektow - "to nieduzo"

[not sure]
- during single req is done 'double lazy-loading' (Tasks, then Esitmates)
- but wg VV
  - optimizing it - should be done after tests/analyses - is it real problem
  - don't optimize it "now"


### 7.5 exploring another alternative design

// ch tests alter approaches to agg boundaries

idea: wydzielic Task jako osobny agg (poza agg BI)
- pros
  - save memory (less objects are loaded)
  - eliminate lazy loading
- cons: delay in setting BI status to done (due to EC)
- but business accept it -> idea is accepted


### 7.6 implememnting eventual consistency

// q: jak robione jest message redelivery (after failure)

example - use EC to set BI 'done'
- agg has method-command Task.estimatedHoursRemaining()
- a/m method on end sends event EventTaskHoursRemainingEstimated
- event has attrs BacklogItemID, TaskID, hoursRemaining, ...
- suber of a/m event - calls DS which
  - get BI, Task z repo (by IDs from event)
  - calls BI.estimateTaskHoursRemaining(event.hoursRemaining, task)
    - this sets BI state to done if no more hours remain

optimalization
- instead of reading all Tasks for BI (to calc remaining hours)
- rather create specialized method in repo
    TotalBacklogItemTaskHoursRemaining(tenantId, biId)
- which on DB level calcs remaining hours of BI (w/o reading all Tasks to mem)

waiting for EC and refresh UI
- app quickly update Task but BI with delay (due to EC)
- then problem: what to show on UI: task is modified but BI not yet
- maybe show message (or sth like this): "BI state is being calculated, refresh soon"
- gt: a/m jest slabe, moze lepiej owrapowac calosc w await?


### 7.7 is it the team member's job?

b. need can change
- setting BI to done can be done automatically [in tx or EC]
- but this feat can be off [eg. another user manually ack change to done]
- in such case
  - create setting in app
  - if auto-close = true -> no T/EC is needed [bot for 'true' -> pb use EC]


### 7.8 time to decision

// nothing special


## 8 implementation

// nothing special


### 8.1 create a rool entity with unique identity

// nothing special

- class Product extends ConcurrencySafeEntity
- CSE (layer SuperType) gives 
  - surrogate identity
  - optimistic concurrency versioning

c
- class Product has property Set<ProductBacklogItem>
- don't mistake it with BacklogItem
- it's used for sorting of BI

C
- Product ma id: domenowe i surrogate
- w konstruktorze Product jest tylko id domenowe
- surrogate jest pp ustawione przez db


### 8.2 favor value object parts

- parts of agg try to model as VO [not E]

C
- Product ma ref do Tenant przez TenantId
- Product i Tenant sa z diff BC
- wiec musza być ref'owane przez Id
  - VI: aggs z innych BC refuj przez Id
- acz wewn. BC tez refujemy przez Id

C: intergrate BCs
- Product ma ref do ProductDiscussion [VO]
- VO ProductDiscussion represents agg Discussion from another BC
- PD jest eventually consistent względem zmian w Discussion
- zmiany sa propagowane do obiektu Product [do attr PD]
  - za pomoca eventu
  - w "delayed" tx

C
- ProductBacklogItem is an E [could be VO]
- as VO there'd be performance problem
  - in case of sorting change
  - trzeba by wywalic old collection of VOs i wstawic nowa collection
- as we use E - we set only attr 'ordering' [and quickly change sorting]

- w w/w - tech wplynal na model domenowy
- acz pp niewiele - bo z client PoV nie widzimy diff miedzy vo/e

C
- use of key-value store lets use VO [instead of E]
  - but will client see diff? pp
- anyway - seems techs highly influence details of model
  - but is it publicly visible in domain [these tech details]?


### 8.3 using law of Demeter and tell, don't ask

design principles:
- law of demeter
- tell, don't ask

both promo hiding infos


LOD
- promotes using 'least needed knowledge'
- sample: objects = client (C), server (S)
- when C calls S - C should
  - only know how to call command/querry on S
  - NOT know S internals [properties ...]
- esp: C should not call internal parts of S
- if such call is needed then
  - S exposes method [which delegates to internal part]
  - and C calls a/m method
- recap: metoda obiektu moze wolac inne metody
  - nalezace do tego obiektu
  - parametrow przekazanych tej metodzie
  - obiektu ktory stworzyla
  - of self-contained parts [obiektow zagregowane [w sensie UML] w "this"]


TDA
- mowimy obiektowi co ma zrobic
przyklad
- bad: C pyta S o dane, decyduje co robic, kaze S to robic
- good: C "mowi" S co ma zrobic [C wola command on S]


- TDA/LOD są podobne
- acz TDA prosciej szeroko stosowac


SAMPLES
- client calls
    void Product.reorderFrom(BacklogItemId anId, int anOrdering) { ... }
- it's command
- client has "least knowledge" to perfom call
  - params are "primitive", 100% needed [no polution]
  - internals of Product are not know to client
  
- client calls
    Set<ProductBI> Product.backlogItems() { ... }
- it's querry
- n: it's return ProductBI [VO] not BI [E]
  - PBI is small [least knowledge]
  - it doesn't publish "internals" of P


- caly kod w klasie should minimize knowlegde [use minimun to perform task]

- LOD jest bardziej wymagające niz TDA
- LOD zakazuje klientowmi nawigowac po grafie obiektow (eg. agg)
- TDA
  - pozwala na nawigacje [nie zakazuje jej ;]
  - wymusza modyfikacje stanu agg przez commands

C
- czasem proj agg moze stosowac tylko TDA [bez LOD]
- jest to ok


### 8.4 optimistic concurrency

- gdzie ustawic attr. version OC?
- assume set it only on root entity of agg
  - and increas it on ANY change agg boundries [even in sub-E]
- ale to "srednie": brudzi kod logiki [technikalmiali], jest czesto niepotrzebne ...
// q: to jak chronimy invariants - gdy sub-E maja own versions

- z: uzywamy hbm
- kiedy w agg Product zmieniamy name/desc/.. -> podbijamy version of root
- it's ok/easy
- ale prob: jak zmieniac ver kiedy zmienia sie order of BacklogItems
  - bo modyf. ProductBacklogItem nie jest widziana przez HBM jako zmiana Product [przez mech. version'owania]
- teor. mozna to obejsc przez sztuczne podbijanie agg/Product przy zmianie PBI
Product.reorderFrom(..) {
  // read ProductBacklogItem
  // modify PBI
  version(version() + 1) // sztucznie podbij Product.version
}
- probs with w/w
  - Product.version zmienia sie takze jesli call to reorderFrom(..) nie zmienia kolejnosci
  - wyciek infra do modelu
  
fix
- przy modyf PBI nie musimy podbijac P.version
- PBI moga miec own OC
- OC bedzie chronic modyf. single PBI przez wielu users

c
- PBI sluzy tylko i wylacznie do sortowanie BIs wewn. Product
- jest sub-E, ma ref do TenantId, ProductId ... -> hence
- hance VIN
  - sub-E moga refowac do innych E/aggs - ale tylko przez ID [p/p]
  - a zakaz jest refowania z sub-E do innych aggs po 'ref' [p/p]

- versioning all E parts doesn't work in every case
- sometimes [to protect invariants] we must modify root version
  
alter way
- use hooks provided by hbm
- cfg root version-ing as dirty and manually handle OC
- ale trzeba uzyc bidirectional relation - co EE bardzo odradza
  - mozna uzyc w rzadkich cases
  - ale nie dla mech. potrzeb OptimisticConcurreny
    
alter way
- podziel agg na mniejsze i uzywaj std OC
- niezalecane - bo domene ksztaltuje infra
- ale moze byc uzasadnione wielkoscia, wydajnoscia root'a

- wg VV problemu nie ma w techs gdzie agg zapisujemy jako calosc [mongo, riak ..]
- gt: ale pewnie sa problemy z brakiem OC ;]


### 8.5 avoid dependency injection

- injecting repos or DS to aggs - is bad
- bo aggs moga przez to robic look-up'y/dociagaja inne aggs
- reced way: find all aggs before calling command on agg (which needs these pre-loaded aggs)
- 'disconnected domain model' is not reced

- racze wstrzykuj Repos, DS do AS etc.