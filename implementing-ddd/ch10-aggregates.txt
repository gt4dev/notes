# ch10 aggregates

- grupowanie encji i vo w agregaty to jeden z mniej zrozumiałych tematów DDD

- typowy problem to robienie zbyt duzych agg (i zagniezdzanie full entities)
- nie mozna tez pociac agg na 'zbyt male' bo to nie chroni invariants


## 1 using aggregates in the scrum core domain

- samples base on bc=apm


### 1.1 1st attempt: large-cluster aggregate

- assume Product is very large agg
- contains objects: BacklogItem, Release, Sprint ..

- klasa wyglada prosto
- ale stworzy tone problems
  - many tx will fail (conflicts)
    - q: czyli w "1 user env" to wygodne i ok podejcie?

optimistic concurrency
- class Product extends ConcurencySafeEntity
- CSE impls optimistic concurrency
dzialanie OC
- CSE zawiera pole concurrencyVersion (tabel ma kolumne concurrency_version)
- podczas zapisu E - jesli numer wersji jest starszy niz juz zapisany w bazie - to update jest odrzucany
- hbm uzywa elem <version> do wskazania pola
sample
- user A i B pracuja na tym samym obiekcie Product,ver=1
- A dodaj BacklogItem i robi commit, teraz ver=2
- B dodaje Release i probuje zrobic commit - tx fails bo ma stale ver

c: nadpisywanie zmian w key-value stores
- przy kazdym zapisie agg - zapisywana jest jego CALA zawartosc
- to nappisuje zmiany innych user'ow nawzajem
- to niedopuszczalne

n: poza fails of tx - large agg has other probs
- wydajność
- skalowalność


### 1.2 2nd attempt: multiple aggregates

consider another model
- 4 aggrs: Product, BacklogItem, Release, Sprint
- each refs Product by ProductId (identity of Product)

comparing to prev. model
- signature of Product methods will change
- w large jest
  Product { void ScheduleSprint("params desc sprint, w/o any IDs")
- w small jest
  Product { Sprint ScheduleSprint("params identyczne")
- mega zmiana
  - w large jest command
  - w small jest querry 
    - dziala jak factory (tworzy i zwraca agregat)

uzycie w AS
MyAS { 
  public void planProductBacklogItem(
    aTenantID, aProductID 
    aSummary, aCategory, aBacklogItemType, aStoryPoint) 
- all params as primitives / strings!!!
- metoda konwertuje strings w VO
  - ID'kie przez "new TenantId(tenandId)"
  - reszta przez "static methods/factorie" w VO
      BacklogItemType.valueOf(backlogItemType):BacklogItemType
- z repo wyszukujemy agg Product
- i wywolujemy na nim
    product.planBacklogItem("params juz jako VO"):BacklogItem
- zwrocony agg BI dajemy do
    biRepo.Add(bi)
    
c: VV uzywa konwencji prefix'owania method params with 'a'

c: w 'small agg' nie ma problemu konfliktu tx'ow (mozna tworzyc dowolna || ilosc aggs)

c: w modelu 'large' mozna ustawic HBM/optimisticLock=false 
- eliminuje to problem z konfliktami tx (przy dodawaniu new BI ..)
- ale zostaly by inne problemu



## 2 rule: model true invariants in consistency boundaries

- zeby odkryć agregaty w BC musimy odkryć prawdziwe niezmienniki (invariant) modelu - musimy!!!
- niezmienniki wyznaczaja zawartość agregatu

- inwariant = reguła biznesowa która musi być zawsze consistent/utrzymana
- prosta i skuteczna definicja

typy konsystencji
- transactional consistency TC
- eventual consictency EC

inwariant dotyczy tylko TC

przykład
- inwariant c = a + b
class Agg1 { 
  // pola A, B, C
  // operacje 
- cokolwiek się dzieje, niezależnie jakie operacje sawywołane = invariant zawsze musi być spełniony

c: agregat wyznacz TC boundary (obszar zawsze konsystentnych danych)
- zatem E nested in Agg jest konsystentne

- zwykle C zapewnia TX
- wowczas podczas commit wszystko wewn. granic agregatu musi byc C
- czyli w "tmp states" inwariant nie musi byc zachowany (ale musi podczas commit)

- BC modyfikuje tylko 1 agg w tx

- do zaproj. agg trzeba wykonac analize tx!!! co kiedy ma byc C
- duzo zalezy od UI - ile aggs bedzie modyf. przy 1 use case, powinien modyf. 1 agg

- agg wyznaczaja granice consistency (a nie tworza graf obiektow)


## 3 rule: design small aggregates

std problems with large aggs
- tx conflicts
- perfomrance
- scalability

another problem - sample
- assume large agg Product with 1k of BIs, Sprints, Releases ...
- jak chcesz dodac new BI
- to musisz wczytac ALL BIs (mimo ze ich nie potrzebujesz)
- to problem wydajnosci i pamieci
- n: pozostale E (Release, Sprint ..) ustaw jako lazy-loading i nie sa one wczytywane

- large agg tworza nieprawdziwe invariants
- dla "pozornej" wygody tworza mega grafy obiektow

small agg
- only root entity with attrs (possibly as VO)

przyklad "niejawnych invariants"
- w Product attrs name and desc sa zwykle zmieniane razem - stad sa w 1 agg

hint
- przy projektowaniu modelu mysl czy dany koncept
  - czy bedzie sie zmienial w czasie
  - czy mozna go kompletnie wymienic
.. if 2nd - project it as VO

c: if you re-analyse your model - probably you'll see that many many E can be replaced with VO

c: w avg projekcie biznesowym
- 70% aggs ma 1 E (plus props as VO)
- 30% aggs ma 2-3 E
.. acz all zalezy od reqs


### 3.1  don't trust every use case

- typowa specyfikacja opisuje use cases
- trzeba do niej dolaczyc decyzje o tworzeniu agg

- czesto specyfikaca wymaga modyfikacji wielu agg
- nalezy ustalic czy
  - mozna rozbic to na kilka mniejszych tx
  - realnie potrzebna jest 1 big tx

note
- if you try to modify many aggs in 1 tx - to moze ze zle ustaliles invariant (zbyt szeroko)
- moze trzeba polaczyc kilka aggs w nowy agg (z nowymi granicami spojonsci) - zaproj. nowy "koncept"

another option - use eventaul consistency
- but check if delay is acceptable


## 4 rule: reference other aggregates by identity

- jak proj. obiekt to kusi wizja duzego grafu obiektow (compositional structure) z opcja dalekiej nawigacji

wazne
- agg MOZE miec ref do root'a innego agregatu
- ale ref'owany agg NIE lezy w consistency boundary tego agg
- sample
  class BacklogItem : ConcurrencySafeEntity {
    Product product
  }


if in 1 tx you must modify many agg - it's v strong info that there is 
- bad consistency boundary
- some UL notion wasn't discovered yet

- jesli mimo dodatkowych analiz - problem pozostaje - moze trzeba uzyc eventual consistency


### 4.1 making aggregates work together through identity reference

- prefer refing between aggs by their ID
- sample
  class BacklogItem : ConcurrencySafeEntity {
    ProductId product
  }

- refing by ID avoids 'eager loading' refed aggs
- model 
  - is faster (less time take load to mem)
  - consumes less mem


### 4.2 model navigation

how to navigate with only ID
- way 1 - "disconnected domain model"
  - call repos from inside of agg - to fetch needed data
  - form of lazy-loading

- way 2 (reced)
  - use repo or DS to load 2nd agg data
  - pass this data to 1st agg when needed
sample
- chcemy wywolac metode assignTeamMemberToTask(TeamMemberId, Team, TaskId) z agg BacklogItem
- create AS.assignTeamMemberToTask
- prepare params needed by agg's method
- read agg Team
  - here alter is having ref to Team
- pass all to above method

- way 2 frees agg from deping from repo (or DS)
- way 1 is ok for complex domains
  - pass to called method ref to repo (or DS) 
    - yes, param, q: why not make repo field of class?
  - agg robi double dispatch to dwl data
  
- remember: regardless of way - in 1 tx you modify 1 agg

c: ui and navigations
- using IDs for refing between aggs make hard navigation - useful in UI
- in such case reading data reqs calls to few repos
- it slow performance
- in such cases: use "HBM theta joins" or CQRS

c: hbm and theta joinsu
- it allows to read a few diff aggs in 1 query
- it's hbm (not sql) querry which returns related (but diff) objects


### 4.3 scalability and distribution

- aggs ref themselves by ID
- as amazon guy says: "almost infinity scalability" can be achieved

other plus
- in app there are many BCs
- as refs are done by ID then naturally can ref aggs from other BCs
- it's especially useful if you
  - modify local agg
  - and send dEvent (with agg id) about this change
- naturally: txes are divided between BCs, and eventual consistency is used


## 5 rule: use eventual consistency (EC) outside the boundary

wg EE 
- to keep consistency and modify many aggs in 1 request - use eventual consistency
- this rule regards all cases
  - with few aggs modified "in 1 req"
  - with many aggs (eg. even during batch processing)

- you must agree with domain experts is delay ok between modifying objects

impling EC
- there is agg with method BacklogItem.commitTo(Sprint s)
- method is command
- method at the end sends event BacklogItemCommited
  - n: send is sync, but consumption on subsciber side is async
- subers 
  - exec in separated TX (keep rule: modify each agg in 1 tx)
  - one of subers - will add info about new item to Sprint agg

what if modification fails on suber side
- modification can be retried
  - if no ack from suber that modification done -> event is redelivered
    // q: how message infra gets info about 'event handled'?
  - there can be many retries until
    - app gets ack "message handled"
    - and consistency is finally achieved
- but there should be limit of tries - after this you should
  - either compensate tx
  - at least report problem to user/admin - to react
    
c: do retires non-linear
- retry next redelivery with longer and longer delay
- start with delay 1sec, then 2sec, then 4sec - until limit
 

### 5.1 ask whose job it is

- sometimes it's hard to guess what consistency to apply (tx or eventaul)

wg EE - to decide on method
- assess whose responsibility is to assure consistency
  - if user (who calls particular use-case) - do task in 1 tx
  - if another user or system - do task in EC
  


## 6 reason to break the rules

- czasem można zapisać w kilka aggs w 1 tx
- ponizej sa 4 powody (ale nie jedyne)


### 6.1 r1: user interface convinience

- czasem user na 1 ekranie tworzy kilka np. nowych BacklogItems
- taki UC obsługujemy w 1 metodzie  
- np. AS.planBatchOfBacklogItems[productId, tenantId, BItemDesc[] seriaNowychDanych]
- w/w metoda wewn. tworzy klika instancji BItems i dodaje je kolejno do BItemRepo, w 1 tx

- nie ma tu problems z niezachowaniem invariants - bo tworzymy nowy BItems

- n: chyba zachowanie inwariants jest kryterium czy mozna zlamac agg-rule


### 6.2 r2: lack of technical mechanism

- using eventual consistency reqs some infra (messaging, timers, backround threads ..)
- some projs don't have access to it - sad but true

- as we won't use EC -> proj p/b will have large aggregates
- this will decrese performance/scalaebility

- thus: consider creating small aggs
- if business doesn't allow to change spec --then--> no choice: you can modify many aggs in 1 tx


### 6.3 r3: global transacitons

- if you must global, 2-phase tx-es - then it looks natural to modify many aggs in 1 tx
- but it DOESN'T directly force us to modify many aggs in 1 tx
- thus: if possible - avoid even here modifying many aggs in 1 tx


### 6.4 r4: query performance

- sometimes you must have "live" ref from agg1 to agg2
  - cause eg it ease doing fetching data etc
- you can do it but remember about "perfomrance etc." problems


### 6.5 adhering to the rules

- there can be many reasons to break rules
- but remember - in long term - keeping rules ease project, but breaking -> make proj. hard
- if you keep rules you will have
  - consistency where it's needed
  - performance
  - scaleability


## 7 gaining insight through discovery

// here agg rules are applied and checked how it influence model


### 7.1 rethinking the design, again

current state
- domain is divided on small elements
- aggs ref each other by id

c
- acc to spec: if hours in Tasks in BacklogItem == 0 -> auto set BI as done
- it's invariant thus BI and Tasks are kept in 1 agg (BI)


### 7.2 estimating aggregate cost

technika BOTE [back of the envelope] 
- estymuje ilosci obiektow bioracych udzial w danym UC (ale i ogolnie)
- przyklad
  - zgrubienie określ czas trwania Sprint, ilość Tasks in Sprint ... 
  - zgrubnie policz ilosc obiektów BItem, Task ...
  - wyszlo: np. 144 obiekty na zaladowanie 1 BI


### 7.3 common usage scenarios

Ciekawostka jak jest zbudowane optimistic concurrency dla klasy task
Musi być możliwość że dwóch użytkowników dodaje nowe taski,  i nie blokują sobie nawzajem będą bitem
Każda encja ma swoją wersję[ pole klasy] z optymisty konkurencją
Każda encja niezależnie modyfikuje wersję

Jest problem
Dodanie nowego Task większa wersję backlog item
Zatem dodanie dwóch równoległe tasks  spowodujee konflikt

Może trzeba zoptymalizować hbm wyłączyć optimistic lock
Optimistic Lock w typowej konfiguracji równa się version,  teraz ustawimy False
Prawdopodobnie   ustawiane jest to na bitem, <class>
Ciekawe że dopuszczalna jest i opłacana taka modyfikacja

W tym przypadku, dodawania task do b item,  Musimy wprowadzić mechanizm który pozwoli na równoległe dodawanie wielu tasks
Optimistic locking=version nie sprawdzisie tu

Widać to bardzo wyraźnie że strategia lockowania musi zależeć od konkretnego uc
I stanowi to pewną heurystyke,  bo nigdy nie wiemy czy założenia okażą się słuszne,  Użytkownicy moga działać inaczej
I w konsekwencji jednak będzie dużo failed tx
Z drugiej strony Niedopuszczalne są nadpisywania danych  nawzajem przez użytkowników



### 7.4 memory consumption

// nothing special - just count objects loaded in UC

c: double lazy load ;]
- Tasks of BacklogItem are lazy-loaded
- lazy-loaded are also EstimationLogEntry (part of Task)
- wg VV podczas UC ladowanych jest 25 obiektow - wg VV to nieduzo

[not sure]
- during single req is done 'double lazy-loading' (above Tasks, then Esitmates)
- but wg VV 
  - optimizing it - should be done after tests/analyses - is it real problem
  - don't optimize it "now"


### 7.5 exploring another alternative design

// ch tests alter approaches to agg boundaries

idea: wydzielic Task jako osobny agg (wydzielic go poza BI)
- pros
  - we save memory (less objects are loaded)
  - eliminate lazy loading
- cons: delay in setting BI status to done (due to EC)
- but business accept it -> idea is accepted


### 7.6 implememnting eventual consistency

// q: jak robione jest message redelivery (in the case of failure)

example - use EC to set BI state
- agg has method-command Task.estimatedHoursRemaining()
- on method end event is sent EventTaskHoursRemainingEstimated
- event has attrs BacklogItemID, TaskID, hoursRemaining, ...
- suber of a/m event - on event - calls DS which
  - get BI z repo (by ID from event)
  - get Task ...
  - calls BI.estimateTaskHoursRemaining(event.hoursRemaining, task)
    - this call set BI state to done if no more hours remains

optimalization
- instead of reading all Tasks for BI (to calc remaining hours)
- rather create specialized method in repo
  TotalBacklogItemTaskHoursRemaining(tenantId, biId)
- which on DB level calcs remaining hours of BI (w/o reading all Tasks to mem)
- if repo create 


waiting for EC and refresh UI
- if you quickly update Task but BI with delay (due to EC)
- then what to show on UI if task is already modified but BI not yet
- reced approach: show on UI message (or sth like this): "BI state is calculated, refresh soon"
- gt: a/m jest slabe, moze lepiej owrapowac calosc w await?


### 7.7 is it the team member's job?



### 7.8 time to decision



## 8 implementation



### 8.1 create a rool entity with unique identity



### 8.2 favor value object parts



### 8.3 using law of Demeter and tell, don't ask



### 8.4 optimistic concurrency



### 8.5 avoid dependency injection