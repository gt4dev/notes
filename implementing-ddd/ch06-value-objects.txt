# 6 VALUE OBJECTS

- vo są czesto "przyćmione" przez e
- gdziekolwiek możliwe powinieneś użyć vo zamiast e
- nawet same e powinny skupiac sie na serwowaniu vo

- vo skupiają się na mierzeniu, kwantyfikowaniu (okreslaniu ilosci), opisywaniu 
- dzieki temu to łatwe do kodowania, testowania, optymalizowania i utrzymania (wow, chyba all plusy)

ciekawostka
- popularnym podejsciem jest 
  - zamodelowanie domeny jako struktury tabel (1 obiekt domeny = 1 tabela) 
  - powiazanie tabel kluczami
- efektem jest zlo
  - mocno zszyty wielki graf obiektow
  - przeladowany set/get-erami

- obiekt vo towrzymy, przekazujemy klientom i zapominamy o nim
- to rewolucjonizuje podejście do programowania
- wg VV to jak przejście z old lang na lang uzywajace GC!

- użyj vo jeśli interesuja cie tylko o atrybuty
- bez identity etc.

- beginners często nie wiedza czy użyc e czy vo
- ale profs tez tak maja ;]


## 6.1 value characteristics

- możliwe że powinieneś używać VO znacznie częściej niż do tej pory


### 6.1.1 measures, quantifies or desc

- VO nie modeluje rzeczy/przedmiotu z UL
- VO mierzy, kwantyfikauje lub opisuje rzecz/przedmiot
- np osoba ma
  - wiek (wiek to pomiar, kwantyfikacja)
  - imię (to opis)
- troche to podobne do Conceptual Whole


### 6.1.2 immutable

- c: VO baaaardzo rzadko ale moze byc zmienne (more w EE)

- od razu po utworzeniu - obiekt staje się z kompletnie niezmienny
- wartości tworzące VO podajemy w konstruktorze
- acz przy odtwarzaniu VO z DB, JSON, XML ... init moze nastapic pozniej

obvious ale
- vo mogą referować do innych vo
- metody modyfikujące stan vo nie mogą być 
  - publicznie
  - wywołane po constr

VO może mieć ref do E
- VV tego nie zaleca
- jak entity zmieni stan, to zmienia się również vo, a to łamie zasadę niezmienności
- dopuszczalne tylko jeśli znacznie uprości to kod
- nawet w takim case klient nie może bezpośrednio wołać metody e 
  - woła metody vo (cos jak aggr)
  - u: metody te nie modyfikuja stanu vo!
    - wiec to dopuszczalny

- jeśli projektujesz obiekt który musi zmienic stan 
- to rozwaz czy lepiej kompletnie wymienic obiekt

### 6.1.3 conceptual whole (CH)

- VO zawiera (najczesciej) wiele atrybutów 
- każdy jest nieodlaczna częścią całości, tylko razem tworzą pomiar, kwantyfikuja ...

c: pattern CH opracowal Cuningham

przykład: 50usd
- dwa atrybuty
  - razem tworzą CH - okreslaja wartość pieniężną
  - osobno kazdy znaczy coś innego

ciekawy przykład
class ThingOfWorth {
  MonetaryValue worth;
  ThingName name;  <<< tak, name w VO a nie string!
}
- warto uzyc VO zamiast primitive (string, ...) jeśli wokolo V jest "zachowanie"
- zbuduj VO i zamknij zachowanie w metodzie (schowaj jego logike przed klientami)
- eg: ThingName.CapitalizedName()
  - dba 1st letter byla duza reszta była mała

obvious but
- cały vo jest zawsze tworzony w jednej operacji - w konstruktorze


### 6.1.4 replacebility

- vo typically is held (as reference) by e
- if vo changes - completely change vo (update e's reference)


c: full relacement is done during setting primitives
eg: when setting int with 3 to 5 - you replace it (not update)

whatever you need to update in vo (1 value, many values ..) - rebuild whole object
- build whole new vo
- set this new object in place of 'old'

replacebility moze sie wydawac nieefektywne dla malych i czestych zmian
ale da sie to zoptymalizowac
przez uzycie side effect free behavior


### 6.1.5 value equality

- w app może istniej wiele roznych VO które z logicznego punktu widzenia są równe
- teoretycznie mógłbyś zostawic 1 taki VO i wstawic ref do niego wszedzie w app - nie zmieni to zachowania app

- porównanie robimy przez porównanie 
  - typów 
  - atrybutów (cmp all, 1-by-1)
- if both are equal - objects are equal

c: VV in equals() reads values by getters
- so VV uses full self-encapsulation (setters in consructors)

c: equals uses all INTERNAL attrs to cmp objects
- so regardles of which eg. FullName is used (CapitalizedName(), Initials() ...)
- cmp is done correctly 

vin: if object doesn't req unique identity - do it as VO, else as E


### 6.1.6 side-effect-free behavior (sefb)

- pattern od EE

- funkcja = metoda obiektu która nie modyfikuje jego stanu
- all sefb = funkcje
- all vo methods must be functions

c: w funkcyjnych jezkykach uzywa sie tylko sefb
czyli chyba tylko operuje sie na "VO'ach"

c: Mayer/Fowler funkcje nazywaja "metodami query" z pattern CQS (Command Querry Separation) 

przykład
- FullName.withMiddle(sth):FullName
- metoda z vo FullName zwraca nowy obiekt FullName, wzbogacony o middle name

czy vo może modyfikować e przekazana jako parametr metody vo
- jesli metoda ta modyfikuje tylko stan e (nie zmienia stanu vo) - jest dopuszczalna
- ale to raczej trudno przetestowac
- thus best
  - vo method should return sth what E can consume/set-on-itself
  - vo method shouldn't modify e

- obiekt vo businessPriority.priorityOf(product):float // bp = vp, p = e
- 'float' jest wyliczany ze stanu e
- problems here
  - vo zależy od e (i musi znac strukture e)
    - unikaj tego
    - vo best ograniczyć do znajomości siebie i swoich atrybutów
  - nie widzimy wprost które pole z Product jest używane
    - more explicite jest 'wyciagniecie z Product' konkretnego stanu (np. product.PrioritySthSth())
    - i przekazanie go do vo
  - nie widzimy wprost czy e jest modyfikowane

- very very rare ale czasem vo jest modyfikowalne!
- acz staraj sie zamiast tego - budowac vo (or entity?) z sefb


## 6.2 integrate with minimalism

- kazdy projekt ddd ma wiele bc
- (if possible) model concepts from remote bc (server, upstream) as vo on local bc (client, downstream)
- it minimizes amount of "problems" during integration

przyklad
- w remote bc-R sa agregaty: User, Role
- local bc-L uses data from w/w aggrs
- bc-L keeps this data in VOs: Moderator, Owner, Participant
- it simplifies case a lot (in bc-L we have only needed data)
  - strive to use this case

problem: integration is static
- if bc-R changes data, bc-L doesn't know about it
- bc-L moze zachowac 'eventual consistency'
  - nasluchiwac events z bc-R i aktualizowac sie
- ale wowczas dane sie zmieniaja - nie mozna uzyc VO - trzeba je trzymac w E


## 6.3 standard types expressed as values

ST
- opisuje rzeczy, mierzy ... (like vo)
- rozroznie stuff (e,vo) od siebie

sample 1
- UL defs phone number
- phone moze byc dla cell, home, work, ...
- tworzymy VO dla phone number i rozowzniamy przez ST

sample 2
- UL defs currency and app defs explicitly: usd, jpy, eur, pln

- ST are similar to enums "but" are "instantiated"

STs can be defined on diff levels
- single BC, app
- corpration
- international stds

freq STs are managed in specialized BCs, usually
- defined as Es, with attrs
  - identity
  - name
  - description
  .. but can be more
- you consume them as VO, usually with 1 (yes, 1) attr
  
samples (on enums)
"enum GroupMemberType {Grup, User "and some overrides"}"
  - yes, literally enum: used as enum 
  - no magic, no single vo instances, just plain enum!!!
enum  BacklogItemStatus {Planed Scheduled Commited...}


U: instead enum you can create unique VO for each ST

ST from Agg
- 1 instance of Agg for ST type
- but think twice

c: ST (raczej) nie powinny byc utrzymywane w BC który ich używa
- q: why, bo to overloading "BC resp"?

- widly used ST should be def in specialized BC
- problem can be modifying such STs
- expose Aggs (changable!!)
  - on consument side as VO (immutable)
  - maybe globally expose as immutable VO?

shared immutable ST
- create service (DS) or factory for each shared ST
  - it reads data from shared database
- sample services are for PhoneNumber, PostalAddressType, CurrencyType
- service (or factory) returns then VO eg: Currency

acz use simplest approach = enums

VV recoms "enums based ST" also expose from service/factory
code for enum must be "generated" from DB



## 6.4 testing value objects

// quite regular infos
- tests write in a way that non-technical expert can understand id = use only UL


## 6.5 implementation

- BusinessPriority to super przyklad vo 
- pokazuje nawet uzycie jako strategy pattern (aka policy)

BP jest serializable
- to wazne przy vo remote calls, persisting object

VV daje 2 konstruktory do vo
- 1st - do initu obiektu (it calls self delegation methods)
- 2nd - create copy
  - c: robimy shallow copy, nie kopiujemy nested objects but ref to them (beside primitives, but string?)
    - w VO deep copy nie ma sensu (typowo), acz czasem jest potrzebne
  - 2nd const - useful for testing immutability, like
    - create vo0
    - create copy vo1
    - call methods of vo1 (try to "modify it")
    - compare both vo
- u: 3th const - bez params, na potrzeby hbm, schowany (protected)

pattern strategy/policy
- vo (BP) ma publiczne metody, eg: TotalValue():float
- metoda 
  - nie dziala bezposrednio na attrs v0
  - internally calls other methods (self-delegatino and others)
  - operates on result from a/m methods
- strategy bo 
  - at any time you can override any of these methods
  - docelowo BP bedzie miec wiele implementacji i sie to przyda

nazwy getterow
- VV odradza nazwy metod eg getSomething()
- jesli masz metode getValueSth() to nazwij ja ValueSth
- it's more human-readable, UL-friendly

c: bad Java Beans specification
- it had bad influence on projects of object
- good old example: String
  - good methods: chartAt,  indexOf, length ..
  - ale sa bad getSth ...

c: encapsulation
- masz setter setRatings (private, calles in constr)
- masz "getter" "public ratings()" - just returns attr value
- conc: w ten sposob mozesz "upubliczniac" private attr (choc to pewnie uzasadnione)

remember to impl
- equals
- hashCode
- toString



## 6.6 persisting value objects

- zwykle VO persystujemy razem z A (do ktorego jest przypiete VO)
- n: all dalsze przyklady zakladaja ze VO jest czescia A
- typowo A (razem z VO) jest read/write by repo

- zwykle pers. robimy z orm
- ale to complicated (bo trzeba zrobic mapowanie, przygotowac tabele ...)
- no-SQL/key-value stores mega ulatwiaja pers. of A
  - troche o tym z ch12-repos
  - tu tylko sql


### 6.6.1 reject undue influence of data model leakage

- typowo VO is stored in DB in denormalized form (in the same table/row what hosting E)
- easy and convient way

- czasem VO is stored as DB entity (own table, primary key ..)
- it's mainly for E with nested VOs collections

- regardless of case - DB shouldn't influence domain model
- more - it should be reverse: domain model drives data model
- although as always - there are exceptions

- sometimes particular data model structure is needed (keep ref integritiy, indexes, keys, support raporting, querries ...)
- many claim that raporting should: not work on prod DB, has own data stucture


### 6.6.2 orm and single value objects

- easy case
- idea: store VO in the table & row of E but own columns (each attr in own column)

column naming (distinguish all E cols)
- path of objects: businessPriority.ratings.benefit
- map to column: business_priority_ratings_benefit

- in hbm use <component>

c
- VV's sample nestes 1 VO in another
- in hbm cfg it by nesting <component> in another <component>

- n: domain model (vo) doesn't have any stuff from DB model


### 6.6.3 orm and many values serialized into a single column

- list of VO is viewed in E as Set or List
- serialize collection to text and store in 1 column

wady
- col width - sometimes we don't know 
  - size of collection (can be long)
  - size of single object (some strings can be looooong)
  c: w MySQL max table/column width = 65k chars    
  c: w Oracle varchar2 max = 4k chars
- queries
  - can use VO in Q (cause are srings)
  - but it's rather rare need
- need to impl custom hbm type (no big issue)



### 6.6.4 ORM and many values backed by database entity

- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table

- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects

- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)