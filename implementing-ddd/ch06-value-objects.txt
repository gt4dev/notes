# 6 VALUE OBJECTS

6 Value Object

- vo są czesto "przyćmione" przez e
- gdziekolwiek możliwe powinieneś użyć vo zamiast e
- nawet same e powinny skupiac sie na serwowaniu vo

- vo skupiają się na mierzeniu, kwantyfikowaniu (okreslaniu ilosci), opisywaniu 
- dzieki temu to łatwe do kodowania, testowania, optymalizowania i utrzymania (wow, chyba all plusy)

ciekawostka
- popularnym podejsciem jest 
  - zamodelowanie domeny jako struktury tabel (1 obiekt domeny = 1 tabela) 
  - powiazanie tabel kluczami
- efektem jest zlo
  - mocno zszyty wielki graf obiektow
  - przeladowany set/get-erami

- obiekt vo towrzymy, przekazujemy klientom i zapominamy o nim
- to rewolucjonizuje podejście do programowania
- wg VV to jak przejście z old lang na lang uzywajace GC!

- użyj vo jeśli interesuja cie tylko o atrybuty
- bez identity etc.

- beginners często nie wiedza czy użyc e czy vo
- ale profs tez tak maja ;]


## 6.1 value characteristics

- możliwe że powinieneś używać VO znacznie częściej niż do tej pory


### 6.1.1 measures, quantifies or desc

- VO nie modeluje rzeczy/przedmiotu z UL
- VO mierzy, kwantyfikauje lub opisuje rzecz/przedmiot
- np osoba ma
  - wiek (wiek to pomiar, kwantyfikacja)
  - imię (to opis)
- troche to podobne do Conceptual Whole


### 6.1.2 immutable

- c: VO baaaardzo rzadko ale moze byc zmienne (more w EE)

- od razu po utworzeniu - obiekt staje się z kompletnie niezmienny
- wartości tworzące VO podajemy w konstruktorze
- acz przy odtwarzaniu VO z DB, JSON, XML ... init moze nastapic pozniej

obvious ale
- vo mogą referować do innych vo
- metody modyfikujące stan vo nie mogą być 
  - publicznie
  - wywołane po constr

VO może mieć ref do E
- VV tego nie zaleca
- jak entity zmieni stan, to zmienia się również vo, a to łamie zasadę niezmienności
- dopuszczalne tylko jeśli znacznie uprości to kod
- nawet w takim case klient nie może bezpośrednio wołać metody e 
  - woła metody vo (cos jak aggr)
  - u: metody te nie modyfikuja stanu vo!
    - wiec to dopuszczalny

- jeśli projektujesz obiekt który musi zmienic stan 
- to rozwaz czy lepiej kompletnie wymienic obiekt

### 6.1.3 conceptual whole (CH)

- VO zawiera (najczesciej) wiele atrybutów 
- każdy jest nieodlaczna częścią całości, tylko razem tworzą pomiar, kwantyfikuja ...

c: pattern CH opracowal Cuningham

przykład: 50usd
- dwa atrybuty
  - razem tworzą CH - okreslaja wartość pieniężną
  - osobno kazdy znaczy coś innego

ciekawy przykład
class ThingOfWorth {
  MonetaryValue worth;
  ThingName name;  <<< tak, name w VO a nie string!
}
- warto uzyc VO zamiast primitive (string, ...) jeśli wokolo V jest "zachowanie"
- zbuduj VO i zamknij zachowanie w metodzie (schowaj jego logike przed klientami)
- eg: ThingName.CapitalizedName()
  - dba 1st letter byla duza reszta była mała

obvious but
- cały vo jest zawsze tworzony w jednej operacji - w konstruktorze


### 6.1.4 replacebility

- vo typically is held (as reference) by e
- if vo changes - completely change vo (update e's reference)


c: full relacement is done during setting primitives
eg: when setting int with 3 to 5 - you replace it (not update)

whatever you need to update in vo (1 value, many values ..) - rebuild whole object
- build whole new vo
- set this new object in place of 'old'

replacebility moze sie wydawac nieefektywne dla malych i czestych zmian
ale da sie to zoptymalizowac
przez uzycie side effect free behavior


### 6.1.5 value equality

- w app może istniej wiele roznych VO które z logicznego punktu widzenia są równe
- teoretycznie mógłbyś zostawic 1 taki VO i wstawic ref do niego wszedzie w app - nie zmieni to zachowania app

- porównanie robimy przez porównanie 
  - typów 
  - atrybutów (cmp all, 1-by-1)
- if both are equal - objects are equal

c: VV in equals() reads values by getters
- so VV uses full self-encapsulation (setters in consructors)

c: equals uses all INTERNAL attrs to cmp objects
- so regardles of which eg. FullName is used (CapitalizedName(), Initials() ...)
- cmp is done correctly 

vin: if object doesn't req unique identity - do it as VO, else as E


### 6.1.6 side-effect-free behavior (sefb)

- pattern od EE

- funkcja = metoda obiektu która nie modyfikuje jego stanu
- all sefb = funkcje
- all vo methods must be functions

c: w funkcyjnych jezkykach uzywa sie tylko sefb
czyli chyba tylko operuje sie na "VO'ach"

c: Mayer/Fowler funkcje nazywaja "metodami query" z pattern CQS (Command Querry Separation) 

przykład
- FullName.withMiddle(sth):FullName
- metoda z vo FullName zwraca nowy obiekt FullName, wzbogacony o middle name

czy vo może modyfikować e przekazana jako parametr metody vo
- jesli metoda ta modyfikuje tylko stan e (nie zmienia stanu vo) - jest dopuszczalna
- ale to raczej trudno przetestowac
- thus best
  - vo method should return sth what E can consume/set-on-itself
  - vo method shouldn't modify e

- obiekt vo businessPriority.priorityOf(product):float // bp = vp, p = e
- 'float' jest wyliczany ze stanu e
- problems here
  - vo zależy od e (i musi znac strukture e)
    - unikaj tego
    - vo best ograniczyć do znajomości siebie i swoich atrybutów
  - nie widzimy wprost które pole z Product jest używane
    - more explicite jest 'wyciagniecie z Product' konkretnego stanu (np. product.PrioritySthSth())
    - i przekazanie go do vo
  - nie widzimy wprost czy e jest modyfikowane

- very very rare ale czasem vo jest modyfikowalne!
- acz staraj sie zamiast tego - budowac vo (or entity?) z sefb


VVVVVVVVVVVVVVVVVVVVV CONT. HERE




## 6.2 integrate with minimalism

## 6.3 standard types expressed as values

## 6.4 testing value objects

## 6.5 implementation

## 6.6 persisting value objects

### 6.6.1 reject undue influence of data model leakage

### 6.6.2 orm and single value objects

### 6.6.3 orm and many values serialized into a single column




### 6.6.4 ORM and many values backed by database entity
- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table
- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects
- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)