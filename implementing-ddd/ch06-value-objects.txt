# 6 VALUE OBJECTS

6 Value Object

- vo są czesto "przyćmione" przez e
- gdziekolwiek możliwe powinieneś użyć vo zamiast e
- nawet same e powinny skupiac sie na serwowaniu vo

- vo skupiają się na mierzeniu, kwantyfikowaniu (okreslaniu ilosci), opisywaniu 
- dzieki temu to łatwe do kodowania, testowania, optymalizowania i utrzymania (wow, chyba all plusy)

ciekawostka
- popularnym podejsciem jest 
  - zamodelowanie domeny jako struktury tabel (1 obiekt domeny = 1 tabela) 
  - powiazanie tabel kluczami
- efektem jest zlo
  - mocno zszyty wielki graf obiektow
  - przeladowany set/get-erami

- obiekt vo towrzymy, przekazujemy klientom i zapominamy o nim
- to rewolucjonizuje podejście do programowania
- wg VV to jak przejście z old lang na lang uzywajace GC!

- użyj vo jeśli interesuja cie tylko o atrybuty
- bez identity etc.

- beginners często nie wiedza czy użyc e czy vo
- ale profs tez tak maja ;]


## 6.1 value characteristics

- możliwe że powinieneś używać VO znacznie częściej niż do tej pory


### 6.1.1 measures, quantifies or desc

- VO nie modeluje rzeczy/przedmiotu z UL
- VO mierzy, kwantyfikauje lub opisuje rzecz/przedmiot
- np osoba ma
  - wiek (wiek to pomiar, kwantyfikacja)
  - imię (to opis)
- troche to podobne do Conceptual Whole


### 6.1.2 immutable

- c: VO baaaardzo rzadko ale moze byc zmienne (more w EE)

- od razu po utworzeniu - obiekt staje się z kompletnie niezmienny
- wartości tworzące VO podajemy w konstruktorze
- acz przy odtwarzaniu VO z DB, JSON, XML ... init moze nastapic pozniej

obvious ale
- vo mogą referować do innych vo
- metody modyfikujące stan vo nie mogą być 
  - publicznie
  - wywołane po constr

VO może mieć ref do E
- VV tego nie zaleca
- jak entity zmieni stan, to zmienia się również vo, a to łamie zasadę niezmienności
- dopuszczalne tylko jeśli znacznie uprości to kod
- nawet w takim case klient nie może bezpośrednio wołać metody e 
  - woła metody vo (cos jak aggr)
  - u: metody te nie modyfikuja stanu vo!
    - wiec to dopuszczalny

- jeśli projektujesz obiekt który musi zmienic stan 
- to rozwaz czy lepiej kompletnie wymienic obiekt

### 6.1.3 conceptual whole (CH)

- VO zawiera (najczesciej) wiele atrybutów 
- każdy jest nieodlaczna częścią całości, tylko razem tworzą pomiar, kwantyfikuja ...

c: pattern CH opracowal Cuningham

przykład: 50usd
- dwa atrybuty
  - razem tworzą CH - okreslaja wartość pieniężną
  - osobno kazdy znaczy coś innego

ciekawy przykład
class ThingOfWorth {
  MonetaryValue worth;
  ThingName name;  <<< tak, name w VO a nie string!
}
- warto uzyc VO zamiast primitive (string, ...) jeśli wokolo V jest "zachowanie"
- zbuduj VO i zamknij zachowanie w metodzie (schowaj jego logike przed klientami)
- eg: ThingName.CapitalizedName()
  - dba 1st letter byla duza reszta była mała

obvious but
- cały vo jest zawsze tworzony w jednej operacji - w konstruktorze


### 6.1.4 replacebility

- vo typically is held (as reference) by e
- if vo changes - completely change vo (update e's reference)


c: full relacement is done during setting primitives
eg: when setting int with 3 to 5 - you replace it (not update)

whatever you need to update in vo (1 value, many values ..) - rebuild whole object
- build whole new vo
- set this new object in place of 'old'

replacebility moze sie wydawac nieefektywne dla malych i czestych zmian
ale da sie to zoptymalizowac
przez uzycie side effect free behavior


### 6.1.5 value equality

- w app może istniej wiele roznych VO które z logicznego punktu widzenia są równe
- teoretycznie mógłbyś zostawic 1 taki VO i wstawic ref do niego wszedzie w app - nie zmieni to zachowania app

- porównanie robimy przez porównanie 
  - typów 
  - atrybutów (cmp all, 1-by-1)
- if both are equal - objects are equal

c: VV in equals() reads values by getters
- so VV uses full self-encapsulation (setters in consructors)

c: equals uses all INTERNAL attrs to cmp objects
- so regardles of which eg. FullName is used (CapitalizedName(), Initials() ...)
- cmp is done correctly 

vin: if object doesn't req unique identity - do it as VO, else as E


### 6.1.6 side-effect-free behavior (sefb)

- pattern od EE

- funkcja = metoda obiektu która nie modyfikuje jego stanu
- all sefb = funkcje
- all vo methods must be functions

c: w funkcyjnych jezkykach uzywa sie tylko sefb
czyli chyba tylko operuje sie na "VO'ach"

c: Mayer/Fowler funkcje nazywaja "metodami query" z pattern CQS (Command Querry Separation) 

przykład
- FullName.withMiddle(sth):FullName
- metoda z vo FullName zwraca nowy obiekt FullName, wzbogacony o middle name

czy vo może modyfikować e przekazana jako parametr metody vo
- jesli metoda ta modyfikuje tylko stan e (nie zmienia stanu vo) - jest dopuszczalna
- ale to raczej trudno przetestowac
- thus best
  - vo method should return sth what E can consume/set-on-itself
  - vo method shouldn't modify e

- obiekt vo businessPriority.priorityOf(product):float // bp = vp, p = e
- 'float' jest wyliczany ze stanu e
- problems here
  - vo zależy od e (i musi znac strukture e)
    - unikaj tego
    - vo best ograniczyć do znajomości siebie i swoich atrybutów
  - nie widzimy wprost które pole z Product jest używane
    - more explicite jest 'wyciagniecie z Product' konkretnego stanu (np. product.PrioritySthSth())
    - i przekazanie go do vo
  - nie widzimy wprost czy e jest modyfikowane

- very very rare ale czasem vo jest modyfikowalne!
- acz staraj sie zamiast tego - budowac vo (or entity?) z sefb


## 6.2 integrate with minimalism

- kazdy projekt ddd ma wiele bc
- (if possible) model concepts from remote bc (server, upstream) as vo on local bc (client, downstream)
- it minimizes amount of "problems" during integration

przyklad
- w remote bc-R sa agregaty: User, Role
- local bc-L uses data from w/w aggrs
- bc-L keeps this data in VOs: Moderator, Owner, Participant
- it simplifies case a lot (in bc-L we have only needed data)
  - strive to use this case

problem: integration is static
- if bc-R changes data, bc-L doesn't know about it
- bc-L moze zachowac 'eventual consistency'
  - nasluchiwac events z bc-R i aktualizowac sie
- ale wowczas dane sie zmieniaja - nie mozna uzyc VO - trzeba je trzymac w E


## 6.3 standard types expressed as values

ST
- opisuje rzeczy, mierzy ... (like vo)
- rozroznie stuff (e,vo) od siebie

sample 1
- UL defs phone number
- phone moze byc dla cell, home, work, ...
- tworzymy VO dla phone number i rozowzniamy przez ST

sample 2
- UL defs currency and app defs explicitly: usd, jpy, eur, pln

- ST are similar to enums "but" are "instantiated"

STs can be defined on diff levels
- single BC, app
- corpration
- international stds

freq STs are managed in specialized BCs, usually
- defined as Es, with attrs
  - identity
  - name
  - description
  .. but can be more
- you consume them as VO, usually with 1 (yes, 1) attr
  
samples (on enums)
"enum GroupMemberType {Grup, User "and some overrides"}"
  - yes, literally enum: used as enum 
  - no magic, no single vo instances, just plain enum!!!
enum  BacklogItemStatus {Planed Scheduled Commited...}


U: instead enum you can create unique VO for each ST

ST from Agg
- 1 instance of Agg for ST type
- but think twice

c: ST (raczej) nie powinny byc utrzymywane w BC który ich używa
- q: why, bo to overloading "BC resp"?

- widly used ST should be def in specialized BC
- problem can be modifying such STs
- expose Aggs (changable!!)
  - on consument side as VO (immutable)
  - maybe globally expose as immutable VO?

shared immutable ST
- create service (DS) or factory for each shared ST
  - it reads data from shared database
- sample services are for PhoneNumber, PostalAddressType, CurrencyType
- service (or factory) returns then VO eg: Currency

acz use simplest approach = enums

VV recoms "enums based ST" also expose from service/factory
code for enum must be "generated" from DB



## 6.4 testing value objects

// quite regular infos
- tests write in a way that non-technical expert can understand id = use only UL


VVVVVVVVVVVVVVVVVVVVV CONT. HERE


## 6.5 implementation


Klasa biznes priority bp prezentuje wszystkie charakterystyki vo i więcej ( to jest Jak użyć vo jako Strategy pattern aka policy)

bp jest serializable
Przyda się To do serializacji vo np remote komunikacji lub zapisania  prrsystencji obiektu

Vv  daje zwykle 2 konstruktory do vo
Jeden służy do initu obiektu (wewnątrz używane selv delegation)
Drugi kopiuje
Ciekawe że robimy shallow copy,  nie kopiujemy  atrybutów tylko bierzemy ich referencje( jeśli nie są prymitywami)
Zauważ że Deep  copy lub clone  nie mają  sensu w przypadku vo,  bo wartości zawsze są takie same
Ale czasami Deep Copy jest wymagana ( na pewno nie w przypadku vo,  Tu jest kompletnie niepotrzebne) to można zrobić, zakodować to
A czy jest to upierdliwe

Ciekawe że konstruktor kopiujący potrzebny jest w testach,  w celu sprawdzenia czy niezmienność jest zachowana
 bierzemy jakieś vo
 robimy kopiey 
zmieniamy i porównujemy do pierwotnego vo 


O co chodzi z paterem Strategy/ policy
Masz w v o jakieś publiczne metody
Na  przykład metoda Total Value
Zbiera żadnych parametrów, a zwraca float
Włącz nie działa ona bezpośrednio na atrybutach wywołuje inne metody które zwracają dane /float  i operuje dopiero wartościach
Strategii polega na tym że W każdej chwili można nadpisać dowolną z tych wewnątrz używanych metod
No nie jest to Rocket Science he he
Obecnie bp vo nie ma wydzielonego interfejsu (separated interface) ale pewnie będzie miało
I będzie wiele implementacji vo i wtedy będzie strategy działało

Gettery
VV odradza tworzenie nazwy metod typu get something
Jeśli zwykle na przykład miałeś metodę getValueX
To teraz pisz zwykłe valueX()
Bo jest to bardziej human-readable

VV uważa że specyfikacja Java Bean miała zły wpływ na projekt obiektów,  DDd w szczególności
Przykładem dobrego  projektu jest klasa string
Ma ona kilka metod typu get( okej wszystkiego naprawisz)
Ale główne metody mają postać typu
chart At,  index of,  length
Ciekawe że VV używa seterów na przykład set Ratings ( tylko w konstruktorze,  niewidoczne publicznie) 
A potem ma metodę ratings,  widoczna publicznie(bez get) 
Druga ciekawostka,  że widać że atrybut prywatny w vo,  może być  upubliczniony 

W ramach implementacji musisz uwzględnić  na pisanie metod
equals
hash code
to string
Ale to klasyka


Uwaga uwaga jest trzeci konstruktor, bez parametrów,  na potrzeby hbm,  ciekawostka widoczność protected,  schowany w skrócie




## 6.6 persisting value objects

66 persisting vo

Zwykle Jesteśmy zainteresowani persystoowaniem vo razem z agregatem do którego jest podpięty
We wszystkich przykładach zakładamy że vo jest podpięty pod agregat
Zakładamy że agregat jest dodawany lub czytany przez repozytorium,  a powiązane vo jest zapisywane i odczytywane razem z  entity która zawiera Vo

Zwykle używane orm
Ale to dodaje trochę  skomplikowania trzeba zmapować klasę na tabelę, atrybuty na kolumny
Są opcje no SQL oraz Key-Value stores( obie całkiem reluable and enterprise ready)
Ogólnie Various stores mega mocno upraszczają przechowywanie agregatów
W tym rozdziale mamy Focus na orm,  trochę o Stores jest w rozdziale 12 repositories




### 6.6.1 reject undue influence of data model leakage

661 Reject undue...

Najczęściej Vo jest zapisywane w bazie w postaci zdenormalizowanej
To jest, w tej samej tabeli zawierająca v o entity
To proste i przyjemne scenariusz  persisting data

Czasem jednak vo jest zapisywane jako entity bazy danych
Ma własną tabelę,  własny klucz Główny
Dzieje się tak głównie gdy mamy encje z zagnieżdżoną kolekcją Vo

Niezależnie od scenariusza, mechanizm zapisu do bazy nie powinien wpływać na model domenowych
Więcej,  model danych  powinien być Driveowany przez model domeny,  nigdy odwrotnie
Chociaż jak zwykle są wyjątki

Ale czasem ważna jest struktura modelu danych,  modelu bazy
Musimy zachować integralność referencyjną
Trzeba wspierać raportowanie
etc
To trzeba zaadresować
Większość większość twierdzi że raportowanie nie powinno działać na bazie produkcyjnej,  i powinna mieć wyspecjalizowane dedykowany Design modelu danych

Jednak finalnie niezależnie od modelu danych( kluczy integralności indeksów Entity..)  powinno to wszystko wpływać na model obiektowy




### 6.6.2 orm and single value objects

662 orm and Single Value Object

Zapis jednego vo do bazy jest zwyklr prosty
Idea-  zapisać vo w wierszu entity,  ale we własnych kolumnach( każdy atrybut ma swoją kolumnę)
Zwykle kolumny mają nazwy pozwalające wyróżnić kolumny należące do vo
Zobacz w przykład nazwę na stronie 2 51
Vo Business priority ratings  ma atrybuty Benefit i cost
Kolumny w  entity nazywają się  Business priority rating benefit(  rozdzielone podkreśleniem)
Dokładna na stronie  252 na dole strony 

Hbm Użyj elementu component do zamodelowanie tego scenariusza
Komponenty z hbm pozwala na zmapowanie bezpośrednio do tablice entity naszego Vo

Ciekawostka
W przykładzie VV jest zagnieżdżone jedno vo w drugie vo
Co w mapowaniu hbm za moderowany jest jako zagnieżdżenie jednego komponent w drugi komponent

Zauważ że nie ma w model domeny żadnych wpływów z bazy





### 6.6.3 orm and many values serialized into a single column

663 orm and many values...

Jest to sytuacja kiedy wiele vo mapujemy  przy pomocy orm
Lista vo obiektów jest przypięta do entity jest reprezentowana jako Set or list

Możliwość 1
Serializować kolekcje do reprezentacji tekstowej i zapisać w jednej kolumnie
Ma to wady ale czasami da się to rozwiązanie zastosować
Wady
 szerokość kolumny,  czasami nie wiesz ile elementów jest w kolekcji,  albo Jaka jest wielkość pojedynczego obiektu k( to szczególnie się przydarza gdy masz Strings wewnątrz Vo   nie ma maksymalnej wielkości tych stringów
Ciekawe że w my SQL maksymalna wielkość kolumny do 65000 znaków, Jednocześnie jest to maksymalny rozmiar wiersza
w Oracle varchar2  ma maksymalną wielkość 4000

Konieczność zapytanie
I będziesz mógł używać tych vo w zapytaniach SQL
Bo są stringami
A czy to raczej rzadki Case

Woda 3:   Wymaga to implementacji hbm Custom user Type 
Według VV nie jest to dużym problemem w stosunku do wcześniejszych






### 6.6.4 ORM and many values backed by database entity
- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table
- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects
- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)