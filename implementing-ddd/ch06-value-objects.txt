# 6 VALUE OBJECTS

6 Value Object

- vo są czesto "przyćmione" przez e
- gdziekolwiek możliwe powinieneś użyć vo zamiast e
- more nawet projekt e powinien skupiac sie na serwowaniu vo

- vo skupiają się na mierzeniu, kwantyfikowaniu (okreslaniu ilosci), opisywaniu 
- a to łatwe do kodowania, testowania, optymalizowania i utzymania (wow, chyba all plusy)

ciekawostka
- popularnym podejsciem jest zamodelowanie domeny jako struktury tabel (1 obiekt domeny = 1 tabela) i powiazanie tabel kluczami
- efektem jest mocno zszyty wielki graf obiektow, przeladowany set/get-erami
- to zlo

- obiekt vo towrzymy, przekazujemy klientom i zapominamy o nim
- to rewolucjonizuje podejście do programowania
- wg VV to jak przejście z old lang na lang uzywajacy GC!

- użyj vo jeśli interesuja cie tylko o atrybuty
- nie dawaj identity

- beginners często nie wiedza czy użyc e czy vo
- ale profs tez tak maja ;]


## 6.1 value characteristics

- możliwe że powinieneś używać VO znacznie częściej niż do tej pory


### 6.1.1 measures, quantifies or desc

- VO nie modeluje rzeczy, przedmiotu z UL
- VO mierzy, kwantyfikauje lub opisuje rzecz/przedmiot
- np osoba (przedmiot/rzecz) ma
  - wiek (wiek to pomiar, kwantyfikacja)
  - imię (to opis)
- troche to podobne do Conceptual Whole



### 6.1.2 immutable

- c: VO baaaardzo rzadko ale moze byc zmienne (pisze o tym EE)

- od razu po utworzeniu - obiekt staje się z kompletnie niezmienny
- wartości tworzące VO podajemy w konstruktorze
  - acz przy odtwarzaniu z DB, JSON, XML ... init moze nastapic pozniej

obvious ale
- vo mogą referować do innych vo
- metody modyfikujące stan vo nie mogą być dostępne publicznie, wywołane po constr

VO może mieć ref do E
- VV tego nie zaleca
  - bo jak entity zmieni stan, to zmienia się również vo, a to łamie zasadę niezmienności
- dopuszczalne tylko jeśli znacznie uprości to kod
- nawet w takim case klient nie może bezpośrednio wołać metody z e 
   - woła metody z vo (cos jak Aggr)
   - a Te nie powinny modyfikować stanu vo
    - wiec to dopuszczalny

- jeśli projektujesz obiekt który musi zmienic stan 
- to może lepiej wowczas kompletnie wymienic obiekt


### 6.1.3 conceptual whole (CH)

- VO agreguje (zwykle) wiele powiazanych atrybutów 
- każdy jest ważną częścią całości, tylko razem tworzą pomiar, kwantyfikuja ...

- c: pattern CW opracowal cuningham

- przykład: 50usd
- dwa atrybuty
  - osobno znaczą coś innego, razem tworzą CH - wyznaczającą wartość pieniężną przedmiotu
class Thing {
  MonetaryValue worth;
}


VVVVVVVVVVVVVVVVVVVVV CONT. HERE

Przy okazji ciekawe przykład
VV w klasie thing of worth  zamieścił dwa atrybuty  typu Vo
.  omówiony monetary Value
. thing name!
Tak nazwa przedmiotu ma vo a nie string
To oczywiście zależy od  wymagań,  ale jeśli nazwa ma jakieś zachowania na przykład CapitalizedName ( która dba o to by Pierwsza litera w nazwie była duża a reszta zawsze była mała)  logikę warto schować w vo
Ale to ważne by pamiętać że używamy tylko kiedy mamy rzeczywiście jakieś dodatkowe zachowania na danym atrybucie

To oczywiste ale zauważ że cały obiekt jest tworzone w jednej operacji,  w konstruktorze
To musi być zawsze zagwarantowane,  cały obiekt tworzony jest w jednej operacji





### 6.1.4 replacebility

614 replac...

Vo Should Be Held as reference  by entity
If vo Changes,  completely  Wymień to na nową wartość

Ciekawostka, kompletna wymiana jest realizowana podczas ustawiania wartości prymitywów
Na przykład ustawiasz INT z 3 na 5  to wymieniasz 3 na 5

W przypadku wymienialności
Po prostu w momencie potrzeby zmiany Vo  podstawiać pod zmienną ( klasy lub zmienną w metodzie) nowy obiekt z nowym stanem, cokolwiek tam potrzebujesz zmienić zmieniasz wszystko

Ciekawe że to podejście może wydawać operatywne Szczególnie jeśli zmiany są częste,  a obiekt skomplikowany,  a zmiana w jednym miejscu 
ale da się to obejść  przez tak zwane Side Effect free  behavior





### 6.1.5 value equality

615 równość wartości

Zauważ że w systemie może być bardzo wiele instancji obiektów które z logicznego punktu widzenia są równe

Zauważ że teoretycznie mógłbyś podmienić po zamieniać referencja i jeśli obiekty nadal byłyby równa to nawet jeśli są to różne instancje to nie zmienia to zachowania aplikacji,  podmiana zamiana obiektów nic nie zmienia

Porównanie robimy przez porównanie typów a potem atrybutów obiektów
Jeśli oba są takie same to obiekty są równe

Implementacja porównania
Override equals()
Wewnątrz Porównaj  klasy i 
każdy atrybut z klasy Vo

Ciekawe że VV odczytuje atrybuty przez gettery
To uzupełnienie,  druga strona Self encapsulation
Wcześniej widać było tylko setery
Poproszę,  tu używa getrów

Ciekawostka,  equals  porównuje wewnętrzny stan,  wewnętrzne atrybuty
Dzięki temu porównanie będzie dobrze działało ( w przypadku klasy Vo FullName,  z metodą CapitalizedName)  niezależnie czy aktualnie patrzymy na zwykły name czy Capitalized,  porównanie zadziała prawidłowo

Ciekawostka kiedy v o kiedy e
Jeśli obiekt nie wymaga Unique identity,  do it as Vo






### 6.1.6 side-effect-free behavior

616 Side Effect free behavi

Pattern od EE

Ciekawostka funkcja to operacja obiektu która nie modyfikuje jego stanu

Oczywiście Sound Effect free metody to są funkcje

Wszystkie metody obiektu vo muszą być funkcjami

Ciekawostka funkcyjnych językach dopuszczalna jest tylko Sound Effect free behavior,   to znaczy wszędzie na wejściu i wyjściu są vo

Ciekawostka mayer i fowler  nazywają funkcje metodami query  pattern CQS ( Command q separ) 

Przykłady 
klasa fullname,  metoda 'with middle Initial'  zwraca zupełnie nową instancję  fullname,  dodatkowo zainicjowano atrybutem middle 

Ciekawostka czy vo może modyfikować e przekazana jako parametr W metodzie vo
Z punktu widzenia  niezmieniania stanu vo to metoda vo która modyfikuje e jest dopuszczalna
Pytanie czy łatwo takie coś przetestować,  a nie łatwo ani  trudno
Najlepiej Jeśli taka metoda zwraca rezultat który  na bazie którego  encja sama siebie zmodyfikować,  a metoda najlepiej niech nie modyfikuje e

A czy jest to dopuszczalne to Starajmy się tego unikać
Przykład strona 230
Obiekt vo BusinessPriority.  priority of( Product) 
Gdzie Product to encja
Metoda zwraca float priority (wyliczony na bazie encji) 
Problemy z tym kodem
. Vo zależy od e,  więc vo musi rozumieć e i jego strukture
Jeśli to możliwe unikaj tego,  vo najlepiej ograniczyć do znajomości samego siebie i swoich atrybutów
.  osoba czytająca ten kod  nie wiem które pole z Product jest używane,  lepiej gdyby konkretne vo Product było  wyprodukowane i podane do  nasze metody,  byłoby to dużo bardziej explicit,  i model byłby bardziej czysty
.  nie można łatwo stwierdzić że entity niemodyfikowana przez vo

Optymalne dla powyższego przykładu byłoby kod ze strony 231

Bardzo bardzo rzadko ale jednak zdarza się że obiekt musi być u mutable.   w takiej sytuacji raczej staraj się używać vo z Side Effect free behavior  albo entity






## 6.2 integrate with minimalism

## 6.3 standard types expressed as values

## 6.4 testing value objects

## 6.5 implementation

## 6.6 persisting value objects

### 6.6.1 reject undue influence of data model leakage

### 6.6.2 orm and single value objects

### 6.6.3 orm and many values serialized into a single column




### 6.6.4 ORM and many values backed by database entity
- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table
- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects
- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)