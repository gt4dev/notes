# 6 VALUE OBJECTS

6 Value Object

- vo są czesto "przyćmione" przez e
- gdziekolwiek możliwe powinieneś użyć vo zamiast e
- nawet same e powinny skupiac sie na serwowaniu vo

- vo skupiają się na mierzeniu, kwantyfikowaniu (okreslaniu ilosci), opisywaniu 
- dzieki temu to łatwe do kodowania, testowania, optymalizowania i utrzymania (wow, chyba all plusy)

ciekawostka
- popularnym podejsciem jest 
  - zamodelowanie domeny jako struktury tabel (1 obiekt domeny = 1 tabela) 
  - powiazanie tabel kluczami
- efektem jest zlo
  - mocno zszyty wielki graf obiektow
  - przeladowany set/get-erami

- obiekt vo towrzymy, przekazujemy klientom i zapominamy o nim
- to rewolucjonizuje podejście do programowania
- wg VV to jak przejście z old lang na lang uzywajace GC!

- użyj vo jeśli interesuja cie tylko o atrybuty
- bez identity etc.

- beginners często nie wiedza czy użyc e czy vo
- ale profs tez tak maja ;]


## 6.1 value characteristics

- możliwe że powinieneś używać VO znacznie częściej niż do tej pory


### 6.1.1 measures, quantifies or desc

- VO nie modeluje rzeczy/przedmiotu z UL
- VO mierzy, kwantyfikauje lub opisuje rzecz/przedmiot
- np osoba ma
  - wiek (wiek to pomiar, kwantyfikacja)
  - imię (to opis)
- troche to podobne do Conceptual Whole


### 6.1.2 immutable

- c: VO baaaardzo rzadko ale moze byc zmienne (more w EE)

- od razu po utworzeniu - obiekt staje się z kompletnie niezmienny
- wartości tworzące VO podajemy w konstruktorze
- acz przy odtwarzaniu VO z DB, JSON, XML ... init moze nastapic pozniej

obvious ale
- vo mogą referować do innych vo
- metody modyfikujące stan vo nie mogą być 
  - publicznie
  - wywołane po constr

VO może mieć ref do E
- VV tego nie zaleca
- jak entity zmieni stan, to zmienia się również vo, a to łamie zasadę niezmienności
- dopuszczalne tylko jeśli znacznie uprości to kod
- nawet w takim case klient nie może bezpośrednio wołać metody e 
  - woła metody vo (cos jak aggr)
  - u: metody te nie modyfikuja stanu vo!
    - wiec to dopuszczalny

- jeśli projektujesz obiekt który musi zmienic stan 
- to rozwaz czy lepiej kompletnie wymienic obiekt

### 6.1.3 conceptual whole (CH)

- VO zawiera (najczesciej) wiele atrybutów 
- każdy jest nieodlaczna częścią całości, tylko razem tworzą pomiar, kwantyfikuja ...

c: pattern CH opracowal Cuningham

przykład: 50usd
- dwa atrybuty
  - razem tworzą CH - okreslaja wartość pieniężną
  - osobno kazdy znaczy coś innego

ciekawy przykład
class ThingOfWorth {
  MonetaryValue worth;
  ThingName name;  <<< tak, name w VO a nie string!
}
- warto uzyc VO zamiast primitive (string, ...) jeśli wokolo V jest "zachowanie"
- zbuduj VO i zamknij zachowanie w metodzie (schowaj jego logike przed klientami)
- eg: ThingName.CapitalizedName()
  - dba 1st letter byla duza reszta była mała

obvious but
- cały vo jest zawsze tworzony w jednej operacji - w konstruktorze


### 6.1.4 replacebility

- vo typically is held (as reference) by e
- if vo changes - completely change vo (update e's reference)


c: full relacement is done during setting primitives
eg: when setting int with 3 to 5 - you replace it (not update)

whatever you need to update in vo (1 value, many values ..) - rebuild whole object
- build whole new vo
- set this new object in place of 'old'

replacebility moze sie wydawac nieefektywne dla malych i czestych zmian
ale da sie to zoptymalizowac
przez uzycie side effect free behavior


### 6.1.5 value equality

- w app może istniej wiele roznych VO które z logicznego punktu widzenia są równe
- teoretycznie mógłbyś zostawic 1 taki VO i wstawic ref do niego wszedzie w app - nie zmieni to zachowania app

- porównanie robimy przez porównanie 
  - typów 
  - atrybutów (cmp all, 1-by-1)
- if both are equal - objects are equal

c: VV in equals() reads values by getters
- so VV uses full self-encapsulation (setters in consructors)

c: equals uses all INTERNAL attrs to cmp objects
- so regardles of which eg. FullName is used (CapitalizedName(), Initials() ...)
- cmp is done correctly 

vin: if object doesn't req unique identity - do it as VO, else as E


VVVVVVVVVVVVVVVVVVVVV CONT. HERE


### 6.1.6 side-effect-free behavior

616 Side Effect free behavi

Pattern od EE

Ciekawostka funkcja to operacja obiektu która nie modyfikuje jego stanu

Oczywiście Sound Effect free metody to są funkcje

Wszystkie metody obiektu vo muszą być funkcjami

Ciekawostka funkcyjnych językach dopuszczalna jest tylko Sound Effect free behavior,   to znaczy wszędzie na wejściu i wyjściu są vo

Ciekawostka mayer i fowler  nazywają funkcje metodami query  pattern CQS ( Command q separ) 

Przykłady 
klasa fullname,  metoda 'with middle Initial'  zwraca zupełnie nową instancję  fullname,  dodatkowo zainicjowano atrybutem middle 

Ciekawostka czy vo może modyfikować e przekazana jako parametr W metodzie vo
Z punktu widzenia  niezmieniania stanu vo to metoda vo która modyfikuje e jest dopuszczalna
Pytanie czy łatwo takie coś przetestować,  a nie łatwo ani  trudno
Najlepiej Jeśli taka metoda zwraca rezultat który  na bazie którego  encja sama siebie zmodyfikować,  a metoda najlepiej niech nie modyfikuje e

A czy jest to dopuszczalne to Starajmy się tego unikać
Przykład strona 230
Obiekt vo BusinessPriority.  priority of( Product) 
Gdzie Product to encja
Metoda zwraca float priority (wyliczony na bazie encji) 
Problemy z tym kodem
. Vo zależy od e,  więc vo musi rozumieć e i jego strukture
Jeśli to możliwe unikaj tego,  vo najlepiej ograniczyć do znajomości samego siebie i swoich atrybutów
.  osoba czytająca ten kod  nie wiem które pole z Product jest używane,  lepiej gdyby konkretne vo Product było  wyprodukowane i podane do  nasze metody,  byłoby to dużo bardziej explicit,  i model byłby bardziej czysty
.  nie można łatwo stwierdzić że entity niemodyfikowana przez vo

Optymalne dla powyższego przykładu byłoby kod ze strony 231

Bardzo bardzo rzadko ale jednak zdarza się że obiekt musi być u mutable.   w takiej sytuacji raczej staraj się używać vo z Side Effect free behavior  albo entity






## 6.2 integrate with minimalism

## 6.3 standard types expressed as values

## 6.4 testing value objects

## 6.5 implementation

## 6.6 persisting value objects

### 6.6.1 reject undue influence of data model leakage

### 6.6.2 orm and single value objects

### 6.6.3 orm and many values serialized into a single column




### 6.6.4 ORM and many values backed by database entity
- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table
- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects
- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)