# 6 VALUE OBJECTS

## 6.1 value characteristics

### 6.1.1 measures, quantifies or desc

### 6.1.2 immutable

### 6.1.3 conceptual whole

### 6.1.4 replacebility

### 6.1.5 value equality

### 6.1.6 side-effect-free behavior

## 6.2 integrate with minimalism

## 6.3 standard types expressed as values

## 6.4 testing value objects

## 6.5 implementation

## 6.6 persisting value objects

### 6.6.1 reject undue influence of data model leakage

### 6.6.2 orm and single value objects

### 6.6.3 orm and many values serialized into a single column




### 6.6.4 ORM and many values backed by database entity
- najprostszy sposob na zapisanie kolekcji values w bazie przez ORM (esp. HBM) 
- traktujemy VOs jako encje bazy danych
- VO z "model PoV" musi byc wolny od technikaliow bazy, ORM, ...
- pomaga tu pattern Layer SuperType (LST)
- VV wprowadza klase LST IdentifiedDomainObject
- przechowuje ona pole "klucz encji"
   - niewidoczny "w domenie" bo jest private/protected
- VV dodatkowo wprowadza klase "IdentifiedValueObject (extends IdentifiedDomainObject)"
  - klasa nie dodaje zadnego kodu
  - ma znaczenie tylko jako dokumentacja - explicite wyraza intencje modelowania VO
  - n: IDO ma tez wersje dla encji (see CH5, Entity extends IdentifiedDomainObject)

przyklad
- agregat Group zawiera kolekcje VOs typu "GroupMember : IdentifiedValueObject"
- klasa Group jest czysta od technikaliow - po prostu ma kolekcje GroupMember-s
- HBM cfg
    <class name="Group" ...
      <set name="members" ...
        <one-to-many ...
    
    <class name="GroupMember" ...
      <id ..>
      <property ..>
      <component ..>   <-- c: bo GroupMember zawiera inne VO
          
- jak robisz replacement kolekcji - to wywolaj wczesniej members.Clear()
  - HBM usunie wowczas stare obiekty
  - btw. kolekcja jest impl. przez HBM


### 6.6.5 ORM and many values backed by join table
- HBM zapisuje kolekcje w join table (what is hbm-join-table?)
- VO-s sa zapisane w dedykowanej tabeli
- VO nie potrzebuje wlasnego klucz
- kluczem obcym jest ID "parent encji"
- zaleta: obiekt domenowy VO nie musi miec (ukrytego) klucza zeby join'owac z parent (acz ma klucz parenta)
- w HBM to mapowanie robisz przez <composite-element>
- problemy
  - (chyba) zaden z VOs nie moze byc null'em - bo wartosci identyfikuja VO
  - VO nie moze zawierac innej kolekcji - bo glowny VO nie ma ID'a - wiec nie ma jak join'owac
- wyglada ok, ale VV rekomenduje podejscie "backed by database entity", a to odradza


### 6.6.6 ORM and Enum as state objects
- use it to save in DB: standardowy typ lub enum
- HBM nie wspiera enumow (as of iddd publish date)
- zapisuj enum'y przez HBM custom types (najczesciej jako stringi)
- przyklad GroupMemberType (nested in GroupMember)