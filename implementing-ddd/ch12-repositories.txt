# CH12 REPOSITIORIES

wg EE
- provide r only for aggs that needs global access
- provide illusion of 'in-memory' access
- access r through interface

- czasem jak kilka aggs ma wspolna hierarchie - to sa wyciagane z 1 repo

c: to idea vv - podzial repos na 
- collection
- persistance 
.. oriented


## 1 COLLECTION ORIENTED REPOS


- COR to klasyczne podejscie z DDD
- repo nasladuje zachowanie [kontrakt] kolekcji
- avoid in r any notion of saving data

standardowe zachowanie kolekcji to
- po dodaniu obj do kolekcji - jest on tam caly czas
- jak wyciagasz i zmieniasz obj z kolekcji - kol NIC o tym nie musi wiedziec
  
sample
interface Collection {
  add
  addAll
  remove
  removeAll
}

typowe zachowania repo
- jak 2nd time dodajesz obj do HashSet - to old obj. jest nadpisywany
  - esp: nie leci excep 
- podczas get obj gdy obj nie ma - dostajesz null [takze dla GetEntityById(id)}
  - esp: nie leci excep
- rzucaj excep jesli query params sa nieprawidlowe ["poza zakresem"]

- don't save objs already held by repo
- po get obj z repo i modyf - nie wstawiaj go z powrotem do repo

c: vv troche sp*l
po co tu rozszerzal HashSet? 
class MyRepo extends HashSet<Calendar>
  add(Calendar c) {..}
}


persiting mech
- pers. mech - musi umiec rozpoznac ze obj zostal zmieniony
- many possible impls - below only 2
- oba podejscia maja rozna wydajnosc
- w obu cases - sledzenie zmian jest niezauwazalne dla klienta
  - user wola tylko 'commit'

1 implicit copy on read
- poczas reconstituting [from store] are created objects
  - private copy
  - for use by client
- on commit [called by client]
  - mech cmp both objs
- jak sa diffs -> changed objs are flushed to store
- c: przy lazy loading - cmp'ed are only [lazy] loaded elems of e

2 implicit copy on write
- przy reconst. 
  - obj wrapowany jest 'light proxy' 
  - returned to client
- klient wola metody na "proxy"
  - pers mech zna widzi te calls
  - docelowe metody tez sa wolane
- on 1st proxy method call - PM robi kopie obiektu i oznacza go jako dirty
- on commit - all dirty objects are flushed to db


### 1.1 HIBERNATE IMPL


- n: hbm tworzy collection oriented repos

typowy interf
interface CalendarRepository {
  void addCalendar(Calendar cal);
  void addAll(Collection<Cal> cals);
  void remove(Cal cal)
  void removeAll(Collection<Cal> cals)
  ..
}
- interface mimics collection behaviour
- jak usuwasz - to dajesz cala encje
- jak dodajesz to zwracany jest void [nie id ..]
  - std kolekcja zwraca boolean
  - VV zwraca void bo
    - zwracanie true [jako ack sukcesu] jest pozorne
    - real success of add/remove/.. mozna oglosic dopiero po tx commit
- lekko dyskusyjne jest posiadania metod add/remove[All]
  - bo aggs najczesciej zmieniamy pojedynczo

usuwanie aggs
- jak pobierzesz cos z repo i ktos ma do tego ref - to nie mozesz tego obiektu 'usunac' ["anulowac" ref ..]
- mozesz ew. oznaczyc encje flaga 'removed' etc

finders
interface CalendarRepositrory {
  Calendar calendarOfId(CalId)
  ..
}
- if szukamy po id i nic nie znajdujemy - to zwroc null [a nie excep]
- to naturalne w kolekcjach


subfolder impl w modelu
- czasem umieszcza sie impl of repo w domain.model
  mybc.domain.model.calendar.impl
- it's popular pattern in java
- teoret. sam model nadal jest [nie ma technikaliow]
- acz "typowo" impl. interfejsu jest w ns:infrastructure
g: pewnie da sie tak robic dla innych 'technikaliow' [klient poczty, stub serwisu ..]
  - folder $root
    - logika bazujaca na interfaces [wolna od techs]
    - czysty UL domenu [nawet technicznej]
  - folder $root/impl
    - technikalia z poza UL

delete in hbm
- metoda remove(Calendar c) pobiera pelny obiekt [nie tylko id]
- bo impl. calls: session().delete(wholeObject)
- ale hbm ma kilka ways for deletes

cascade delete
- albo przez config [set cascade]
- albo recznie w repo.remove(Parent parent) {
  session.delete(child)
  session.delete(parend)
}


// hbm wymaga poznania
// hql, full objects w hql [jak to dziala, co hbm match'uje?] ...


### 1.2 CONSIDERTIONS TO TOP-LINK

- w top-link jest oddzielnie session, unit of work
- w hbm jest to "polaczone" w session [and tx'y]

repo interface musi miec dodatkowa metode

way1: MyRepo.editingCopy(Calendar c):Calendar
- metoda rejestuje c w unit of work
- zwraca proxied object, ktory TL monitoruje [na zmiany]
way2: MyRepo.UseEditingMode():void
- po wywolaniu tej metody all gets from repo return objects sa 
  - wpiete w unit-of-work
  - proxied/monitored

- to nadal styl 'collection oriented repo'
- chociaz juz dosc mocne przegiecie z dodatkowym callem


## 2 PERSISTENCE ORIENTED REPOS


- use when pers mech can't detect changes
- sample case: NoSQL key-value data-store, oracle coherence

- idea: all changed objects you pass to repo's method save(changedObject)

- save(..) moze byc w postaci put(..)

global n
- obiekt musi miec identity - zeby repo moglo go zapamietac/potem zakualiziwac

takie repo mimics Map/HashMap

key-value store dziala jak Map
ale zasadniczo 
  - kazde repo tak dziala
  - kazdy map to store typu key-value

- zawsze wolaj save/put zeby utrwalic zmiane
- wynika to ze sposobu dzialanie unit of work w takich repos

g/n
- repo w add(MyE) bierze caly agg [a nie: id + reszta]
- potem w impl. mozesz wydzielic key wstawic do mapy<key, my-e>


### 2.1 COHERENCE IMPL


interface ProductRepository {
  save(Product p)
  saveAll(Colection<Product> ps)
  productOfId(pId)
  ..
}  

flow
- po modyfikacji agg 
- call save(..) zeby utrwalic zmiane
  p1 = new Product(..)
  repo.save(p1)

  p2.modifySth(..)
  repo.save(p2)


c
- vv czesto w AnyRepo.nextId() zwraca random UUID
- nie uzywa db, caches ...


### 2.2 MONGO-DB IMPL



## 3 ADDITIONAL BEHAVIOUR



## 4 MANAGING TRANSACTIONS



### 4.1 A WARNING



## 5 TYPE HIERARCHIES



## 6 REPO VS DATA ACCESS OBJECT



## 7 TESTING REPOS
