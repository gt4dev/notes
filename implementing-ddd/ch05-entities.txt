# CH5 ENTITIES

- devs mają tendencję do skupiania się na danych a nie domenie
  - nie buduja "rich behaviors" 
  - skupiaja sie tylko na danych, atrybutach, asocjacjach
- to bez sensu - bo sa tool'e do generowania kodu z modelu db


## Why We Use Entities

- use entity 
  - to express individuality of object
  - when you want distinguish object from others
- entity is identified and can change (even heavely!) in long time
  - final E can be totally diff from 'start version'
  - but still has the same identity

that diffs E from VO
- unique identity
- mutability

n: devs often overuse Es, where VO would be better than E
if you "overuse E" then maybe you need CRUD not DDD?


## Unique Identity (UI)

UI = base of entity

n: on start of projecting E
- focus on
  - defining identity
  - ways of finding, matching Es
- maybe add important behaviours for E (and attrs required by it)
- forget about rest (other attrs/behaviours)

- human readable identities can be used for ease finding/matching Es

use VO as holders for I
- VO is immutable = assure I stability
- VO can have methods
  - this encapsulate knowlegde (eg. can extract date-time from I)
  - knowlegde is not leaking to clients

typical strategies of creating I (in order: easy -> hard)
- user provides vaules which create UI (app assure that values are ok)
- aplikacja generuje identity
- persistence store zapewnia identity
- inny BC już mam entity z UI i my je używamy



### User Provides Identity

user ustala wartosci I
- albo sam wprowadza (n: human readable)
- albo wybiera z listy

problem
- podane przez user wartości mogą być bledne, user bedzie chcial je poprawic potem
- a identity musi być niezmienne
- choc czasem można pozwolić user'owi na zmiane

chyba lepiej dane od user'a zapisać w zwykłych properties
- nie rob z nich UI



### Application Generates Identity

to quite reliable sposoby generowanie unikalnych identity
trzeba uważać w klastrach i rozproszonych węzłach

zwykle do wyliczenie ID używane są
- czas węzła w milisekundach
- IP węzła
- ID obiektu factory ktory generuje ID
- random number

- id zwykle ma 128 bitów unique values
- reprezenowanych w 32B textu (hexach) lub 36B z hyphenami

c: w Java UUID mozna generowac na 4 sposoby (random, z "input text" ..)

- czasem (rzadko) problemem jest rozmiar ID pamięci
- stosuj wowczas ID'y z bazy (8B Long, 4B int)

- dla lokalnych (w ramach Agg) entity można skrócić identity do kilku bajtów
- acz "aggregat root" wymaga global unique identity


custom/combined identity - example
- join in ID a few element, np: "APM-20210324-123abc" gdzie np
  - APM = TLS nazwy BC'a
  - data utworzenie ID
  - krotkie UI
- takie ID moze byc HumanReadable
  - co jest wazne przy komunikacji z klientem/czlowiekem
- ID takie trzymaj w VO (z pomocniczymi metodami eg MyId.GetDate():MyDate


- kod tworzenie UI umiesc w repo np
  MyAggRepo.NextIdentity():MyAggId
- q: gdzie metoda do gener ID dla non-agg/local?
  - a: pewnie w repo 'root/owning aggregatu'


### Persistence Mechanism Generates Identity

- c: unique values = f(type)
  int =  4B = 2*10^9
  long = 8B = 9*10^18

- zaleta: zawsze bedziemy miec unikalna wartosc ID
- wada: wydajnosc ("in app ID" is much faster)

fix for performance = prefetch more IDs and cache
- problem: gaps in IDs if server restarts
- trying to restore IDs from "losts/gaps" can be more expensive than worth

impl late ID - typical way
- object gets ID after insert to DB
- hmb config
  <id name="PropertyInClass" type="long" column="product_id">
    <generator class="sequence|or|native" ...
  </..

impl early IDs
- yes, early is possible for "DB src"
- create in repo method NextIdentity():ProductId
- NextIdentity can create and return "next value" from DB sequence/cache/...


### Another Bounded Context Assigns Identity

- n: see integration details are in chapters: 3-ctx-maps, 14-integr-bcs

flow
- 1st: find partucular identity in BC2 by
  - API exposed by BC2
    - searching, fetching data matching criterias (email, tax id ..)
  - show this data (if many rows) to user
  - user picks 1 "row" - get identity from it
- use this identity locally!!! in your BC1

problems
- data in BC2 can heavily change and maybe these changes must visible in BC1?
- BC1 should listen for Domain Events from BC2 (so changes can be updated)
- sometimes BC1 modify "imported data" and must send (by DEvents) to BC2

- it's hardes way of generating identity
  - out entity (its identity) depends on outer system
- pick as last way



### When the Timing of Identity Generation Matters

generowanie identity moze nastapic
- early - as part of constructing object
- late - podczas persystencji obiektu

- zaleznie od reqs - mozna stosowac oba
- VV recommends setting ID early

flow for late ID
- client 
  - creates object (w/o ID)
  - add it to repo
- repo persist obj
- ID is generated (by DB, but not only)
- ID is assigned to entity object

"late ID" is problematic 
- with domain events
  - when obj is created - we want to generate event
  - but ID is not yet assigned
  - thus for DE use early ID
- when Entity is in Set
  - in Set there can be only 1 entity without ID
  - thus
    - either use early ID
    - or override equals - so distingiush entities by attributes (VO-like)


### Surrogate Identity (SI)
- identyfikator zastepczy

- typowy ORM (eg: HBM) preferuje natywnych primer identity z baz danych
- on DB side it can be: numeric, sequence; 
- on VM side: long, int
- domena czesto wymaga innego identity np: guid, user-name ...
  
easy solution solution - use 2 identities
- 1st - from domain (and fulfilling domain reqs)
- 2nd - surrogate identity - spelnia ORM reqs

impl
- add to MyEntity field: "long id" (or int ..)
- add to my_entity column: "id (primary key)"
- set HBM mapping

hide & optimize SI
- hide SI on client/model side
- create "abstract class IdentifiedDomainObject" with field "private long id"
c: it's LaterSuperType pattern (from EAA)
n: in CH10-Agg VV creates "EntityBase" with a above + optimistic concurency

c: VV ustawia db constranins w table
- SI - primary na kolumnie: id
- domain identity - unique na: tenant_id_id, username
n: DI tez jest zamodelowane w DB

n: przykladzie User
- identyfikator domenowy składa się z dwóch pol (TenantId, username)
- pola te nie wyrozniaja sie z kodu klasy User (ok, poza uzyciem ich w equals)
- conc: client E (na bazie jej API) "musi zgadnac" co jest jej ID
- w DB jest zalozony unique key - ale more to protect data than identify

- SI w DB can be used to keep referential integrity miedzy tabelami
- q: tez miedzy agregatami?


### Identity Stability

- in most cases: identity must be stable through the whole entity life

protect identity
- make setters, fields protected/private (so client can't change it)
- set identity fields - only by (private) setters 
  - which checks is it 1st field init or 2nd
  - if 2nd - throws excep


## Discovering Entities and Thier Intrinsic Ch-cs

- UL z BC daje slownictwo do projektowania modelu
- UL musi być wypracowany z ekspertami i przez analize wymagań
- finalnie caly zepol porozumiewa sie "uzywajac UL"
- c: mapowanie nouns/verbs na klasy/metody to ZBYT DUZE uproszczenie projektowania modelu

- on start: mozna zapisać UL jako słownik pojęć i zbiór prostych przypadków użycia
- finalnie: UL jest wyrazany TYLKO przez kod (bo trudno trzymać sync miedzy docs i kodem)


### Unconvering Entities and Properties

sposoby zmiany wartosc E:
- primitive property is changed
- whole VO is replaced

przyklad: w encji User
- UnId jest stale (tu: TenantId, username)
- all other data is changing 'in time' (Person, ..)

- VV uzywa primitive string to keep username 
- cause here is no any special behavious
- Alex uses VOs here (to limit string lenght etc.)

- klasa Tenant ma prop TenandId (jako V)
- but TenantId is not "owned" by Tenand only
- equally well it can be (and is) used by other classes: User ...

c: User in many BCs
- UI = username, tenantId
- inne BC (inne niz bc:identiy) moga zbierac inne dane zw. z User: adres, kontakt, billing info, location...
- n: acz jak jest business need to "bc:identity" tez moze zbierac te dane (i w sumie zawiera: Person ...)
- p/p inne BC powinny - w celu refowania do User - uzywac UnId z bc:identity
- n: pp normalnie raczej nie kopiujesz danych miedzi BC ("1 src of truth") ale "username" to klucz i trzeba
- q: jak VV refuje do User'a z innych BC, bo mamy to UnId z 2 pol


### Digging for Essential Behavior

- raczej nie uzywaj setters/getter (ani w E, ani w VO)
- chyba ze wynika to z UL - wtedy ok
- jak w 1 req wolasz kilka setters - to jest to bardzo podejrzane

przyklad - aktywacja tenant
- wystaw metody activate/deactivate
- to zgodne z zasada EE: "intention revealing interface"

c: VV worked out 2 patts for security:
- User
- Fundamental Identity

sample E:
- User zawiera Person (both extends ConcurrencySafeEntity)
- Person zawiera VO: ContactInfo and name (string)

c: E User ma metody
- change password - normalne
- change "personal contact information" - ciekawe
  - modyfikuje nested entity "contact information"
  - a nie samego User'a

c: ukrywanie detali
- User ma property 'password' ale niedostepne publicznie
- publicznie dostepna jest met: 'change password'

c: ukrywanie detali
- obiekt User wystawia publicznie obiekt Person
- ale pp to sie zmieni - bo nie kazdy user jest person
- wowczas publicznie trzeba bedzie wystawic pole z interfact Principal


### Roles And Responsibilities

- ogolnie odkrywanie roles & resps to wazny element modelowania

- w OO interfejs zwykle okresla role obiektu
- klasa może implementować wiele interfejsów / roles
- c: jesli klasa nie implementuje interfejsów - to ma rolę reprezentowaną przez publiczne metody

przyklady
- klasa User (bez interfejsów) ma rolę user'a
- klasa X ktora implementuje interfejsy User i Person - ma obie te role

p/p best use case for "role interfaces" is 
- hiding some methods from client
- and exposing only these which are needed


### Construction

constr of E musi zebrac:
- infa potrzebne do identyfikacji E
  - p/p to dotyczy tylko "early entity generation"
  - bo w late nie ma takiej mozliwosci

- jesli E nie jest wyszukiwana przez UI
  - to const zbiera infa uzywane do wyszukania E
  - np: name, desc ...

- c: constr of User takes Person

niezmienniki
- E can contain 1 or more invariants
- if calcing/assuring invariant reqs 
  - setting some state/fields
  - assuring some prop != null
.. then all req infos must be provided in constr

self-encapsulation
- prefered VV pattern
- w const wolaj setter'y (ktore sa protected/private)
- settery: waliduja wartosc i ustawiaja property
- c: nie trzeba wrapować "stringi w VO" (as Alex does) - settery zapewniaja walidacje


### Validation

zakres sprawdzenia poprawności
- pojedynczy atrybuty
- cały obiektu
- kompozycja obiektów


n: attr/obiekt/kompozycja moga miec "temporary invalid/incomplete state"
- jest to ok w sensie technicznym/biznesowym
- walidacja tylko sprawdza poprawnosc stanu



WALIDOWANIE ATRYBUTÓW

- ch6-vo desc how to protect single attrs

- ustawianie wartosci attr i walidowanie - to dwie różne sprawy
- do ustawiania attr use self-encapsulation (VV mocno to recomenduje)

self-encapsulation (SE)
- do attr'ow klasy dostajesz sie przez setter'y/gettery
  - nawet "class-owner of attrs" ich uzywa
- zaleta
  - abstrakcja od zmiennych (gt: isn't too abstr?)
  - prosta "walidacja" przy setter'ach

c: SE to nie jest walidacja
- walidacje robia walidatory, a nie obiekty domenowe
- SE to bardziej: asercja, design by contract

przykład - klasa VO EmailAddress 
- w konstruktorze pobiera string:adres
- constr calls setAddress(a)
- setter robi
  - walidacje (czy null, czy ok length, czy RegExp email ...) 
  - finalne ustawienie zmiennej

c: podczas przypisania obiektu VO jako zmienna E 
- E nie moze zwalidowac wewn. stanu VO
- E moze spr. tylko czy obiekt != null
- VO musi samo zagwaranotwac spojnosc

c: gdzie sprawdzic "limit dlugosci string" etc
- niektorzy sprawdzenie limitu string zostawiaja bazie
  - rzuci excep jesli string przekracza limit np. 100 znakow
- wg VV modelu moze sprawdzac takie niskie detale
- dodatkowo model rzuci dokladny excep "ktora wartosc jest zla"
  - baza rzuci general exception (bez info ktory string jest too long)



VALIDATE WHOLE OBJECTS

- w celu walidacji: musisz miec dostęp do wszystkich atrybutów obiektu
- use patterns: specification (EE), strategy (Gamma)

deferred validation pattern (by Cunningham)
- sprawdzenie wykonujemy w "ostatnim możliwym momencie"
- szczegółowo sprawdzamy obiekt
- DVP można użyć do 1 obiektu i kompozycji

- walidowanie E wymaga dostępu do calego stanu
- dodanie walidacji do E jest zle bo
  - W często sie zmienia (częściej niż E)
  - responsibility of E to trzymanie stanu (SRP)

- walidator buduj jako osobna klase
- W umieść w tym samym pakiecie co E
- attrs w E zrob widoczne dla W ("package" or higher, "private" odetnie dostep)
- VV mówi nawet o dostępie "public"
  - jesli będzie to potrzebne (bo np walidator jest poza pakietem E)
  - ale to złe dla modelu

- klasa W może implementować pattern: specification lub strategy
- W przypadku wykrycia problemu W
  - notyfikuje klienta 
  - lub zapisuje informacje do odczytania później
- ważne żeby walidacja robic "do konca" (a nie rzucac excep on 1st problem)

impl
- create abstract class Validator
- konkretny walidator np E1 rozszerza abstrakcyjny i nadpisuje validate()
- validate() zwyczajnie sprawdza stan obiektu
- w przypadku problemów zgłasza błędy do NotificationHandler 
  - który jest zdef. w abstract Validator
- NotiHandler
  - moze byc uniwersalny: zbiera info o problemach w postaci string
    nh.NotifyProblem("field A incorrect");
    nt.NotifyProblem("field X bad");
  - mozemy specjalizowany: "E1NotiHandler : NotiHandler" i zglaszac problemy jako
    nh.NotiIncorrectX()
    nh.NotiBadY()

- n: walidowana encja jest param. constr. Walidatora

- client calls W by:
  MyE1.validate(ValidationNotificationHandler vnh){
    (new MyE1Validator(this, vnh)).validate();
  }
- E nie wie jak robic walidacje
- acz ma metode validate wiec wie o mozliwosc 'samo-walidacji'



VALIDATING OBJECT COMPOSITIONS

- use deferred validation

flow
- create walidator object
- pass to it set/composition of objects

- possibly do validation in DomainService
  - DS reads set of objects from Repo
  - then DS does V
    - single object
    - composition

when to validate
- listen DEvents which can trigger validation and do validation



### Change Tracking

// short about use DEvents + EventStore to track E changes