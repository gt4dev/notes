# CH5 ENTITIES

- devs mają tendencję do skupiania się na danych a nie domenie
  - nie buduja "rich behaviors" 
  - skupiaja sie tylko na danych, atrybutach, asocjacjach
- to bez sensu- bo sa tool'e do generowania takiego ('data-drive')


## Why We Use Entities

- use entity 
  - to express individuality of object
  - when you want distinguish object from others
- entity is identified and can change (even heavely) in time
  - so final E can be totally diff from 'start version'
  - but still has the same identity

that diffs E from VO
- unique identity
- mutability

n: devs often overuse Es, where VO would be better than E
but if anyway you "overuse E" then maybe you need CRUD not DDD?


## Unique Identity (UI)

UI = base of entity

n: on start of projecting E
- focus on
  - defining identity
  - ways of finding, matching Es
- maybe add important behaviours for E (and attrs required by it)
- forget about rest (other attrs/behaviours)

- human readable identities can be used for ease finding/matching Es

use VO as holders for I
- VO is immutable = assure I stability
- VO can have methods
  - this encapsulate knowlegde (eg. can extract date-time from I)
  - knowlegde is not leaking to clients

typical strategies of creating I (in order: easy -> hard)
- user provides vaules which create UI (app assure that values are ok)
- aplikacja generuje identity
- persistence store zapewnia identity
- inny BC już mam entity z UI i my je używamy



### User Provides Identity

user ustala wartosci I
- albo sam wprowadza (n: human readable)
- albo wybiera z listy

problem
- podane przez user wartości mogą być bledne, user bedzie chcial je poprawic potem
- a identity musi być niezmienne
- choc czasem można pozwolić user'owi na zmiane

chyba lepiej dane od user'a zapisać w zwykłych properties
- nie rob z nich UI



### Application Generates Identity

to quite reliable sposoby generowanie unikalnych identity
trzeba uważać w klastrach i rozproszonych węzłach

zwykle do wyliczenie ID używane są
- czas węzła w milisekundach
- IP węzła
- ID obiektu factory ktory generuje ID
- random number

- id zwykle ma 128 bitów unique values
- reprezenowanych w 32B textu (hexach) lub 36B z hyphenami

c: w Java UUID mozna generowac na 4 sposoby (random, z "input text" ..)

- czasem (rzadko) problemem jest rozmiar ID pamięci
- stosuj wowczas ID'y z bazy (8B Long, 4B int)

- dla lokalnych (w ramach Agg) entity można skrócić identity do kilku bajtów
- acz "aggregat root" wymaga global unique identity


custom/combined identity - example
- join in ID a few element, np: "APM-20210324-123abc" gdzie np
  - APM = TLS nazwy BC'a
  - data utworzenie ID
  - krotkie UI
- takie ID moze byc HumanReadable
  - co jest wazne przy komunikacji z klientem/czlowiekem
- ID takie trzymaj w VO (z pomocniczymi metodami eg MyId.GetDate():MyDate


- kod tworzenie UI umiesc w repo np
  MyAggRepo.NextIdentity():MyAggId
- q: gdzie metoda do gener ID dla non-agg/local?
  - a: pewnie w repo 'root/owning aggregatu'


### Persistence Mechanism Generates Identity

- c: unique values = f(type)
  int =  4B = 2*10^9
  long = 8B = 9*10^18

- zaleta: zawsze bedziemy miec unikalna wartosc ID
- wada: wydajnosc ("in app ID" is much faster)

fix for performance = prefetch more IDs and cache
- problem: gaps in IDs if server restarts
- trying to restore IDs from "losts/gaps" can be more expensive than worth

impl late ID - typical way
- object gets ID after insert to DB
- hmb config
  <id name="PropertyInClass" type="long" column="product_id">
    <generator class="sequence|or|native" ...
  </..

impl early IDs
- yes, early is possible for "DB src"
- create in repo method NextIdentity():ProductId
- NextIdentity can create and return "next value" from DB sequence/cache/...


### Another Bounded Context Assigns Identity

- n: see integration details are in chapters: 3-ctx-maps, 14-integr-bcs

flow
- 1st: find partucular identity in BC2 by
  - API exposed by BC2
    - searching, fetching data matching criterias (email, tax id ..)
  - show this data (if many rows) to user
  - user picks 1 "row" - get identity from it
- use this identity locally!!! in your BC1

problems
- data in BC2 can heavily change and maybe these changes must visible in BC1?
- BC1 should listen for Domain Events from BC2 (so changes can be updated)
- sometimes BC1 modify "imported data" and must send (by DEvents) to BC2

- it's hardes way of generating identity
  - out entity (its identity) depends on outer system
- pick as last way



### When the Timing of Identity Generation Matters

generowanie identity moze nastapic
- early - as part of constructing object
- late - podczas persystencji obiektu

- zaleznie od reqs - mozna stosowac oba
- VV recommends setting ID early

flow for late ID
- client 
  - creates object (w/o ID)
  - add it to repo
- repo persist obj
- ID is generated (by DB, but not only)
- ID is assigned to entity object

"late ID" is problematic 
- with domain events
  - when obj is created - we want to generate event
  - but ID is not yet assigned
  - thus for DE use early ID
- when Entity is in Set
  - in Set there can be only 1 entity without ID
  - thus
    - either use early ID
    - or override equals - so distingiush entities by attributes (VO-like)


### Surrogate Identity (SI)
- identyfikator zastepczy

- typowy ORM (eg: HBM) preferuje natywnych primer identity z baz danych
- on DB side it can be: numeric, sequence; 
- on VM side: long, int
- domena czesto wymaga innego identity np: guid, user-name ...
  
easy solution solution - use 2 identities
- 1st - from domain (and fulfilling domain reqs)
- 2nd - surrogate identity - spelnia ORM reqs

impl
- add to MyEntity field: "long id" (or int ..)
- add to my_entity column: "id (primary key)"
- set HBM mapping

hide & optimize SI
- hide SI on client/model side
- create "abstract class IdentifiedDomainObject" with field "private long id"
c: it's LaterSuperType pattern (from EAA)
n: in CH10-Agg VV creates "EntityBase" with a above + optimistic concurency

c: VV ustawia db constranins w table
- SI - primary na kolumnie: id
- domain identity - unique na: tenant_id_id, username
n: DI tez jest zamodelowane w DB

n: przykladzie User
- identyfikator domenowy składa się z dwóch pol (TenantId, username)
- pola te nie wyrozniaja sie z kodu klasy User (ok, poza uzyciem ich w equals)
- conc: client E (na bazie jej API) "musi zgadnac" co jest jej ID
- w DB jest zalozony unique key - ale more to protect data than identify

- SI w DB can be used to keep referential integrity miedzy tabelami
- q: tez miedzy agregatami?


### Identity Stability

- in most cases: identity must be stable through the whole entity life

protect identity
- make setters, fields protected/private (so client can't change it)
- set identity fields - only by (private) setters 
  - which checks is it 1st field init or 2nd
  - if 2nd - throws excep


## Discovering Entities and Thier Intrinsic Ch-cs

- UL z BC daje slownictwo do projektowania modelu
- UL musi być wypracowany z ekspertami i przez analize wymagań
- finalnie caly zepol porozumiewa sie "uzywajac UL"
- c: uznanie mapowania nouns/verbs na klasy/metody to ZBYT DUZE uproszczenie

- on start: mozna zapisać UL jako słownik pojęć i zbiór prostych przypadków użycia
- finalnie: UL jest wyrazany TYLKO przez kod (bo trudno trzymać sync miedzy docs i kodem)


### Unconvering Entities and Properties

sposoby zmiany wartosc E:
- primitive property is changing
- whole VO is replaced

n: w encji User (i wszedzie indziej)
- UI jest stale (TenantId, username)
- all other data is changing 'in time' (Person, ..)

- VV uzywa primitive string to keep username 
- cause here are no any special behavious
- Alex is using VOs here (to eg limit string lenght)

- klasa Tenant ma prop TenandId (jako V)
- but TenantId is not "owned" by Tenand only
- equally well it can be (and is) used by other classes: User ...

c: User in many BCs
- UI = username, tenantId
- inne BC (nie bc:identiy) moga zbierac inne dane zw. z User: adres, kontakt, billing info, location...
- n: acz jak jest potrzeba to "bc:identity" moze (i zawiera) zawierac more data: Person ...
- p/p inne BC powinny - w celu refowania do User - uzywac UI z bc:identity
- n: pp normalnie raczej kopiujesz danych miedzi BC ("1 src of truth") ale "username" to klucz i trzeba
- q: jak VV refuje do User'a z innych BC, mamy to UI z 2 pol, ...


### Digging for Essential Behavior

- raczej nie uzywaj setters/getter (ani w E, ani w VO)
- chyba ze wynika to z UL - wtedy to ok
- jak w 1 req wolasz kilka setters - to jest to bardzo podejrzane

przyklad - aktywacja tenant
- wystaw metody activate/deactivate
- c: to zgodne z zasada EE: "intention revealing interface"

c: VV worked out 2 patts for security:
- User
- Fundamental Identity

sample E:
- User zawiera Person (entity)
- Person zawiera VO: ContactInfo and name (string)

c: E User ma metody
- change password - normalne
- change "personal contact information" - ciekawe
  - modyfikuje nested entity "contact information"
  - a nie samego User'a

c: ukrywanie detali
- User ma property 'password' ale niedostepne publicznie
- publicznie dostepna jest met: 'change password'

c: ukrywanie detali
- obiekt User wystawia publicznie obiekt Person
- ale pp to sie zmieni - bo nie kazdy user jest person
- wowczas publicznie trzeba bedzie wystawic pole z interfact Principal


VVVVVVVVVVVVVVVVVVVVVVVVVVVV CONT. HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVV

### Roles And Responsibilities

- odkrywanie roles & resps to wazny element modelowanie (nie tylko dla E)

- w OO interfejs zwykle okresla role obiektu
- klasa może implementować wiele ról, tj interfejsów

- c: jesli klasa nie implementuje interfejsów - ma rolę reprezentowaną przez publiczne jej metody

przyklady
- klasa User (bez interfejsów) ma rolę user
- jesli klasa implementuje interfejsy User i Person - ma dwie role

- pp best use case for "role interfeces" is hiding methods from client
- class (by interface) exposes only these methods which are needed for client


### Construction

przy tworzeniu instancji E - constr musi zebrac:
- infa potrzebne do identyfikacji E
  - acz to dotyczy pp tylko early entity generation - w late nie ma takiej mozliwosci
- infa wymagane do wyszukania E (? - not sure)
  - jeśli E jest szukana po name, desc ... -  to te infa musza byc dane w constr
  - np. constr w User ustawia Person ...

niezmienniki
- E can contain 1 or more invariants (notion from Agg)
- if calcing/assuring invariant reqs 
  - setting some state/fields
  - some prop can't be null
  .. then all req infos must be provided in constr

self-encapsulation
- VV czesto w const wywoluje setter'y (ktore sa protected/private)
- settery: waliduja wartosc i ustawiaja property
- c: nie trzeba wrapować "stringi w VO" (as Alex does) - walidacje mozna zrobic w w/w sposob


### Validation

### Change Tracking