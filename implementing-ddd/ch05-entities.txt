# CH5 ENTITIES

- devs mają tendencję do skupiania się na danych a nie domenie
  - nie buduja "rich behaviors" 
  - buduja struktury, atrybuty, asocjacje
- to bez sensu - sa tool'e do generowania kodu z modelu db


## Why We Use Entities

- use entity 
  - to express individuality of object
  - when you want distinguish object from others
- entity is identified and can change (even heavely) in long time
  - final E can be totally diff from 'start version'
  - but still has the same identity

that diffs E from VO:
- unique identity
- mutability

n: devs often overuse Es, where VO would be better
if you "overuse E" then maybe you need CRUD not DDD


## Unique Identity (UI)

UI = base of entity

n: on start of projecting E
- focus on
  - defining identity
  - ways of finding, matching Es
- add important behaviours for E (and attrs required by it)
- forget about rest (other attrs/behaviours)

- human readable identities can be used for ease finding/matching Es
- but it's not oblig. for finding Es

use VO as holders for I
- VO is immutable = assure I stability
- VO can have methods
  - this encapsulate knowlegde (eg. can extract date-time from I)
  - knowlegde is not leaking to clients

typical strategies of creating I (in order: easy -> hard)
- user provides vaules which create UI (app assure that values are ok)
- aplikacja generuje identity
- persistence store zapewnia identity
- inny BC mam entity z UI i my je używamy


### User Provides Identity

user ustala wartosci I
- albo sam wprowadza
  - so it's human readable
- albo wybiera z listy

problem
- podane przez user wartości mogą być bledne, user bedzie chcial je poprawic potem
- a identity musi być niezmienne
- choc czasem można pozwolić user'owi na zmiane

- chyba lepiej dane od user'a zapisać w zwykłych properties
- nie rob z nich UI


### Application Generates Identity

quite reliable way of generating unique identity
trzeba uważać w klastrach i rozproszonych węzłach

zwykle do wyliczenie ID używane są
- czas węzła w milisekundach
- IP węzła
- ID obiektu factory ktory generuje ID
- random number

- id zwykle ma 128 bitów unique values
- reprezenowanych w 32B textu (hexach) lub 36B z hyphenami

c: w Java UUID mozna generowac na 4 sposoby (random, z "input text" ..)

- czasem (rzadko) problemem jest rozmiar ID w pamięci
- stosuj wowczas ID'y z bazy (8B long, 4B int)

- dla lokalnych (w ramach Agg) entity można skrócić identity do kilku bajtów
- acz "aggregat root" wymaga global unique identity

custom/combined identity - example
- join in ID a few element, np: "APM-20210324-123abc" gdzie np
  - APM = TLS nazwy BC'a
  - data utworzenie ID
  - krotkie UI
- takie ID jest HumanReadable
  - a to jest wazne przy komunikacji z klientem/czlowiekem
- ID takie trzymaj w VO 
  - z ew. metodami MyId.GetDate():MyDate

- tworzenie UI wrzuc do repo
  MyAggRepo.NextIdentity():MyAggId
// q: gdzie metoda do gener ID dla non-agg/local?
// a: pewnie w repo 'root/owning aggregatu'


### Persistence Mechanism Generates Identity

- c: amount of unique values = f(type of field)
  int =  4B = 2*10^9
  long = 8B = 9*10^18

- zaleta: zawsze bedziemy miec unikalna wartosc ID
- wada: wydajnosc ("in app ID" is much faster)

fix for performance = prefetch more IDs and cache
- problem: gaps in IDs if server restarts
- trying to restore IDs from "losts/gaps" can be more expensive than worth

impl late ID - typical way
- object gets ID after insert to DB
- hmb config
  <id name="PropertyInClass" type="long" column="product_id">
    <generator class="sequence|or|native" ...
  </..

impl early IDs
- yes, early is possible for "DB src"
- create in repo method NextIdentity():ProductId
- NextIdentity can create and return "next value" using DB sequence/cache/...


### Another Bounded Context Assigns Identity

flow
- 1st: find partucular identity in BC2 by
  - BC2 exposes API, use it to search data [IDs] matching criterias (email, tax id ..)
  - if many rows: show this data to user
  - user picks 1 "row" -> you get identity from it
- use this (exactly copied!) identity locally!!! in your BC1

problems
- data in BC2 can heavily change and maybe these changes must visible in BC1
  - BC1 should listen for Domain Events from BC2 (so changes can be updated)
- sometimes BC1 modify "imported data" and must send (by DEvents) to BC2

- it's the hardes way of generating identity
- our entity (its identity) depends on outer system
- pick as last way


### When the Timing of Identity Generation Matters

generowanie identity moze nastapic
- early - as part of constructing object
- late - podczas persystencji obiektu

- zaleznie od reqs - mozna stosowac oba
- VV recommends setting ID early

flow for late ID
- client 
  - creates object (w/o ID)
  - add it to repo
- repo persist obj
- ID is generated (by DB etc)
- ID is assigned to entity object

"late ID" is problematic
- with domain events
  - when obj is created - we want to generate event
  - but ID is not yet assigned
  - thus for DE use early ID
- when Entity is in Set
  - in Set there can be only 1 entity without ID
  - thus
    - either use early ID
    - or override equals - so distingiush entities by attributes (VO-like)


### Surrogate Identity (SI)

- typowy ORM (HBM) preferuje natywne primer identity [z DB]
- this identity on 
  - DB side it can be: numeric, sequence
  - VM side: long, int
- domena czesto wymaga innego identity np: guid, user-name ...

solution - use 2 identities
- 1st - domain - fulfil domain reqs
- 2nd - surrogate identity - fulfil ORM reqs

impl
- add to MyEntity field: "long id" (or int ..)
- add to my_entity column: "id (primary key)"
- set HBM mapping

hide & optimize SI
- hide SI on client/model side
- create "abstract class IdentifiedDomainObject" with field "private long id"
- it's LayerSuperType pattern (from EAA)

c: in CH10-Agg VV creates "EntityBase" with a above + optimistic concurency

c: VV ustawia db constranins w table
- surrogate indetity - "primary" na col: id
- domain identity - "unique" na cols: tenant_id_id, username

n: przykladzie User
- domain ID constis of TenantId + username
- pola te w kodzie Java sa zwyklymi polami + sa uzyte equals/hashCode
- w DB jest zalozony unique key

- SI w DB can be used to keep referential integrity miedzy tabelami
// q: tez miedzy agregatami?


### Identity Stability

- in most cases: identity must be stable through E life time

protect identity
- make setters, fields - protected/private (so client can't change it)
- set identity fields - setters which
  - checks is it 1st field init
  - if 2nd - throws excep


## Discovering Entities and Thier Intrinsic Ch-cs

- UL daje slownictwo do projektowania modelu
- UL musi być wypracowany z ekspertami i przez analize wymagań
- finalnie caly zepol porozumiewa sie uzywajac UL
- c: mapowanie nouns/verbs na klasy/metody to ZBYT DUZE uproszczenie przy projektowania modelu

- on start: mozna zapisać UL jako słownik pojęć i zbiór prostych przypadków użycia
- finalnie: UL jest wyrazany TYLKO przez kod (trudno trzymać sync miedzy docs i kodem)


### Unconvering Entities and Properties

zmiany wartosc E:
- set primitive property
- replace whole VO

przyklad: entity User
- id jest stale (tu: TenantId, username)
- all other data is changing (Person, ..)

c
- VV uzywa primitive string to keep username 
- cause here is no additional behaviour
- Alex uses VOs here (to limit string lenght etc.)

c
- Tenant ma prop TenandId (jako V)
- but TenantId is
  - not "owned" by Tenand only
  - used "globally" (by User ..)

c: User in many BCs
- id = username, tenantId
- native BC = identiy
- inne BC moga zbierac dodatkowe dane o User: adres, kontakt, billing info, location...
  - acz (jak jest justified business need) to w/w dane mozna zbierac i w BC:Identity 
  - identity w sumie zawiera: Person ...
- p/p inne BC musze refowac User przy uzycie full ID z bc:identity (tenantId + username)
- p/p normalnie nie kopiujesz danych miedzi BC ("1 src of truth") ale 
  - "username" to klucz i trzeba
  - w momencie uzycie jako czesc ID stal sie niezmienny
// q: jak VV refuje do User'a z innych BC, bo mamy to UnId z 2 pol


### Digging for Essential Behavior


- raczej nie uzywaj setters/getter (ani w E, ani w VO) - tylko UL property names
  - chyba ze wynika to wprost z UL
- jak w 1 req wolasz kilka setters - to jest to bardzo podejrzane

przyklad
- wystaw metody activate/deactivate
  - a nie setActive(true)
- to zgodne z zasada EE: "intention revealing interface"

c: VV worked out 2 patts for security:
- User
- Fundamental Identity

sample E:
- User zawiera Person (tez E, both extends ConcurrencySafeEntity)
- Person zawiera VO: ContactInfo and name (string)

sample methods: E User
- changePassword - normalny flow plus LOGIKA [a nie anemia]
  - spr. nowe password
  - on end: publish event UserPasswordChanged
    - c: w DE jest full id (uname + tenandId)
- changePersonalContactInformation - ciekaw
  - replaces field of nested entity "contact information"
  - pp User is root, Person is nested - thus modifying is done by root

sample: ukrywanie detali
- User ma property 'password' ale niedostepne publicznie
- publicznie dostepna jest met: 'change password'

c: ukrywanie detali
- obiekt User wystawia publicznie obiekt Person
- ale pp to sie zmieni - bo nie kazdy user jest person
- wowczas publicznie bedzie wystawione attr Principal Principal


### Roles And Responsibilities


- odkrywanie roles & resps to wazny element modelowania

- w OO interfejs zwykle okresla role obiektu
- klasa może implementować wiele interfejsów = roles
- jesli klasa nie implementuje interfejsów - to ma rolę reprezentowaną przez publiczne metody

przyklady
- klasa User (bez interfejsów) ma rolę user'a
- klasa X ktora implementuje interfejsy User i Person - ma obie te role

p/p best use case for "role interfaces" is 
- hiding some methods from client
- exposing only needed


### Construction

constr of E musi zebrac:
- infa potrzebne do identyfikacji E
  - p/p to dotyczy tylko "early entity generation"
  - bo w late nie ma takiej mozliwosci
- jesli E nie jest wyszukiwana przez ID
  - to constructor zbiera infa uzywane do wyszukania E
  - np: name, desc ...

- c: constr of User takes Person

niezmienniki
- E can contain 1 or more invariants
- constructor gets all data required to assure/check E invariants
- et
  - set states/fields
  - make prop != null

self-encapsulation
- VV reced pattern
- w constr wolaj setter'y (ktore sa protected/private)
- settery: waliduja wartosc i ustawiaja property

- nie trzeba wrapować "strings w VO" (as Alex does)
- settery zapewniaja walidacje
- chyba ze chcesz dodatkowe behaviour


### Validation


zakres walidacji
- 1 atrybut
- cały obiekt
- kompozycja obiektów


n: attr/obiekt/kompozycja moga miec "temporary invalid/incomplete state"
- jest to ok (technicznie/biznesowo)
- walidacja tylko sprawdza poprawnosc stanu


WALIDOWANIE ATRYBUTÓW

- ch6-vo descs more how to protect single attrs

- ustawianie wartosci attr i walidowanie - to dwie różne sprawy
- to set attr use self-encapsulation (VV recoms)

self-encapsulation (SE)
- do attr'ow klasy dostajesz sie przez setter'y/gettery
- nawet "class-owner of attrs" ich uzywa
- zaleta
  - abstrakcja od zmiennych (gt: isn't too abstr?)
  - prosta "walidacja" przy setter'ach

c: SE to nie jest walidacja
- walidacje robia walidatory, a nie obiekty domenowe
- SE to bardziej asercja, design by contract

przykład - klasa VO EmailAddress
- w konstruktorze pobiera string:adres
- constr calls setAddress(string)
- setter robi
  - walidacje (czy null, czy ok length, czy RegExp email ...) 
  - finalne ustawienia attr

n: podczas przypisania obiektu VO do E 
- E nie moze zwalidowac wewn. stanu VO
- E moze spr. tylko czy obiekt != null
- VO musi samo zagwaranotwac spojnosc

c: gdzie sprawdzic "limit dlugosci string" etc
- niektorzy zostawiaja to DB
  - rzuci excep jesli string przekraczy limit np. 100 znakow
- wg VV modelu moze to tez sprawdzac
- dodatkowo model rzuci dokladny excep "ktora wartosc jest zla"
  - baza rzuci general exception (bez info ktory string jest too long)


VALIDATE WHOLE OBJECTS

- walidacja wymaga dostęp do wszystkich atrybutów obiektu
- use patterns: specification (EE), strategy (Gamma)

Deferred Validation Pattern (by Cunningham)
- sprawdzenie wykonujemy w "ostatnim możliwym momencie"
- szczegółowo sprawdzamy obiekt
- DVP można użyć do 1 obiektu i kompozycji

- walidowanie (W) E wymaga dostępu do calego stanu
- dodanie W do E jest zle bo
  - W często sie ona zmienia (częściej niż E)
  - responsibility of E to trzymanie stanu (SRP) a nie W

- walidator buduj jako osobna klase
- W umieść w tym samym pakiecie co E
- attrs w E zrob widoczne dla W ("package" or higher, "private" odetnie dostep)
- VV mówi nawet o dostępie "public"
  - jesli będzie to potrzebne (bo np walidator jest poza pakietem E)
  - ale to złe dla modelu

- klasa W może implementować pattern: specification lub strategy
- W przypadku wykrycia problemu W
  - notyfikuje klienta 
  - lub zapisuje informacje do odczytania później
- rob walidacje "do konca" (nie rzucac excep on 1st problem)

impl
- create abstract class Validator
- konkretny walidator np E1 rozszerza abstrakcyjny i nadpisuje validate()
- validate() zwyczajnie sprawdza stan obiektu
- w przypadku problemów zgłasza błędy do NotificationHandler 
  - który jest zdef. w abstract Validator
- NH moze byc
  - uniwersalny: zbiera info o problemach w postaci string
    nh.NotifyProblem("field A incorrect");
    nh.NotifyProblem("field X bad");
  - specjalizowany: "E1NotiHandler : NotiHandler" i zglaszac problemy jako
    nh.NotiIncorrectA()
    nh.NotiBadX()

- n: walidowana encja podaj do W jako param constr

- client calls W by:
  MyEntity.validate(ValidationNotificationHandler vnh){
    (new MyEnityValidator(this, vnh)).validate();
  }
- E nie wie jak robic walidacje
- ale ma metode validate() wiec wie o mozliwosc walidacji


VALIDATING OBJECT COMPOSITIONS


- use deferred validation

flow
- create walidator object
- pass to it composition [set/"big" graph]

- do validation (V) in DomainService [dep on reqs]
  - DS reads set of objects from Repo
  - DS does V - by validator
    - single object
    - composition

when to start to V?
- listen DEvents which trigger validation


### Change Tracking

// short about use DEvents + EventStore to track E changes